<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>ReRoozen&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ReRoozen&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ReRoozen&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="ReRoozen&#039;s Blog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="ReRoozen&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="ReRoozen"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"ReRoozen's Blog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"ReRoozen"},"publisher":{"@type":"Organization","name":"ReRoozen's Blog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="ReRoozen&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-04-23T06:30:10.000Z" title="2024/4/23 14:30:10">2024-04-23</time>发表</span><span class="level-item"><time dateTime="2024-04-24T07:16:25.918Z" title="2024/4/24 15:16:25">2024-04-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Assembly-Language/">Assembly Language</a></span><span class="level-item">4 分钟读完 (大约651个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/04/23/ARMAsm/01-Architecture/">ARMv8 Architecture</a></p><div class="content"><h1 id="AArch64"><a href="#AArch64" class="headerlink" title="AArch64"></a>AArch64</h1><h2 id="标量数据类型"><a href="#标量数据类型" class="headerlink" title="标量数据类型"></a>标量数据类型</h2><table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Size(bits)</th>
<th align="center">C++ Type</th>
<th align="center"><code>&lt;cstdint&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Singned</td>
<td align="center">8</td>
<td align="center"><code>char</code></td>
<td align="center"><code>int8_t</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">16</td>
<td align="center"><code>short</code></td>
<td align="center"><code>int16_t</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">32</td>
<td align="center"><code>int</code>, <code>long</code></td>
<td align="center"><code>int32_t</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">64</td>
<td align="center"><code>long</code>, <code>long long</code></td>
<td align="center"><code>int64_t</code></td>
</tr>
<tr>
<td align="center">Unsigned</td>
<td align="center">8</td>
<td align="center"><code>unsigned char</code></td>
<td align="center"><code>uint8_t</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">16</td>
<td align="center"><code>unsigned short</code></td>
<td align="center"><code>uint16_t</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">32</td>
<td align="center"><code>unsigned int</code>, <code>unsigned long</code></td>
<td align="center"><code>uint32_t</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">64</td>
<td align="center"><code>unsigned long</code>, <code>unsigned long long</code></td>
<td align="center"><code>uint64_t</code></td>
</tr>
<tr>
<td align="center">Float</td>
<td align="center">32</td>
<td align="center"><code>float</code></td>
<td align="center">n&#x2F;a</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">64</td>
<td align="center"><code>double</code></td>
<td align="center">n&#x2F;a</td>
</tr>
</tbody></table>
<h2 id="标量指令"><a href="#标量指令" class="headerlink" title="标量指令"></a>标量指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; Immediate</span><br><span class="line">mov w0, 42    ; w0 = 42</span><br><span class="line">add x1, x0, 8 ; x1 = x0 + 8</span><br><span class="line">lsl w2, w1, 2 ; w2 = w1 &lt;&lt; 2</span><br><span class="line"></span><br><span class="line">; Register</span><br><span class="line">mov x1, x0       ; x1 = x0</span><br><span class="line">mul x2, x1, x0   ; x2 = x1 * x0</span><br><span class="line">smull x2, w0, w1 ; x2 = w0 * w1</span><br><span class="line"></span><br><span class="line">; Load/Store</span><br><span class="line">ldr x0, [sp] ; x0 = *sp</span><br><span class="line">str w0, [x4] ; *x4 = w0</span><br></pre></td></tr></table></figure>

<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="标量-整型"><a href="#标量-整型" class="headerlink" title="标量&#x2F;整型"></a>标量&#x2F;整型</h3><p>ARMv8的体系结构中有31个通用寄存器，64位的名称为 <code>X0-X30</code>，32位的名称为 <code>W0-W30</code>。<br><code>X/W0-X/W28</code> 可以随意用于加载数据、保存临时变量，<code>X/W29</code> 用于保存栈帧指针，<code>X/W30</code> 用于保存函数的返回地址。<br>在硬件结构上并没有 <code>X/W31</code> 寄存器，但是这个寄存器的编码用于表示0寄存器。</p>
<p>除了通用寄存器之外，ARMv8还有一个 <code>SP</code> 寄存器保存栈指针，一个 <code>PC</code> 作为程序计数器，一个 <code>NZCV</code> (Negative, Zero, Carry, oVerflow) 寄存器用于保存状态。</p>
<h3 id="向量-浮点"><a href="#向量-浮点" class="headerlink" title="向量&#x2F;浮点"></a>向量&#x2F;浮点</h3><p>ARMv8的体系结构中有32个SIMD&#x2F;向量寄存器，每个寄存器长度为128 bits，命名为 <code>V0-V31</code>。<br>整型只能被打包为向量才能保存在这些寄存器中，而浮点数无论标量还是向量都要保存在这些寄存器中。</p>
<p>完整的128位寄存器根据保存的数据类型在程序中有不同的写法，都以寄存器 <code>V2</code> 为例：<br>保存一个128位类型时写作 <code>v2.1q</code>；保存2个64位类型时写作 <code>v2.2d</code>；<br>保存4个32位类型时写作 <code>v2.4s</code>；保存8个16为类型时写作 <code>v2.8h</code>；保存16个8位类型时写作 <code>v2.16b</code>。<br>另一方面，这些寄存器也可以只用低64位保存数据，一次写作 <code>v2.1d</code>, <code>v2.2s</code>, <code>v2.4h</code>, <code>v2.8b</code>。</p>
<blockquote>
<p>ARMv7中的向量寄存器被称为 <code>Q</code>。</p>
</blockquote>
<h2 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h2><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldr w1,[x0] ; w1 = *x0</span><br><span class="line">ldr x1,[x0] ; x1 = *x0</span><br></pre></td></tr></table></figure>

<h3 id="寄存器-偏移量寻址"><a href="#寄存器-偏移量寻址" class="headerlink" title="寄存器+偏移量寻址"></a>寄存器+偏移量寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ldr w1, [x0,20]        ; w1 = *(x0 + 20)</span><br><span class="line">ldr x2, [x1,x0]        ; x2 = *(x1 + x0)</span><br><span class="line">ldr w2, [x1,x0,lsl 2]  ; w2 = *(x1 + (x0&lt;&lt;2))</span><br><span class="line">ldr w2, [x1,w0,uxtw 2] ; w2 = *(x1 + (w0&lt;&lt;2))</span><br></pre></td></tr></table></figure>

<h3 id="索引寻址"><a href="#索引寻址" class="headerlink" title="索引寻址"></a>索引寻址</h3><p>取递增后地址的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldr w1, [x0,4]!        ; w1 = *(x0 + 4); x0 += 4</span><br><span class="line">ldr x2, [x1,x0]!       ; x2 = *(x1 + x0); x1 += x0</span><br><span class="line">ldr x2, [x1,x0,lsl 2]! ; x2 = *(x1 + (x0&lt;&lt;2)); x1 += (x0&lt;&lt;2)</span><br></pre></td></tr></table></figure>

<p>取数后递增索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldr x2, [x1], 8         ; x2 += *x1; x1 += 8</span><br><span class="line">ldr x2, [x1], x0        ; x2 = *x1; x1 += x0</span><br><span class="line">ldr x2, [x1], x0, lsl 2 ; x2 = *x1; x1 += (x0&lt;&lt;2)</span><br></pre></td></tr></table></figure>

<h3 id="相对PC偏移量寻址"><a href="#相对PC偏移量寻址" class="headerlink" title="相对PC偏移量寻址"></a>相对PC偏移量寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr x2, label ; x2 = *(pc + label_offset)</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-04-16T05:24:08.000Z" title="2024/4/16 13:24:08">2024-04-16</time>发表</span><span class="level-item"><time dateTime="2024-04-17T02:44:58.754Z" title="2024/4/17 10:44:58">2024-04-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Performance-Profiling/">Performance Profiling</a></span><span class="level-item">11 分钟读完 (大约1715个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/04/16/PerformanceMeasuring/02-MemoryHierarchical/">02-Measuring Memory Hierarchy</a></p><div class="content"><h1 id="缓存的结构"><a href="#缓存的结构" class="headerlink" title="缓存的结构"></a>缓存的结构</h1><p><img src="/gallery/PerformanceProfiling/CPUCache.png"></p>
<p>在一个cache line中，需要至少有两个字的大小才实用，不然有大量硬件会浪费在标签上；最大也不能大过一个内存页的大小。<br>一个字通常是一个指针的大小，即一个64位处理器中，一个cache line至少能容纳2个8字节指针，最大4KB。</p>
<p>在N路组相连的cache中，匹配时先选组，然后在选组内的行；连续但不在一组的数据分布于不同的组中。</p>
<h1 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h1><p>4字节对齐指的是字节地址是4的倍数。<br>实际的缓存和内存引用都是用对齐量寻址的。<br>未对齐引用会产生两次对齐的访问，然后进行一些字节的移位和合并，并选择被引用的字节来实现。</p>
<h1 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h1><p>TLB包含两级：每个物理核都包含的L1 TLB和由多个核心共享L2 TLB。<br>TLB采用物理地址寻址。</p>
<p>页表和cache的设计彼此交互。在64位操作系统中，通常虚拟地址长度48位，物理地址40位。<br>因为页表的大小是4KB，所以虚拟地址的低12位没有用来映射，转而用在选择合适的缓存组。<br>如果一个cache line大小为64Byte，那么低6位用来在cache line内寻找特定的一个字节，所以最多只能有64组。<br>如果每个组里只有1路组相连 (直接映射)，那么L1 cache总共只有4KB；如果是4路组相连，L1 cache大小为16KB。<br>这种耦合性反映了意味着较小的内存页限制了L1 cache的大小。</p>
<h1 id="测量内存"><a href="#测量内存" class="headerlink" title="测量内存"></a>测量内存</h1><h2 id="缓存行的大小"><a href="#缓存行的大小" class="headerlink" title="缓存行的大小"></a>缓存行的大小</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>让缓存一开始不包含我们需要的数据，然后从位置 $X$ 加载一个对齐的字，然后再从 $X+c$ 加载一个字，多次访问。<br>当 $c$ 为 $1&#x2F;4$, $1&#x2F;2$, $1$ 和 $2$ cache line大小时访存状况不同，如下所示：</p>
<p><img src="/gallery/PerformanceProfiling/CacheAccess.png"></p>
<p>通过慢慢增加 $c$ 的到这个循环慢到一个临界点，那么 $c$ 就是cache line的大小。</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>现代cache在访问第N行时，也会顺路把第N+1行也预取了；同时乱序执行在一个周期内会启动多条指令，并且同时会有几十条等待内存响应的加载指令。<br>这让多条指令的未命中的延迟合并在一起。</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>设计一个链表，每项的大小为可能得cache line大小，且是对齐的。<br>这种链表的设计让每一项的加载都依赖于前一项，即 <code>ptr = ptr-&gt;next</code>。<br>这样就避免了因为乱序执行产生的并行加载，但是无法屏蔽数据预取。</p>
<p>为了屏蔽数据预取，一个合乎直觉的做法是把连续的项在地址空间中打乱。<br>但是这样并不够，第N+1项的数据仍然在未来会被访问，产生一次命中。</p>
<h4 id="来自DRAM的影响"><a href="#来自DRAM的影响" class="headerlink" title="来自DRAM的影响"></a>来自DRAM的影响</h4><p>DRAM的访问包括以下几个步骤：预充电-&gt;行访问-&gt;列访问。</p>
<p>预充电是DRAM物理实现上的机制，行访问是DRAM的访存是每次读取一大块数据，然后再列访问取出所需的数据。<br>这三个步骤所需的周期大致相同，都是大致15ns。<br>一个行通常是1024Byte，一根DIMM (内存条) 上有多个DRAM芯片，通常是8个，有效的行大小为8KB；CPU会和每个DRAM芯片以8Byte宽的数据总线相连。<br>如果主板上有多根DIMM，那么会相应变为多倍。<br>以两个DIMM为例，CPU访问连续的行的时候会在两根DIMM上交替进行，以实现两倍的带宽。</p>
<p>由于DRAM提供了一种缓存机制，让CPU访问同一行的数据时只进行一次列访问，延迟降低为第一次访问的 $1&#x2F;3$。因此，来自DRAM的影响也不容小觑。</p>
<h4 id="避免DRAM的影响"><a href="#避免DRAM的影响" class="headerlink" title="避免DRAM的影响"></a>避免DRAM的影响</h4><p>考虑系统为一个双通道的内存布局，我们需要将连续的项放入不同的DRAM行中，且以16KB为一组翻转它们的顺序，使访问顺序与地址递增顺序相反。</p>
<blockquote>
<p>或许把这些项的地址放进一个数组里再shuffle能起到一样的效果？</p>
</blockquote>
<p>这些访存的延迟统计从完全命中到cache失效再到TLB失效一路递增。</p>
<h2 id="一级缓存的总大小"><a href="#一级缓存的总大小" class="headerlink" title="一级缓存的总大小"></a>一级缓存的总大小</h2><p>将N个Byte读入cache中，然后重新读取。<br>如果能够全部放在cache中，那么重新读取就会很快，每次取数据只要几个周期。</p>
<p>不过在真实的测试中，我们不能得到完美的阶梯型的访存周期数。<br>假设中的完美阶梯型需要：(1) L1 cache中没有其它任何数据；(2) cache替换策略为完美的LRU策略。<br>然而这些条件在真实的系统中都是无法实现的。</p>
<h2 id="组相连数"><a href="#组相连数" class="headerlink" title="组相连数"></a>组相连数</h2><p>在组相联的cache中，一个cache line可以处于组内的N个位置中的一个。<br>如果cache line只能位于唯一确定的位置，那么N为1，以此类推。</p>
<p>测量组相连度需要读取一个列表，包含 $A$ 个不同行的地址，并且不断重复：0，4K，8K，12K，0，… (A&#x3D;4)。<br>然后重新读取这个列表，如果很快就说明它们都放在组中，直到开始变慢——这个 $A$ 就是组相连数。</p>
<p>对于L2和L3 cache而言，如果它们的组相联度高于L1，那么测量过程不变；反之，L1 cache会干扰计时结果。</p>
<h1 id="页表的开销"><a href="#页表的开销" class="headerlink" title="页表的开销"></a>页表的开销</h1><p>当我们访问的元素间隔大于4KB时，每次读取数据都会发生一次TLB的失效，但是相对于前面的几种情况，有页表引发的数据失真时可预测的。</p>
<h1 id="缓存利用不足"><a href="#缓存利用不足" class="headerlink" title="缓存利用不足"></a>缓存利用不足</h1><p>缓存通常由地址的低位确定。<br>不妨设cache line大小为64Byte，一组内4路组相联，一共8组，那么需要用到 $[0,6)$ 位寻找特定一个Byte，$[6, 9)$ 位去匹配组，$[9, 12)$ 位和标签匹配判断命中。</p>
<p>如果我们只加载128Byte对齐的数据，那么它只会位于偶数的组，相当于有效cache大小减半。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-04-16T05:24:08.000Z" title="2024/4/16 13:24:08">2024-04-16</time>发表</span><span class="level-item"><time dateTime="2024-04-17T14:32:32.248Z" title="2024/4/17 22:32:32">2024-04-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Performance-Profiling/">Performance Profiling</a></span><span class="level-item">10 分钟读完 (大约1436个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/04/16/PerformanceMeasuring/03-CPUandMemory/">02-Measuring Memory Hierarchy</a></p><div class="content"><h1 id="缓存的行为"><a href="#缓存的行为" class="headerlink" title="缓存的行为"></a>缓存的行为</h1><p>假设CPU中有着如下的L1 cache:</p>
<p><img src="/gallery/PerformanceProfiling/CacheSample.png"></p>
<p>在这样的cache中，连续的内存分布于不同的组。<br>这样的一个垂直的路能够保存4096Byte；相隔4096Byte的的数据又会落入同一个组中。</p>
<p>访问连续的4096Byte能够填充一路中的所有组；然而如果我们每次只访问每4096Byte中的前2组中的数据，那么这个cache的有效大小就变为了原来的 $1&#x2F;32$，会产生大量的cache未命中。</p>
<h1 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h1><p>现在考虑一个1024x1024的双精度矩阵乘法，其一行为8KB。</p>
<p>对于按行连续访问的情况，如果该矩阵的行是64Byte对齐的 (和cache line大小一致)，那么这样的一行能够恰好能够放在64个缓存组中，整个L1 cache能够保存4行。</p>
<p>如果按列连续访问的情况，每个元素间隔了8KB，这意味着最多只有8个元素能够同时驻留在L1 cache中，所以按列访问几乎会产生100%的cache失效率。<br>如果行数不是2的幂次，那么最多也只有64个元素驻留在L1 cache中。</p>
<h2 id="朴素矩阵乘法"><a href="#朴素矩阵乘法" class="headerlink" title="朴素矩阵乘法"></a>朴素矩阵乘法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">1024</span>; ++j) &#123;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0.0f</span>;</span><br><span class="line">  <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;<span class="number">1024</span>; ++k) sum+=a[i, k]*b[k, j]</span><br><span class="line">  c[i, j] = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="估算"><a href="#估算" class="headerlink" title="估算"></a>估算</h3><p>在真正执行程序之前，我们不妨先估算这个程序需要的执行时间。</p>
<p>不考虑访存，我们需要 $2^30$ (约10亿) 次乘法和加法。<br>如果每个双精度浮点乘法和加法分别需要4个周期，处理器频率为4GHz，那么乘法和加法各需要1s，总计2s。<br>但是考虑乘法和加法能够被FMA重叠，且流水线能够重叠增加4倍吞吐，那么所有的计算能够在 $1&#x2F;4$ s结束。</p>
<p>现在开始考虑访存的影响。<br>对于数组 <code>a</code> ，它只在第一个访问第一个元素时会发生缓存不命中。<br>读取8MB数据需要128K个缓存行，不考虑缓存行额外的预取，则应该发生至少128K次缓存未命中。<br>对于数组 <code>b</code>，它几乎全部未命中，因此估计发生了10亿次未命中。<br>如果一次未命中需要200周期，那么访问 <code>b</code> 需要50s。<br>但是事实上存在一定程度的数据复用，我们可以估算这个访存未命中的平均后开销为实际的10%，由此估算得到一个可能的时间是5~50s。</p>
<p>书上示例给出的运行时间为6.482s。</p>
<blockquote>
<p>我自己在一个ARM v8处理器上测试为50.1896s。</p>
</blockquote>
<h3 id="交换外层循环"><a href="#交换外层循环" class="headerlink" title="交换外层循环"></a>交换外层循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">1024</span>; ++j) </span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; ++i) &#123;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0.0f</span>;</span><br><span class="line">  <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;<span class="number">1024</span>; ++k) sum+=a[i, k]*b[k, j]</span><br><span class="line">  c[i, j] = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于最内层的循环而言，它的行为并没有改变，仍然是扫描一行和一列。<br><code>a</code> 的行能够在cache中保存多行，对于它的访存失效率或许不会有太大变化。</p>
<p>但是在书中给出的结果是5.115s，反而略快一些。</p>
<blockquote>
<p>我自己在ARM处理器上测试结果为51.1476，考虑到性能波动，其实就是没变化。</p>
</blockquote>
<p>在书中测试用的机器上，其L3缓存并没有使用 $[6:15]$ 位的地址进行组索引，而是使用了某种hash算法将这些地址中这些较低的位和较高的位一起做了一个hash，让列能够分布在L3缓存中更多的组，来降低由列引发的缓存不命中。</p>
<h3 id="转置矩阵再相乘"><a href="#转置矩阵再相乘" class="headerlink" title="转置矩阵再相乘"></a>转置矩阵再相乘</h3><p>将 <code>b</code> 转置为 <code>bb</code> 后再相乘是一个可行的做法。<br>转置 <code>b</code> 需要先读取一行然后写入 <code>bb</code> 的一列。<br>在读 <code>b</code> 的一行时会发生128K次的缓存未命中，然后在按列写入的时候发生1M次缓存未命中，总共113万次左右的未命中。</p>
<p>此时在矩阵乘法的最内层只会访问 <code>a</code> 的一行和 <code>bb</code> 的一行，共发生128次未命中，和外面两层循环乘起来就发生了2.56亿次未命中，不足朴素实现的30%。</p>
<h4 id="更快地转置-b"><a href="#更快地转置-b" class="headerlink" title="更快地转置 b"></a>更快地转置 <code>b</code></h4><p>通过每次转置8x8的小块能够更快地完成转置操作。<br>这是因为L1 cache时8路组相联的，每一列开头的元素位于同一组不同cache line上；同时一个cache line能容纳8个double。<br>每次读写一个8x8的小块预计会发生16次缓存未命中，总共要读写128x128个这样的小块，总共发生256K次的缓存未命中，相较原本的转置仅有25%的未命中次数。</p>
<p>书中的测试对两种转置分别运行了1.144s和0.579s。</p>
<h2 id="矩阵分块"><a href="#矩阵分块" class="headerlink" title="矩阵分块"></a>矩阵分块</h2><p>矩阵分块指从矩阵中拿出一个nxn小块然后存到一块连续的数据中。<br>在书中测试的平台用32x32大小的块是最合适的。<br>这是因为两个32x32大小的块刚好能填充L1 cache的所有cache line。</p>
<p>从快速转置中可知，这样分块的复制过程会产生256K次未命中，总共发生了1024次这样的分块，总共产生了256M (约2.56亿) 未命中。<br>相较于初始版本的缓存为命中大幅度地下降。</p>
<p>书中的测试结果为0.392s，距离理论极限的0.25s已经比较接近了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-04-16T01:48:32.000Z" title="2024/4/16 09:48:32">2024-04-16</time>发表</span><span class="level-item"><time dateTime="2024-04-18T02:24:42.190Z" title="2024/4/18 10:24:42">2024-04-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Performance-Profiling/">Performance Profiling</a></span><span class="level-item">6 分钟读完 (大约860个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/04/16/PerformanceMeasuring/01-CPU/">01-Measuring CPU Time</a></p><div class="content"><h1 id="现代处理器的执行流程"><a href="#现代处理器的执行流程" class="headerlink" title="现代处理器的执行流程"></a>现代处理器的执行流程</h1><p><img src="/gallery/PerformanceProfiling/CPUExecution.png"></p>
<p>超线程指的是一个CPU核上有两个PC和相关寄存器，但是ALU和cache资源量不变。<br>当一个PC在等待数据时，另一个PC能够进行执行，在逻辑上有两个核。</p>
<h1 id="测量一条-add-指令的时延"><a href="#测量一条-add-指令的时延" class="headerlink" title="测量一条 add 指令的时延"></a>测量一条 <code>add</code> 指令的时延</h1><p>这里的时延指的是从 <code>add</code> 指令被取指，到其结果对于依赖这条指令的指令可用时经过的时钟周期数。</p>
<h2 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start = <span class="built_in">timer</span>();</span><br><span class="line"><span class="built_in">add</span>(a, b);</span><br><span class="line">end = <span class="built_in">timer</span>();</span><br><span class="line">end - start;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Intel处理器上，这个获取时钟的timer是位于 <code>x86intrin.h</code> 的 <code>__rdtsc</code> 函数。<br>在ARMv8上，并没有和 <code>rdtsc</code> 直接等价的指令，但是有类似的寄存器，<code>PMCCNTR_EL0</code>。<br>但是X86能够在用户态随便读取周期数，而ARM不行。</p>
</blockquote>
<p>但是在现代处理器上，这种方法并不能准确测量按周期数计的时延，这是因为处理器有主频和外频之分，并且还能动态调频。<br>对于标定频率为2.4GHz的处理器而言，其时间戳可能每10ns (100MHz) 增加24；当其降频或者超频，这个时间戳的递增速率不变，仍然每秒递增24亿次。<br>这种测量方式给出了一致的测量值但是精度下降了一个数量级。</p>
<p>因此，为了减少每次获取时钟时那10ns的模糊性产生的失真，我们需要确保两次读取经过了1000ns (低于1%)，所以测量方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start = <span class="built_in">timer</span>();</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; N; ++i) <span class="built_in">add</span>(a, b);</span><br><span class="line">end = <span class="built_in">timer</span>();</span><br><span class="line">end - start;</span><br></pre></td></tr></table></figure>

<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> startcy, stopcy;</span><br><span class="line"><span class="type">uint64_t</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">startcy = __rdtsc();</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; ++i) sum += <span class="number">1</span>;</span><br><span class="line">stopcy = __rdtsc();</span><br></pre></td></tr></table></figure>

<p>在编译器上，这个循环能够被常量折叠或者死代码删除优化掉。<br>为了迷惑编译器，我们需要将 <code>sum</code> 声明为 <code>volatile</code> 来阻止编译器进行常量分析。</p>
<h2 id="循环开销"><a href="#循环开销" class="headerlink" title="循环开销"></a>循环开销</h2><p>另一方面，循环开销确实也会对我们的测量产生影响，因此适度地循环展开是可行的。</p>
<p>另一个更有效的方法是写两个循环，一个循环体执行N1次add，另一个循环体执行N2次add，两者相减即可消除循环开销。<br>但是N1和N2需要稍大一些，如4和8、10和20来减少编译器优化带来的影响；但也要避免循环体过大以致于不能放入循环缓冲区中，导致取指之间增加。</p>
<h2 id="确保指令间数据依赖"><a href="#确保指令间数据依赖" class="headerlink" title="确保指令间数据依赖"></a>确保指令间数据依赖</h2><h3 id="超标量-多发射"><a href="#超标量-多发射" class="headerlink" title="超标量 (多发射)"></a>超标量 (多发射)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; ++i) &#123;</span><br><span class="line">  sum += <span class="number">1</span>;</span><br><span class="line">  sum2 += <span class="number">1</span>;</span><br><span class="line">  sum += <span class="number">1</span>;</span><br><span class="line">  sum2 += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>sum</code> 和 <code>sum2</code> 相互独立，那么处理器能够使用超标量技术同时发射两条指令，导致最终测试的时延仅有一半，测出来的是发射率。</p>
<h3 id="编译器指令重排"><a href="#编译器指令重排" class="headerlink" title="编译器指令重排"></a>编译器指令重排</h3><p>在下面这个循环中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; ++i) &#123;</span><br><span class="line">  prod *= incr0; prod *= incr1;</span><br><span class="line">  prod *= incr2; prod *= incr3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明面上的计算顺序是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pord = (((prod*incr0)*incr1)*incr2)*incr3</span><br></pre></td></tr></table></figure>

<p>但是编译器重排之后可能把循环常量单独计算，并使用超标量发射多条指令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp = incr0*incr1*incr2*incr3;</span><br><span class="line">pord = prod * temp;</span><br></pre></td></tr></table></figure>

<p>为了避免这样的重写，应该加上 <code>-fno-tree-reassoc</code> 选项。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-04-06T10:34:12.000Z" title="2024/4/6 18:34:12">2024-04-06</time>发表</span><span class="level-item"><time dateTime="2024-04-13T10:18:55.574Z" title="2024/4/13 18:18:55">2024-04-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Design-Patterns-in-CPP/">Design Patterns in CPP</a></span><span class="level-item">8 分钟读完 (大约1260个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/04/06/DesingnPatterns/1-CreationalPattern/">1-CreationalPattern</a></p><div class="content"><h1 id="Creational-Patterns"><a href="#Creational-Patterns" class="headerlink" title="Creational Patterns"></a>Creational Patterns</h1><p>创建一个对象是一件很常见的事情，但是在一个复杂的系统里却需要考虑很多事情：<br>它应该分配在堆上还是栈上？它应该是裸指针、独有指针还是共享指针？<br>这些问题的来源是C++提供的丰富的创建方式：</p>
<ul>
<li>栈上分配</li>
<li>堆上分配</li>
<li><code>unique_ptr</code></li>
<li><code>shared_ptr</code></li>
<li><code>weak_ptr</code></li>
</ul>
<blockquote>
<p><code>weak_ptr</code> 是 <code>shared_ptr</code> 的辅助类，用于解决 <code>shared_ptr</code> 中循环引用的问题。</p>
</blockquote>
<p>当我们创建了对象后如何返回也是一个令人操心的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="comment">/* a large object*/</span></span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">int</span> ) &#123; cout &lt;&lt; <span class="string">&quot;Create Foo\n&quot;</span>; &#125;</span><br><span class="line">  <span class="built_in">Foo</span>(Foo &amp;) &#123; cout &lt;&lt; <span class="string">&quot;Copy Foo\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Foo <span class="title">make_foo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Foo &#123; n &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们当然不希望我们创建了一个 <code>Foo</code> 对象后，返回的时候又调用了复制构造函数产生额外的开销。<br>不过好在大多数C++编译都实现了RVO (Return Value Optimization) 来减少复制构造函数的产生。<br>但是，如果应用情景足够复杂，那么RVO可能不再靠谱。</p>
<h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h2><p>Builder模式用于创建复杂的对象。<br>它将创建对象的过程封装在一个类中。</p>
<p>假如我们希望创建如下的HTML样式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span> Hello <span class="tag">&lt;/<span class="name">li</span>&gt;</span>]</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span> World <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显然，HTML标签的生成能够被独立出来，于是我们将HTML元素抽象出来，并为其创建了一个builder：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HtmlElement</span> &#123;</span><br><span class="line">  string name, text;</span><br><span class="line">  vector&lt;HtmlElement&gt; elements;</span><br><span class="line">  <span class="built_in">HtmlElements</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">HtmlElements</span>(<span class="type">const</span> string &amp;name, <span class="type">const</span> string &amp;text)</span><br><span class="line">      : <span class="built_in">name</span>(name), <span class="built_in">text</span>(text) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">(<span class="type">int</span> indent = <span class="number">0</span>)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HtmlBuilder</span> &#123;</span><br><span class="line">  HtmlElement root;</span><br><span class="line">  <span class="built_in">HtmlBuilder</span>(string root_name) &#123; root.name = root_name; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addChild</span><span class="params">(string child_name, string child_text)</span> </span>&#123;</span><br><span class="line">    root.elements.<span class="built_in">emplace_back</span>(child_name, child_text);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root.<span class="built_in">str</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HtmlBuilder builder &#123; <span class="string">&quot;ul&quot;</span> &#125;;</span><br><span class="line">builder.<span class="built_in">addChild</span>(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">builder.<span class="built_in">addChild</span>(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果没有builder，那么创建一个 <code>HtmlElement</code> 对象会是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string words[] = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">HtmlElement list &#123;<span class="string">&quot;ul&quot;</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> w: words) &#123;</span><br><span class="line">  root.elements.<span class="built_in">emplace_back</span>(<span class="string">&quot;li&quot;</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用上远不及前者。</p>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>将 <code>addChild</code> 的返回类型变为类本身</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HtmlBuilder</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">HtmlBuilder &amp;<span class="title">addChild</span><span class="params">(string child_name, string child_text)</span> </span>&#123;</span><br><span class="line">    root.elements.<span class="built_in">emplace_back</span>(child_name, child_text);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样修改后 <code>HtmlBuilder</code> 的调用就可以链式调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.<span class="built_in">addChild</span>(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">       .<span class="built_in">addChild</span>(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="让用户知道如何使用"><a href="#让用户知道如何使用" class="headerlink" title="让用户知道如何使用"></a>让用户知道如何使用</h3><h4 id="强迫用户使用工厂函数"><a href="#强迫用户使用工厂函数" class="headerlink" title="强迫用户使用工厂函数"></a>强迫用户使用工厂函数</h4><p>第一种方法是强迫用户只能使用builder来创建对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HtmlElement</span> &#123;</span><br><span class="line">  <span class="keyword">friend</span> HtmlBuilder;</span><br><span class="line">  </span><br><span class="line">  string name;</span><br><span class="line">  string text;</span><br><span class="line">  vector&lt;HtmlElement&gt; elements;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> indent_size = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> unique_ptr&lt;HtmlBuilder&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> string &amp;root_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;HtmlBuilder&gt;(root_name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">HtmlElement</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">HtmlElement</span>(<span class="type">const</span> string &amp;name, <span class="type">const</span> string &amp;text)</span><br><span class="line">      : <span class="built_in">name</span>(name), <span class="built_in">text</span>(text) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HtmlBuilder</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">HtmlElement</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有的构造函数被放在 <code>protected</code> 中，不再可以被用户调用，但是留下了一个工厂函数 <code>create</code></li>
<li>但是这么做的后果是 <code>HtmlBuilder</code> 中无法使用构造函数了，需要添加为友元</li>
<li>通过 <code>operator HtmlElement()</code> 实现由builder向类对象的转换</li>
</ul>
<h4 id="Groovy-style-builder"><a href="#Groovy-style-builder" class="headerlink" title="Groovy-style builder"></a>Groovy-style builder</h4><p>Groovy，Kotlin等编程语言宣称自己的语言特性很适合于构建DSL语法结构。<br>但是大家都是通用编程语言，谁又比谁差呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">  string name;</span><br><span class="line">  string text;</span><br><span class="line">  vector&lt;Tag&gt; children;</span><br><span class="line">  vector&lt;pair&lt;string, string&gt;&gt; attributes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Tag &amp;tag) &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">Tag</span>(<span class="type">const</span> string &amp;name, <span class="type">const</span> string &amp;text)</span><br><span class="line">      : <span class="built_in">name</span>(name), <span class="built_in">text</span>(text) &#123;&#125;</span><br><span class="line">  <span class="built_in">Tag</span>(<span class="type">const</span> string &amp;name, <span class="type">const</span> vector&lt;Tag&gt; &amp;children)</span><br><span class="line">      : <span class="built_in">name</span>(name), <span class="built_in">children</span>(children) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span> : Tag &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">P</span><span class="params">(<span class="type">const</span> string &amp;text)</span></span></span><br><span class="line"><span class="function">      : Tag(<span class="string">&quot;p&quot;</span>, text) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">P</span>(initilizer_list&lt;Tag&gt; children)</span><br><span class="line">      : <span class="built_in">Tag</span>(<span class="string">&quot;p&quot;</span>, children) &#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IMG</span> : Tag &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">IMG</span><span class="params">(<span class="type">const</span> string &amp;text)</span></span></span><br><span class="line"><span class="function">      : Tag(<span class="string">&quot;p&quot;</span>, text) &#123;</span></span><br><span class="line">    attributes.<span class="built_in">emplace_back</span>(&#123;<span class="string">&quot;src&quot;</span>, url&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方式要从基类派生合法的标签类型，这样就构建了一套类似于DSL的系统，使用起来是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P &#123; &#123;IMG &#123; <span class="string">&quot;http://urltoanimage.com/img.png&quot;</span> &#125;&#125; &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复合builder"><a href="#复合builder" class="headerlink" title="复合builder"></a>复合builder</h3><p>现在我们打算创建类来保存一些个人信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  string street_address, post_code, city;</span><br><span class="line"></span><br><span class="line">  string company_name, position;</span><br><span class="line">  <span class="type">int</span> annual_income = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的数据成员可以分为两类，一类是住址信息，另一类是工作单位信息。<br>现在我们希望由两个builder分别完成这两类信息的创建。<br>这项工作并不容易，它需要四个类，其UML如下：</p>
<p><img src="/gallery/DesignPattern/Builder-Person.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonBuilderBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Person &amp;person;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PersonBuilderBase</span><span class="params">(Person &amp;person)</span></span></span><br><span class="line"><span class="function">      : person(person) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">move</span>(person);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">PersonAddressBuilder <span class="title">lives</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">PersonJobBuilder <span class="title">works</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonBuilder</span> : <span class="keyword">public</span> PersonBuilderBase &#123;</span><br><span class="line">  Person p; <span class="comment">// object being built</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PersonBuilder</span>() : <span class="built_in">PersonBuilderBase</span>(p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonAddressBuilder</span> : <span class="keyword">public</span> PersonBuilderBase &#123;</span><br><span class="line">  <span class="keyword">typedef</span> PersonAddressBuilder self;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PersonAddressBuilder</span><span class="params">(Person &amp;person)</span></span></span><br><span class="line"><span class="function">      : PersonBuilderBase &#123;</span> person &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">self &amp;<span class="title">at</span><span class="params">(string street_address)</span> </span>&#123;</span><br><span class="line">    person.street_address = street_address;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">self &amp;<span class="title">withPostcode</span><span class="params">(string post_code)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">  <span class="function">self &amp;<span class="title">in</span><span class="params">(string city)</span> </span>&#123;<span class="comment">/*...*/</span>&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonJobBuilder</span>: <span class="keyword">public</span> PersonBuilderBase &#123;</span><br><span class="line">  <span class="comment">/* identical fasion to PersonAddressBuilder */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p = Person::<span class="built_in">create</span>()</span><br><span class="line">    .lives.<span class="built_in">at</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">          .<span class="built_in">withPostcode</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">          .<span class="built_in">in</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .works.<span class="built_in">at</span>(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>要创建的对象 <code>Person</code> 在基类里只是个引用，在 <code>PersonBuilder</code> 中才真的拥有存储空间</li>
<li>另外两个builder没有从 <code>PersonBuilder</code> 继承，这样就避免了多次创建 <code>Person</code> 对象</li>
<li>转换到 <code>Person</code> 对象时，直接将 <code>person</code> 成员的所有权转移走</li>
</ul>
<h3 id="内部类的builder"><a href="#内部类的builder" class="headerlink" title="内部类的builder"></a>内部类的builder</h3><p>假设现在有一个邮件系统，在作为底层实现的类中，一个邮件对象按如下方式描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmailImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string from, to, subject, body;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>既然是内部的底层实现，我们显然不希望用户直接和这些类进行交互</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-04-06T07:07:38.000Z" title="2024/4/6 15:07:38">2024-04-06</time>发表</span><span class="level-item"><time dateTime="2024-04-24T07:16:25.919Z" title="2024/4/24 15:16:25">2024-04-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a></span><span class="level-item">5 分钟读完 (大约716个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/04/06/EnvironmentSetting/DpcppOnARM/">Dpcpp on ARM CPU with PoCL</a></p><div class="content"><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本安装过程使用DPCPP 20230413，LLVM 16，PoCL4。<br>经验证对于较新版本的DPCPP和PoCL5也依然有效。</p>
<h1 id="安装DPCPP"><a href="#安装DPCPP" class="headerlink" title="安装DPCPP"></a>安装DPCPP</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python3 buildbot/configure.py -t Debug \</span><br><span class="line">    --cmake-opt=-DLLVM_USE_LINKER=gold \</span><br><span class="line">    --cmake-opt=-DLLVM_TARGETS_TO_BUILD=<span class="string">&quot;ARM;AArch64&quot;</span> \</span><br><span class="line">    --cmake-opt=-DLLVM_ENABLE_RUNTIMES=openmp</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在较高版本中可以加上 <code>--native_cpu</code></p>
</blockquote>
<h1 id="安装LLVM"><a href="#安装LLVM" class="headerlink" title="安装LLVM"></a>安装LLVM</h1><p>根据PoCL的要求下载对应版本的LLVM即可：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=OFF -DLLVM_OPTIMIZED_TABLEGEN=ON \</span><br><span class="line">-DLLVM_TARGETS_TO_BUILD=<span class="string">&quot;ARM;AArch64&quot;</span> -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang;clang-tools-extra;mlir&quot;</span> -DLLVM_BUILD_TOOLS=ON \</span><br><span class="line">-DLLVM_ENABLE_RUNTIMES=<span class="string">&quot;openmp&quot;</span> -DBUILD_SHARED_LIBS=OFF -DLLVM_ENABLE_EH=ON -DLLVM_ENABLE_RTTI=ON \</span><br><span class="line">-DLLVM_PARALLEL_LINK_JOBS=32 -DCMAKE_INSTALL_PREFIX=&lt;install-path&gt; -DLLVM_ENABLE_DOXYGEN=OFF \</span><br><span class="line">-DLLVM_ENABLE_SPHINX=OFF -DLLVM_ENABLE_LLD=OFF -DLLVM_ENABLE_BINDINGS=OFF -DLLVM_ENABLE_LIBXML2=OFF \</span><br><span class="line">-DOPENMP_ENABLE_LIBOMPTARGET=OFF -DLLVM_STATIC_LINK_CXX_STDLIB=ON ../llvm</span><br><span class="line"></span><br><span class="line">cmake --build build</span><br><span class="line">cmake --install build --prefix &lt;install-path&gt;</span><br></pre></td></tr></table></figure>

<h1 id="安装OpenCL-Header和OpenCL-ICD-Loader"><a href="#安装OpenCL-Header和OpenCL-ICD-Loader" class="headerlink" title="安装OpenCL-Header和OpenCL-ICD-Loader"></a>安装OpenCL-Header和OpenCL-ICD-Loader</h1><p>在编译前需要检查git checkout是否和DPCPP的opencl目录下的CMakeLists.txt中的tag一致。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OpenCL-Header</span></span><br><span class="line">cmake -S . -B build -DCMAKE_INSTALL_PREFIX=&lt;install-path&gt;</span><br><span class="line">cmake --build build --target install</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenCL-ICD-Loader</span></span><br><span class="line">cmake -DCMAKE_PREFIX_PATH=&lt;OpenCL-Header-install-path&gt; -DCMAKE_INSTALL_PREFIX=&lt;install-path&gt; -S . -B build</span><br><span class="line">cmake --build build --target install</span><br></pre></td></tr></table></figure>

<h1 id="安装PoCL"><a href="#安装PoCL" class="headerlink" title="安装PoCL"></a>安装PoCL</h1><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>在此之前写好环境变量：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OpenCL-ICD-Loader</span></span><br><span class="line">VVV_ICD_LOADER=&lt;OpenCL-ICD-Loader-install-path&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$&#123;VVV_ICD_LOADER&#125;</span>/lib:<span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$&#123;VVV_ICD_LOADER&#125;</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenCL-Header</span></span><br><span class="line">VVV_OCL_HEADERS=&lt;OpenCL-Headers-install-path&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> CPLUS_INCLUDE_PATH=<span class="variable">$&#123;VVV_OCL_HEADERS&#125;</span>/include:<span class="variable">$CPLUS_INCLUDE_PATH</span></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=<span class="variable">$&#123;VVV_OCL_HEADERS&#125;</span>/include:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=<span class="variable">$&#123;VVV_OCL_HEADERS&#125;</span>/share/pkgconfig:<span class="variable">$PKG_CONFIG_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LLVM16</span></span><br><span class="line">LLVM_PATH=&lt;LLVM-install-path&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$LLVM_PATH</span>/bin&quot;</span>:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="string">&quot;<span class="variable">$LLVM_PATH</span>/lib&quot;</span>:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>

<p>全部 <code>source</code> 到环境变量中。</p>
<h2 id="编译PoCL"><a href="#编译PoCL" class="headerlink" title="编译PoCL"></a>编译PoCL</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmake -G Ninja -B build -S . \</span><br><span class="line">  -DENABLE_ICD=ON -DCMAKE_PREFIX_PATH=<span class="string">&quot;&lt;llvm-install-path&gt;;&lt;OpenCL-ICD-Loader-install-path&gt;;&lt;OpenCL-Headers-install-path&gt;&quot;</span> \</span><br><span class="line">  -DENABLE_SPIR=ON -DENABLE_SPIRV=ON -DLLVM_SPIRV=&lt;DPCPP-path&gt;/build/install/bin/llvm-spirv \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=RelWithDebInfo -DSTATIC_LLVM=ON -DLLC_HOST_CPU=cortex-a57 \</span><br><span class="line">  -DCMAKE_INSTALL_PREFIX=&lt;pocl-install-path&gt; \</span><br><span class="line">  -DCMAKE_CXX_COMPILER=clang++ \</span><br><span class="line">  -DCMAKE_C_COMPILER=clang</span><br><span class="line"></span><br><span class="line">cmake --build build --target install</span><br></pre></td></tr></table></figure>

<h1 id="使用与检查"><a href="#使用与检查" class="headerlink" title="使用与检查"></a>使用与检查</h1><h2 id="编辑环境变量"><a href="#编辑环境变量" class="headerlink" title="编辑环境变量"></a>编辑环境变量</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DPCPP env</span></span><br><span class="line"><span class="built_in">export</span> DPCPP_HOME=&lt;DPCPP-ROOT&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BASE_PATH=<span class="variable">$DPCPP_HOME</span>/build/install</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;BASE_PATH&#125;</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> CPLUS_INCLUDE_PATH=<span class="variable">$&#123;BASE_PATH&#125;</span>/include/:<span class="variable">$CPLUS_INCLUDE_PATH</span></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=<span class="variable">$&#123;BASE_PATH&#125;</span>/include/:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> CPLUS_INCLUDE_PATH=<span class="variable">$&#123;BASE_PATH&#125;</span>/include/sycl:<span class="variable">$CPLUS_INCLUDE_PATH</span></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=<span class="variable">$&#123;BASE_PATH&#125;</span>/include/sycl:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$&#123;BASE_PATH&#125;</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$&#123;BASE_PATH&#125;</span>/lib:<span class="variable">$LIBRARY_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> CC=clang CXX=clang++</span><br><span class="line"></span><br><span class="line"><span class="comment"># PoCL env</span></span><br><span class="line">BASE_PATH=&lt;PoCL-install-path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># BIN</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;BASE_PATH&#125;</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HEADERS</span></span><br><span class="line"><span class="built_in">export</span> CPLUS_INCLUDE_PATH=<span class="variable">$CPLUS_INCLUDE_PATH</span>:<span class="variable">$&#123;BASE_PATH&#125;</span>/include</span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=<span class="variable">$CPLUS_INCLUDE_PATH</span>:<span class="variable">$&#123;BASE_PATH&#125;</span>/include</span><br><span class="line"></span><br><span class="line"><span class="comment"># LIBS</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$&#123;BASE_PATH&#125;</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$&#123;BASE_PATH&#125;</span>/lib:<span class="variable">$LIBRARY_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=<span class="variable">$&#123;BASE_PATH&#125;</span>/lib/pkgconfig:<span class="variable">$PKG_CONFIG_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> OCL_ICD_VENDORS=<span class="variable">$&#123;BASE_PATH&#125;</span>/etc/OpenCL/vendors</span><br><span class="line"></span><br><span class="line"><span class="comment"># Variables for debugging programs</span></span><br><span class="line"><span class="built_in">export</span> VVV_pocl_help=<span class="string">&quot;SYCL_PI_TRACE=2 POCL_DEBUG=all OCL_ICD_ENABLE_TRACE=1&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>如果使用PoCL4，设置环境变量如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> env-DPCPP.sh</span><br><span class="line"><span class="built_in">source</span> env-PoCL4.sh</span><br></pre></td></tr></table></figure>

<p>如果使用PoCL5，设置环境变量如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> env-OpenCL-Header.sh</span><br><span class="line"><span class="built_in">source</span> env-OpenCL-ICD-Loader.sh</span><br><span class="line"><span class="built_in">source</span> env-DPCPP.sh</span><br><span class="line"><span class="built_in">source</span> env-PoCL5.sh</span><br></pre></td></tr></table></figure>

<p>之后运行 <code>sycl-ls</code> 检查是否出现</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[opencl:cpu:0] ...</span><br></pre></td></tr></table></figure>

<p>表示DPCPP运行时检测到ICD Loader，可以用PoCL作为后端将ARM CPU视为device。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-04-05T12:19:36.000Z" title="2024/4/5 20:19:36">2024-04-05</time>发表</span><span class="level-item"><time dateTime="2024-04-06T03:21:01.617Z" title="2024/4/6 11:21:01">2024-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Design-Patterns-in-CPP/">Design Patterns in CPP</a></span><span class="level-item">6 分钟读完 (大约848个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/04/05/DesingnPatterns/0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/">Prequest knowledge</a></p><div class="content"><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="CRTP-Curiously-Recurring-Template-Pattern"><a href="#CRTP-Curiously-Recurring-Template-Pattern" class="headerlink" title="CRTP (Curiously Recurring Template Pattern)"></a>CRTP (Curiously Recurring Template Pattern)</h2><p>CRTP也被叫做静态多态，它的写法看起来是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> : Base&lt;Foo&gt; &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样写的好处有：</p>
<ol>
<li>获得有类型信息的 <code>this</code> 指针</li>
<li>可以避免动态多态中因为虚函数表带来的开销</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Derived</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it: *<span class="built_in">static_cast</span>&lt;Derived *&gt;(<span class="keyword">this</span>)) &#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> : Base&lt;Foo&gt; &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">iterator</span> &#123;...&#125;;</span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>假设我们正在开发一个消息管理器，能够向所有的网上博客推送消息。<br>使用CRTP可能写出来的系统是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Impl&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Notifier</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">alertSMS</span><span class="params">(string_view msg)</span> </span>&#123; <span class="built_in">impl</span>().<span class="built_in">sendAlertSMS</span>(msg); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">alertEmail</span><span class="params">(string_view msg)</span> </span>&#123; <span class="built_in">impl</span>().<span class="built_in">sendAlertEmail</span>(msg); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function">Impl &amp;<span class="title">impl</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;TImpl &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line">  <span class="keyword">friend</span> Impl;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Impl&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alertAllChannels</span><span class="params">(Notifier&lt;Impl&gt; &amp;notifier, string_view msg)</span> </span>&#123;</span><br><span class="line">  notifier.<span class="built_in">alertSMS</span>(msg);</span><br><span class="line">  notifier.<span class="built_in">alertEmail</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestNotifier</span> : <span class="keyword">public</span> Notifier&lt;TestNotifier&gt; &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendAlertSMS</span><span class="params">(string_view msg)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendAleryEmail</span><span class="params">(string_view msg)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在的写法存在的问题是：我们并没有检查 <code>Impl</code> 是否继承自 <code>Notifier</code>，只能等到编译器报错了之后才能发现 <code>Impl</code> 是否真的有 <code>sendAltertSMS</code> 方法！</p>
<h3 id="使用-concept-进行检查"><a href="#使用-concept-进行检查" class="headerlink" title="使用 concept 进行检查"></a>使用 <code>concept</code> 进行检查</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Impl&gt;</span><br><span class="line"><span class="keyword">concept</span> IsANotifier = <span class="built_in">requires</span>(Impl impl) &#123;</span><br><span class="line">  impl.<span class="built_in">alertSMS</span>(string_view &#123;&#125;);</span><br><span class="line">  impl.<span class="built_in">alertEmail</span>(string_view &#123;&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;IsANotifer Impl&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alertAllChannels</span><span class="params">(Impl &amp;impl, string_view msg)</span> </span>&#123;</span><br><span class="line">  impl.<span class="built_in">alertSMS</span>(msg);</span><br><span class="line">  impl.<span class="built_in">alertEmail</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>requires</code> 允许我们直接对类的接口进行检查，而不再需要构造一个奇怪的基类！</p>
<h2 id="Mixin继承"><a href="#Mixin继承" class="headerlink" title="Mixin继承"></a>Mixin继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mixin</span>: T... &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这种写法能够将一组功能相互正交的类组合在一起使用。<br>在C++20引入 <code>concept</code> 之后，能够提前对mixin的类型进行约束，而不需要等到编译器报错才知道有地方写错了。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性指的是一个类的私有数据成员，以及为了读写它的相关方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; age = value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在C#和Kotlin这样的语言中，对属性的写法提供了语法上的支持，但是C++标准没有。<br>但是MSVC和clang都提够了自己的编译器扩展：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">int</span> _age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _age; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; _age = value; &#125;</span><br><span class="line">  __declspec(<span class="built_in">property</span>(get=getAge, put=setAge)) <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>age</code> 并不会占用额外的内存，在使用时会被编译器替换为原始的形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Paerson p;</span><br><span class="line">p.age = <span class="number">20</span>; <span class="comment">// invoke setAge(20)</span></span><br></pre></td></tr></table></figure>

<h2 id="SOLID设计原则"><a href="#SOLID设计原则" class="headerlink" title="SOLID设计原则"></a>SOLID设计原则</h2><ul>
<li>Single Responsibility Principle (SRP)</li>
<li>Open-Closed Principle (OCP)</li>
<li>Liskov Substitution Principle (LSP)</li>
<li>Interface Segregation Principle (ISP)</li>
<li>Dependency Inversion Principle (DIP)</li>
</ul>
<h3 id="SRP"><a href="#SRP" class="headerlink" title="SRP"></a>SRP</h3><p>每个类都应该只有一项职责。SRP的反例是上帝对象 (God Object)，看起来包罗万象其实非常难用。</p>
<h3 id="OCP"><a href="#OCP" class="headerlink" title="OCP"></a>OCP</h3><p>实体对扩展是开放的，对修改是封闭的，即统一用户的实现接口。<br>典型的例子是使用迭代器的算法库，用户不能直接修改其实现，但是通过在自己实现的对象中添加对迭代器的实现就能够让算法库扩展到自定义对象上。</p>
<h3 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h3><p>任何对象被它们的子类替换后，不应该发生错误。</p>
<h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>客户不应该被迫实现一个他们不需要的接口，因此应该把接口分解为多个接口，每个接口服务于一个模块。</p>
<h3 id="DIP"><a href="#DIP" class="headerlink" title="DIP"></a>DIP</h3><p>高层模块不应该依赖于底层模块，两者都应该依赖于抽象；<br>抽象不依赖于细节，反而细节应该依赖于抽象。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-04-03T08:03:39.000Z" title="2024/4/3 16:03:39">2024-04-03</time>发表</span><span class="level-item"><time dateTime="2024-04-04T08:59:09.411Z" title="2024/4/4 16:59:09">2024-04-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Modern-CPP/">Modern CPP</a></span><span class="level-item">3 分钟读完 (大约440个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/04/03/CPPTemplate/9-Require%E5%92%8Cconcept/">9-Require and concept</a></p><div class="content"><h1 id="requires"><a href="#requires" class="headerlink" title="requires"></a><code>requires</code></h1><p>Requires是C++20引入的特性。<br>因为requires的出现，SFINAE变成了过时、难看的写法。</p>
<h2 id="示例：要求模板参数支持-operator"><a href="#示例：要求模板参数支持-operator" class="headerlink" title="示例：要求模板参数支持 operator+"></a>示例：要求模板参数支持 <code>operator+</code></h2><h3 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;() + std::<span class="built_in">declval</span>&lt;T&gt;())&gt;&gt;</span><br><span class="line">T <span class="built_in">add</span>(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2) &#123;</span><br><span class="line">  <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="requires-1"><a href="#requires-1" class="headerlink" title="requires"></a><code>requires</code></h3><p>使用 <code>requires</code> 需要先定义一个concept。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Addable = <span class="built_in">requires</span>(T a) &#123;</span><br><span class="line">  a + a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Addable T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Concept是一个谓词，在编译时求值，即 <code>constexpr bool</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> v = Addable&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>使用一个编译期可求值的布尔表达式定义 <code>concept</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Int = std::is_same_v&lt;T, <span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure>

<p><code>concept</code> 的定义也能内联进 <code>requires</code> 表达式中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> <span class="title">requires</span><span class="params">(T a)</span> </span>&#123; a+a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两个 <code>requires</code> 表示不同的意思</li>
<li>第二个 <code>requires</code> 是require表达式，一个能编译期产生布尔类型的表达式</li>
<li>第一个 <code>requires</code> 是reuquire子句</li>
</ul>
<h2 id="标准库里的设施"><a href="#标准库里的设施" class="headerlink" title="标准库里的设施"></a>标准库里的设施</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span><span class="params">(<span class="type">const</span> std::integral <span class="keyword">auto</span> &amp;a, <span class="type">const</span> std::integral <span class="keyword">auto</span> &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>concept</code> 能够放在 <code>auto</code> 的前面</li>
</ul>
<p>也可以写成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="built_in">requires</span>(std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单-requires-表达式"><a href="#简单-requires-表达式" class="headerlink" title="简单 requires 表达式"></a>简单 <code>requires</code> 表达式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> Swappable = <span class="built_in">reuqires</span>(T &amp;&amp;t, U &amp;&amp;u) &#123;</span><br><span class="line">  <span class="built_in">swap</span>(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> foo &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(X &amp;, X &amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别地，在这个例子中表现了 <code>requires</code> 表达式在替换过程用到了ADL，自动选择同意名称空间内的 <code>swap</code>。</p>
<h2 id="复合-requires-表达式"><a href="#复合-requires-表达式" class="headerlink" title="复合 requires 表达式"></a>复合 <code>requires</code> 表达式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> C = <span class="built_in">requires</span>(T x) &#123;</span><br><span class="line">  &#123;*x&#125;-&gt;std::convertible_to&lt;<span class="keyword">typename</span> T::inner&gt;;</span><br><span class="line">  &#123;x.~<span class="built_in">T</span>()&#125; <span class="keyword">noexcept</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>*x</code> 是合法的</li>
<li>嵌套类型&#x2F;类型别名 <code>T::inner</code> 存在</li>
<li><code>*x</code> 能够隐式转换到 <code>T::inner</code></li>
<li>析构函数不抛出异常</li>
</ul>
<h2 id="嵌套-requires-表达式"><a href="#嵌套-requires-表达式" class="headerlink" title="嵌套 requires 表达式"></a>嵌套 <code>requires</code> 表达式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> C = <span class="built_in">requires</span>(T) &#123;</span><br><span class="line">  <span class="keyword">requires</span> std::is_same_v&lt;T, <span class="type">int</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>requires</code> 要求后面的表达式为 <code>true</code> 才能成立</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-25T07:02:18.000Z" title="2024/3/25 15:02:18">2024-03-25</time>发表</span><span class="level-item"><time dateTime="2024-04-16T14:06:30.618Z" title="2024/4/16 22:06:30">2024-04-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/MLIR/">MLIR</a></span><span class="level-item">3 分钟读完 (大约409个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/25/MLIR/APP-A%20CommonDialects/">CommonDialects</a></p><div class="content"><h1 id="scf-dialect"><a href="#scf-dialect" class="headerlink" title="scf dialect"></a>scf dialect</h1><p>scf方言中的Op能够用来表征任意的代码块结构。</p>
<h2 id="ConditionOp"><a href="#ConditionOp" class="headerlink" title="ConditionOp"></a>ConditionOp</h2><h2 id="IfOp"><a href="#IfOp" class="headerlink" title="IfOp"></a>IfOp</h2><p>Example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%x, %y = scf.if %b -&gt; (f32, f32) &#123;</span><br><span class="line">  %x_true = ...</span><br><span class="line">  %y_true = ...</span><br><span class="line">  scf.yield %x_true, %y_true : f32, f32</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  %x_false = ...</span><br><span class="line">  %y_false = ...</span><br><span class="line">  scf.yield %x_false, %y_false : f32, f32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于传统的数据流分析，<code>scf.if</code> 能够指定哪些变量在出口处活跃。</p>
<p><code>scf.yeild</code> 表示一个控制块的结束，如果 <code>scf.if</code> 没有返回值，那么它能够被省略，被隐式地插入在代码中。</p>
<p>如果 <code>if</code> 语句中存在逻辑表达式的计算，那么会额外引入一个 <code>scf.if</code> 结构计算这个逻辑表达式的值，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isCoordChanged || iter == <span class="number">0</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%75 = scf.if %42 -&gt; (i1) &#123;</span><br><span class="line">  scf.yield %true : i1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  %209 = memref.load %37[%c0] : memref&lt;1xi32&gt;</span><br><span class="line">  %210 = arith.cmpi eq, %209, %c0_i32 : i32</span><br><span class="line">  scf.yield %210 : i1</span><br><span class="line">&#125;</span><br><span class="line">scf.if %75 &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="memref-dialect"><a href="#memref-dialect" class="headerlink" title="memref dialect"></a>memref dialect</h1><h2 id="GetGlobalOp"><a href="#GetGlobalOp" class="headerlink" title="GetGlobalOp"></a>GetGlobalOp</h2><p>获得一个全局变量的指针。</p>
<h1 id="llvm-dialect"><a href="#llvm-dialect" class="headerlink" title="llvm dialect"></a>llvm dialect</h1><h2 id="GEPOp-getelementptr"><a href="#GEPOp-getelementptr" class="headerlink" title="GEPOp (getelementptr)"></a>GEPOp (getelementptr)</h2><p>相当于从LLVM IR中的 <code>getelementptr</code> 指令，根据偏移量从计算结构体中元素的地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123; <span class="type">long</span> num; <span class="type">int</span> dim; Point *p; &#125; Point *points;</span><br><span class="line"><span class="type">int</span> num	=  points-&gt;num;				<span class="comment">// number of points</span></span><br><span class="line"><span class="type">int</span> dim	=  points-&gt;dim;				<span class="comment">// number of dimension</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%24 = llvm.getelementptr %arg1[%c0_i32, 0] : (!llvm.ptr&lt;!llvm.struct&lt;(i64, i32, !llvm.ptr&lt;!llvm.struct&lt;(f32, memref&lt;?xf32&gt;, i64, f32)&gt;&gt;)&gt;&gt;, i32) -&gt; !llvm.ptr&lt;i64&gt;</span><br><span class="line">%25 = llvm.load %24 : !llvm.ptr&lt;i64&gt;</span><br><span class="line">%26 = arith.trunci %25 : i64 to i32</span><br><span class="line">%27 = llvm.getelementptr %arg1[%c0_i32, 1] : (!llvm.ptr&lt;!llvm.struct&lt;(i64, i32, !llvm.ptr&lt;!llvm.struct&lt;(f32, memref&lt;?xf32&gt;, i64, f32)&gt;&gt;)&gt;&gt;, i32) -&gt; !llvm.ptr&lt;i32&gt;</span><br><span class="line">%28 = llvm.load %27 : !llvm.ptr&lt;i32&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg1</code> 是一个结构体</li>
<li><code>%c0_i32</code> 是一个32位类型的常量0，表示以结构体大小为基准的偏移量</li>
<li><code>0</code> 是结构体内的偏移量，表示结构体内的第一个元素</li>
<li>GEPOp只计算地址，所以要 <code>load</code> 以下</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-25T05:08:24.000Z" title="2024/3/25 13:08:24">2024-03-25</time>发表</span><span class="level-item"><time dateTime="2024-04-03T07:58:07.125Z" title="2024/4/3 15:58:07">2024-04-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Modern-CPP/">Modern CPP</a></span><span class="level-item">4 分钟读完 (大约660个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/25/CPPTemplate/8-SFINAE/">8-SFINAE</a></p><div class="content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>SFINAE &#x3D; Substitution Failure Is Not An Error</p>
<p>这是函数模板<strong>重载决议</strong>中的一个规则：模板形参在替换为显式指定的类型或者推导类型失败时，只会从重载集中丢弃这个特化，而非产生编译错误。<br>当没有重载集中没有可用的模板后，产生找不到可用函数的错误。</p>
<p>模板参数会发生两次代换：</p>
<ol>
<li>模板实参推导前：用显式指定的模板实参进行代换</li>
<li>模板实参推导后：对推导出的实参和默认项获得的实现进行替换</li>
</ol>
<p>如果所有模板形参都显示指定，则不会发生第二次代换。</p>
<h2 id="SFINAE错误-硬错误"><a href="#SFINAE错误-硬错误" class="headerlink" title="SFINAE错误&#x2F;硬错误"></a>SFINAE错误&#x2F;硬错误</h2><p>代换过程中产生的副作用，如额外的模板实例化等，就会产生硬错误。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="对运算符重载的要求"><a href="#对运算符重载的要求" class="headerlink" title="对运算符重载的要求"></a>对运算符重载的要求</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> _T = <span class="keyword">decltype</span>(T&#123;&#125; + T&#123;&#125;)&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">add</span>(<span class="type">const</span> T &amp;c1 <span class="type">const</span> T &amp;c2) &#123;</span><br><span class="line">  <span class="keyword">return</span> c1 + c2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提前用SFINAE让模板替换失败能够减少不必要的实例化。但是缺点是写法上不好看。</p>
<blockquote>
<p>后置返回值类型也能有类似的效果。</p>
</blockquote>
<h1 id="标准库对SFINAE的支持"><a href="#标准库对SFINAE的支持" class="headerlink" title="标准库对SFINAE的支持"></a>标准库对SFINAE的支持</h1><h2 id="std-enable-if"><a href="#std-enable-if" class="headerlink" title="std::enable_if"></a><code>std::enable_if</code></h2><p><code>std::enable_if</code> 对模板参数是否满足某些类型进行检查。<br>下列例子中，要求模板参数是同类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ty</span>, Args... args&gt;</span><br><span class="line"><span class="built_in">array</span>(Type, Args...) -&gt; array&lt;<span class="type">enable_if_t</span>&lt;(is_same_v&lt;Type, Args&gt; &amp;&amp; ...), Type&gt;, <span class="keyword">sizeof</span>...(Args)+<span class="number">1</span>&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用一个折叠表达式对所有参数的类型进行判定</li>
</ul>
<p><code>std::enable_if</code> 和 <code>std::enable_if_t</code> 可能实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enable_if</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> B, <span class="keyword">class</span> <span class="title class_">T</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> enable_if &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">enable_if</span>&lt;<span class="literal">true</span>, T&gt; &#123; <span class="keyword">typedef</span> T type; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enable_if_t</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> B, <span class="keyword">class</span> <span class="title class_">T</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">enable_if_t</span> = enable_if&lt;B, T&gt;::type;</span><br></pre></td></tr></table></figure>

<h2 id="std-void-t"><a href="#std-void-t" class="headerlink" title="std::void_t"></a><code>std::void_t</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">void_t</span> = <span class="type">void</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>将任意序列映射到 <code>void</code> 类型</li>
<li>模板元编程中用于检测不完整类型</li>
</ul>
<p>在不用 <code>requires</code> 的情况下充当起了需求的垃圾桶的角色</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> SFINAE= </span><br><span class="line">    <span class="type">void_t</span>&lt;<span class="keyword">decltype</span>&lt;T&#123;&#125; + T&#123;&#125;&gt;, <span class="keyword">typename</span> T::type, <span class="keyword">decltype</span>&lt;T::value&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">add</span>(<span class="type">const</span> T &amp;t1, <span class="type">const</span> T &amp;t2) &#123;</span><br><span class="line">  <span class="keyword">return</span> t1::value + t2::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-declval"><a href="#std-declval" class="headerlink" title="std::declval"></a><code>std::declval</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> SFINAE= </span><br><span class="line">    <span class="type">void_t</span>&lt;<span class="built_in">declval</span>&lt;T&gt;() + <span class="built_in">declval</span>&lt;T&gt;(), ... &gt;&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">add</span>(<span class="type">const</span> T &amp;t1, <span class="type">const</span> T &amp;t2) &#123;</span><br><span class="line">  <span class="keyword">return</span> t1::value + t2::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此时，<code>T</code> 不支持默认构造函数也能进行检查了</li>
</ul>
<p><code>declval</code> 将类型 <code>T</code> 转换为引用类型 <code>T &amp;&amp;</code>，可以不经过构造而使用成员函数。仅能在不求值语境下使用，对定义没有要求。</p>
<h2 id="偏特化中的SFINAE"><a href="#偏特化中的SFINAE" class="headerlink" title="偏特化中的SFINAE"></a>偏特化中的SFINAE</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> T2 = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> X &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> <span class="built_in">foo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Main template\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partial specilization</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">void_t</span>&lt;<span class="keyword">typename</span> T::type&gt;&gt; X &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> T::type;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Partial specialization\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123; <span class="keyword">using</span> type = <span class="type">int</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X&lt;Foo&gt;::<span class="built_in">foo</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过SFINAE的加持，模板偏特化不在局限于特定的类型，能够做出更复杂的要求。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/gallery/head-portrial.jpg" alt="ReRoozen"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ReRoozen</p><p class="is-size-6 is-block">I need more power!!!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Within Heaven and Hell</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">53</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">16</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Assembly-Language/"><span class="level-start"><span class="level-item">Assembly Language</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Benchmarks/"><span class="level-start"><span class="level-item">Benchmarks</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CMAKE/"><span class="level-start"><span class="level-item">CMAKE</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Patterns-in-CPP/"><span class="level-start"><span class="level-item">Design Patterns in CPP</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/LLVM/"><span class="level-start"><span class="level-item">LLVM</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/LLVM-Meetings/"><span class="level-start"><span class="level-item">LLVM Meetings</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/MLIR/"><span class="level-start"><span class="level-item">MLIR</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Modern-CPP/"><span class="level-start"><span class="level-item">Modern CPP</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/PFPL/"><span class="level-start"><span class="level-item">PFPL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Performance-Profiling/"><span class="level-start"><span class="level-item">Performance Profiling</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Polyhedral/"><span class="level-start"><span class="level-item">Polyhedral</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Writing/"><span class="level-start"><span class="level-item">Writing</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/vim/"><span class="level-start"><span class="level-item">vim</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="level-start"><span class="level-item">环境配置</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-23T06:30:10.000Z">2024-04-23</time></p><p class="title"><a href="/2024/04/23/ARMAsm/01-Architecture/">ARMv8 Architecture</a></p><p class="categories"><a href="/categories/Assembly-Language/">Assembly Language</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-16T05:24:08.000Z">2024-04-16</time></p><p class="title"><a href="/2024/04/16/PerformanceMeasuring/02-MemoryHierarchical/">02-Measuring Memory Hierarchy</a></p><p class="categories"><a href="/categories/Performance-Profiling/">Performance Profiling</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-16T05:24:08.000Z">2024-04-16</time></p><p class="title"><a href="/2024/04/16/PerformanceMeasuring/03-CPUandMemory/">02-Measuring Memory Hierarchy</a></p><p class="categories"><a href="/categories/Performance-Profiling/">Performance Profiling</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-16T01:48:32.000Z">2024-04-16</time></p><p class="title"><a href="/2024/04/16/PerformanceMeasuring/01-CPU/">01-Measuring CPU Time</a></p><p class="categories"><a href="/categories/Performance-Profiling/">Performance Profiling</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-06T10:34:12.000Z">2024-04-06</time></p><p class="title"><a href="/2024/04/06/DesingnPatterns/1-CreationalPattern/">1-CreationalPattern</a></p><p class="categories"><a href="/categories/Design-Patterns-in-CPP/">Design Patterns in CPP</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">八月 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="ReRoozen&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 ReRoozen</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2024</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>