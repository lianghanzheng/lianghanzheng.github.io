<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MLIR Toy Tutorial - ReRoozen&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ReRoozen&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ReRoozen&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Prologue本文档是基于MLIR Toy Tutorial上附加本人学习经验中遇到的问题及经验而成的学习笔记。 Chap1为了复现教程中的内容，在用CMake配置LLVM时需要加上选项 -DLLVM_BUILD_EXAMPLES&amp;#x3D;ON 来编译相关示例代码，能够在 $BUILD_PATH&amp;#x2F;bin 或者 $INSTALL_PATH&amp;#x2F;examples 中找到。 教程中所用的toy语言编译器文件树如下"><meta property="og:type" content="blog"><meta property="og:title" content="MLIR Toy Tutorial"><meta property="og:url" content="http://example.com/2024/01/04/MLIR/2_Toy-tutorial/"><meta property="og:site_name" content="ReRoozen&#039;s Blog"><meta property="og:description" content="Prologue本文档是基于MLIR Toy Tutorial上附加本人学习经验中遇到的问题及经验而成的学习笔记。 Chap1为了复现教程中的内容，在用CMake配置LLVM时需要加上选项 -DLLVM_BUILD_EXAMPLES&amp;#x3D;ON 来编译相关示例代码，能够在 $BUILD_PATH&amp;#x2F;bin 或者 $INSTALL_PATH&amp;#x2F;examples 中找到。 教程中所用的toy语言编译器文件树如下"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:published_time" content="2024-01-04T07:17:31.000Z"><meta property="article:modified_time" content="2024-03-01T07:13:23.260Z"><meta property="article:author" content="ReRoozen"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2024/01/04/MLIR/2_Toy-tutorial/"},"headline":"MLIR Toy Tutorial","image":["http://example.com/img/og_image.png"],"datePublished":"2024-01-04T07:17:31.000Z","dateModified":"2024-03-01T07:13:23.260Z","author":{"@type":"Person","name":"ReRoozen"},"publisher":{"@type":"Organization","name":"ReRoozen's Blog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"Prologue本文档是基于MLIR Toy Tutorial上附加本人学习经验中遇到的问题及经验而成的学习笔记。 Chap1为了复现教程中的内容，在用CMake配置LLVM时需要加上选项 -DLLVM_BUILD_EXAMPLES&#x3D;ON 来编译相关示例代码，能够在 $BUILD_PATH&#x2F;bin 或者 $INSTALL_PATH&#x2F;examples 中找到。 教程中所用的toy语言编译器文件树如下"}</script><link rel="canonical" href="http://example.com/2024/01/04/MLIR/2_Toy-tutorial/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="ReRoozen&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-04T07:17:31.000Z" title="2024/1/4 15:17:31">2024-01-04</time>发表</span><span class="level-item"><time dateTime="2024-03-01T07:13:23.260Z" title="2024/3/1 15:13:23">2024-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/MLIR/">MLIR</a></span><span class="level-item">1 小时读完 (大约8068个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">MLIR Toy Tutorial</h1><div class="content"><h1 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h1><p>本文档是基于<a target="_blank" rel="noopener" href="https://mlir.llvm.org/docs/Tutorials/Toy/">MLIR Toy Tutorial</a>上附加本人学习经验中遇到的问题及经验而成的学习笔记。</p>
<h1 id="Chap1"><a href="#Chap1" class="headerlink" title="Chap1"></a>Chap1</h1><p>为了复现教程中的内容，在用CMake配置LLVM时需要加上选项 <code>-DLLVM_BUILD_EXAMPLES=ON</code> 来编译相关示例代码，能够在 <code>$BUILD_PATH/bin</code> 或者 <code>$INSTALL_PATH/examples</code> 中找到。</p>
<p>教程中所用的toy语言编译器文件树如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── toy</span><br><span class="line">│       ├── AST.h</span><br><span class="line">│       ├── Lexer.h</span><br><span class="line">│       └── Parser.h</span><br><span class="line">├── parser</span><br><span class="line">│   └── AST.cpp</span><br><span class="line">└── toyc.cpp</span><br></pre></td></tr></table></figure>

<p>使用MLIR来扩展编译流程时，通常是在Clang AST和LLVM IR中间插入了一个层次，所以这个教程中的toy编译器仅提供了将源代码解析为AST的能力。</p>
<p>Toy测试用例如下，可以在 <code>$LLVM_ROOT/mlir/test/Examples/Toy/Ch1/ast.toy</code> 该样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># User defined generic function that operates on unknown shaped arguments.</span><br><span class="line">def multiply_transpose(a, b) &#123;</span><br><span class="line">  return transpose(a) * transpose(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def main() &#123;</span><br><span class="line">  # Define a variable `a` with shape &lt;2, 3&gt;, initialized with the literal value.</span><br><span class="line">  var a = [[1, 2, 3], [4, 5, 6]];</span><br><span class="line">  var b&lt;2, 3&gt; = [1, 2, 3, 4, 5, 6];</span><br><span class="line"></span><br><span class="line">  # This call will specialize `multiply_transpose` with &lt;2, 3&gt; for both</span><br><span class="line">  # arguments and deduce a return type of &lt;3, 2&gt; in initialization of `c`.</span><br><span class="line">  var c = multiply_transpose(a, b);</span><br><span class="line"></span><br><span class="line">  # A second call to `multiply_transpose` with &lt;2, 3&gt; for both arguments will</span><br><span class="line">  # reuse the previously specialized and inferred version and return &lt;3, 2&gt;.</span><br><span class="line">  var d = multiply_transpose(b, a);</span><br><span class="line"></span><br><span class="line">  # A new call with &lt;3, 2&gt; (instead of &lt;2, 3&gt;) for both dimensions will</span><br><span class="line">  # trigger another specialization of `multiply_transpose`.</span><br><span class="line">  var e = multiply_transpose(c, d);</span><br><span class="line"></span><br><span class="line">  # Finally, calling into `multiply_transpose` with incompatible shapes</span><br><span class="line">  # (&lt;2, 3&gt; and &lt;3, 2&gt;) will trigger a shape inference error.</span><br><span class="line">  var f = multiply_transpose(a, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印该示例代码的命令为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$INSTALL_PATH</span>/examples/toyc-ch1 ast.toy</span><br></pre></td></tr></table></figure>

<h1 id="Chap2"><a href="#Chap2" class="headerlink" title="Chap2"></a>Chap2</h1><p>MLIR的核心是Operation，简记为Op。<br>Op具有良好的可扩展性，下列例子展示了为toy中的builtin操作 <code>transpose</code> 定义的Op：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%t_tensor = &quot;toy.transpose&quot;(%tensor) &#123;inplace = true&#125; : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt; loc(&quot;example/file/path&quot;:12:1)</span><br></pre></td></tr></table></figure>

<p>这里给出的是generic形式的Op，其含义如下：</p>
<ul>
<li><code>t_tensor</code>：Op的result</br>MLIR整体被视为一张数据流图，Op是节点，而result就是Op的出边</li>
<li><code>toy.transpose</code>：<code>.</code> 之前是方言，之后是Opcode</br>方言可以被视为MLIR的名称空间</li>
<li><code>(%tensor)</code>：操作数，满足SSA性质</li>
<li><code>&#123;inplace=true&#125;</code>：attribute dictionary</li>
<li><code>(tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt;</code>：Op的参数类型和返回值类型</li>
<li><code>loc(&quot;example/file/path&quot;:12:1)</code> 源代码中的位置信息</li>
</ul>
<blockquote>
<p>教程里说位置信息是需要要有的，这点在各个Op的C++ <code>build</code> 方法的参数中得到了体现。但是还是可以通过 <code>builder.getUnknownLoc()</code> 达到如传的效果。</p>
</blockquote>
<h2 id="定义toy-dialect"><a href="#定义toy-dialect" class="headerlink" title="定义toy dialect"></a>定义toy dialect</h2><p>从C++定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> m = ::mlir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ToyDialect</span> : <span class="keyword">public</span> m::Dialect &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ToyDialect</span><span class="params">(m::MLIRContext *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// utility accessor for dialect</span></span><br><span class="line">  <span class="function"><span class="type">static</span> llvm::StringRef <span class="title">getDialectNamespace</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;toy&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call from constructor of ToyDialect used to</span></span><br><span class="line">  <span class="comment">// register attributes, operations, types, ...</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m::MLIRContext ctx;</span><br><span class="line">  <span class="comment">// register into context</span></span><br><span class="line">  ctx.<span class="built_in">loadDialect</span>&lt;m::toy::ToyDialect&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从TableGene定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def Toy_Dialect : Dialect &#123;</span><br><span class="line">  // Equal to `ToyDialect::getDialectNamespace`</span><br><span class="line">  let name = &quot;toy&quot;;</span><br><span class="line"></span><br><span class="line">  // A short one-line summary for the dialect.</span><br><span class="line">  let summary = &quot;A high-level dialect for toy lang&quot;;</span><br><span class="line"></span><br><span class="line">  // A longer description of our dialect.</span><br><span class="line">  let description = [&#123;The toy lang is ... analysis and optimization.&#125;];</span><br><span class="line"></span><br><span class="line">  // A specific CPP namespace for generating relevant files.</span><br><span class="line">  let cppNamespace = &quot;toy&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从TableGen生成相关C++文件需要使用 <code>mlir-tblgen</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mlir-tblgen -gen-dialect-decls Ops.td -I <span class="variable">$&#123;mlir_src_root&#125;</span>/include/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TODO: 这里生成的文件输出在stdout中，为了在C++中引用，它应该放在哪里呢？文件名应该是什么？</p>
</blockquote>
<h3 id="在-MLIRContext-中注册ToyDialect"><a href="#在-MLIRContext-中注册ToyDialect" class="headerlink" title="在 MLIRContext 中注册ToyDialect"></a>在 <code>MLIRContext</code> 中注册<code>ToyDialect</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="built_in">loadDialect</span>&lt;ToyDialect&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="定义Toy-Op"><a href="#定义Toy-Op" class="headerlink" title="定义Toy Op"></a>定义Toy Op</h2><p>上述步骤定义了一个toy dialect，现在其内部还是空空如也，没有定义Op。<br>接下来尝试定义 <code>toy.constant</code> Op，用来表示toy lang中的常量。</p>
<h3 id="MLIR中的形式"><a href="#MLIR中的形式" class="headerlink" title="MLIR中的形式"></a>MLIR中的形式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%4 = &quot;toy.constant&quot;() &#123; value = dense&lt;1.0&gt; : tensor&lt;2x3xf64&gt; &#125; : () -&gt; tensor&lt;2x3xf64&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有操作数</li>
<li><code>dense</code> 是builtin attribute，包含了一个稠密多维数组；该attribute和与名称 <code>name</code> 绑定在一起来表示一个常量，其类型为 <code>tensor&lt;2x3xf64&gt;</code></li>
</ul>
<h3 id="使用C-定义"><a href="#使用C-定义" class="headerlink" title="使用C++定义"></a>使用C++定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstantOp</span> : <span class="keyword">public</span> mlir::Op&lt;</span><br><span class="line">                     <span class="comment">/// `mlir::Op` is a CRTP class, meaning that we provide the</span></span><br><span class="line">                     <span class="comment">/// derived class as a template parameter.</span></span><br><span class="line">                     ConstantOp,</span><br><span class="line">                     <span class="comment">/// The ConstantOp takes zero input operands.</span></span><br><span class="line">                     mlir::OpTrait::ZeroOperands,</span><br><span class="line">                     <span class="comment">/// The ConstantOp returns a single result.</span></span><br><span class="line">                     mlir::OpTrait::OneResult,</span><br><span class="line">                     <span class="comment">/// We also provide a utility `getType` accessor that</span></span><br><span class="line">                     <span class="comment">/// returns the TensorType of the single result.</span></span><br><span class="line">                     mlir::OpTraits::OneTypedResult&lt;TensorType&gt;::Impl&gt; &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// Inherit the constructors from the base Op class.</span></span><br><span class="line">  <span class="keyword">using</span> Op::Op;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Provide the unique name for this operation. MLIR will use this to register</span></span><br><span class="line">  <span class="comment">/// the operation and uniquely identify it throughout the system. The name</span></span><br><span class="line">  <span class="comment">/// provided here must be prefixed by the parent dialect namespace followed</span></span><br><span class="line">  <span class="comment">/// by a `.`.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> llvm::StringRef <span class="title">getOperationName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;toy.constant&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Return the value of the constant by fetching it from the attribute.</span></span><br><span class="line">  <span class="function">mlir::DenseElementsAttr <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Operations may provide additional verification beyond what the attached</span></span><br><span class="line">  <span class="comment">/// traits provide.  Here we will ensure that the specific invariants of the</span></span><br><span class="line">  <span class="comment">/// constant operation are upheld, for example the result type must be</span></span><br><span class="line">  <span class="comment">/// of TensorType and matches the type of the constant `value`.</span></span><br><span class="line">  <span class="function">LogicalResult <span class="title">verifyInvariants</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Provide an interface to build this operation from a set of input values.</span></span><br><span class="line">  <span class="comment">/// This interface is used by the `builder` classes to allow for easily</span></span><br><span class="line">  <span class="comment">/// generating instances of this operation:</span></span><br><span class="line">  <span class="comment">///   mlir::OpBuilder::create&lt;ConstantOp&gt;(...)</span></span><br><span class="line">  <span class="comment">/// This method populates the given `state` that MLIR uses to create</span></span><br><span class="line">  <span class="comment">/// operations. This state is a collection of all of the discrete elements</span></span><br><span class="line">  <span class="comment">/// that an operation may contain.</span></span><br><span class="line">  <span class="comment">/// Build a constant with the given return type and `value` attribute.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(mlir::OpBuilder &amp;builder, mlir::OperationState &amp;state,</span></span></span><br><span class="line"><span class="params"><span class="function">                    mlir::Type result, mlir::DenseElementsAttr value)</span></span>;</span><br><span class="line">  <span class="comment">/// Build a constant and reuse the type from the given &#x27;value&#x27;.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(mlir::OpBuilder &amp;builder, mlir::OperationState &amp;state,</span></span></span><br><span class="line"><span class="params"><span class="function">                    mlir::DenseElementsAttr value)</span></span>;</span><br><span class="line">  <span class="comment">/// Build a constant by broadcasting the given &#x27;value&#x27;.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(mlir::OpBuilder &amp;builder, mlir::OperationState &amp;state,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">double</span> value)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Trait是一种高层次的信息，其它的还有表示参数和结果类型是否一致等；模板中除了第一参数用在CRTP之外，其它模板参数都是trait</li>
<li><code>getValue</code> 返回的是attrbute</li>
<li><code>verifyInvariants</code> 检验attrbute中保存的是不是一个tensor类型</li>
<li><code>build</code> 提供给 <code>OpBuilder::create</code> 使用的构造方法</li>
<li><code>OperationState</code> 包含各种创建Op的各种属性，如Op名称、位置信息等；这个对象很重量级，应该仅在创建时作为临时变量使用；在使用 <code>OpBuilder::create</code> 创建Op时，该对象由 <code>create</code> 自行创建</li>
</ul>
<h4 id="注册在-ToyDialect-中"><a href="#注册在-ToyDialect-中" class="headerlink" title="注册在 ToyDialect 中"></a>注册在 <code>ToyDialect</code> 中</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyDialect::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">addOperations</span>&lt;ConstantOp&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用ODS框架定义Op"><a href="#使用ODS框架定义Op" class="headerlink" title="使用ODS框架定义Op"></a>使用ODS框架定义Op</h2><p>ODS (Operation Definition Specification) 是MLIR提供的另一种定义Op的方式，使用TableGen语法。</p>
<h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>使用ODS框架时，同样需要从 <code>Op</code> 中派生tablegen record。<br>方便起见，这里先定义一个 <code>Toy_Op</code> 方便后续Op的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Base class for toy dialect operations. This operation inherits from the base</span><br><span class="line">// `Op` class in OpBase.td, and provides:</span><br><span class="line">//   * The parent dialect of the operation.</span><br><span class="line">//   * The mnemonic for the operation, or the name without the dialect prefix.</span><br><span class="line">//   * A list of traits for the operation.</span><br><span class="line">class Toy_Op&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt; :</span><br><span class="line">    Op&lt;Toy_Dialect, mnemonic, traits&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mnemonic</code> 指助记符，即Opcode&#x2F;名字，与之前C++中的 <code>ConstantOp::getOperationName</code> 对应，但不用加上dialect的前缀 <code>toy.</code></li>
<li><code>Toy_Dialect</code> 之前单独定义的dialect</li>
<li>C++中定义时添加的trait在ODS中自动推导并加入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def ConstantOp : Toy_Op&lt;&quot;constant&quot;&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-mlir-tblgen-生成C-文件"><a href="#使用-mlir-tblgen-生成C-文件" class="headerlink" title="使用 mlir-tblgen 生成C++文件"></a>使用 <code>mlir-tblgen</code> 生成C++文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mlir-tblgen -decls-op-defs Ops.td -I <span class="variable">$&#123;mlir_src_root&#125;</span>/include/</span><br><span class="line">mlir-tblgen -gen-op-decls Ops.td -I <span class="variable">$&#123;mlir_src_root&#125;</span>/include/</span><br></pre></td></tr></table></figure>

<h3 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h3><p>填充 <code>arguments</code> 和 <code>results</code> 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def ConstantOp : Toy_Op&lt;&quot;constant&quot;&gt; &#123;</span><br><span class="line">  // The constant operation takes an attribute as the only input.</span><br><span class="line">  // `F64ElementsAttr` corresponds to a 64-bit floating-point ElementsAttr.</span><br><span class="line">  let arguments = (ins F64ElementsAttr:$value);</span><br><span class="line">  let results = (outs F64Tensor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><p>添加 <code>summary</code> 和 <code>description</code> 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def ConstantOp : Toy_Op&lt;&quot;constant&quot;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  // Provide a summary and description for this operation. This can be used to</span><br><span class="line">  // auto-generate documentation of the operations within our dialect.</span><br><span class="line">  let summary = &quot;constant operation&quot;;</span><br><span class="line">  let description = [&#123;</span><br><span class="line">    Constant operation turns a literal into an SSA value. The data is attached</span><br><span class="line">    to the operation as an attribute. For example:</span><br><span class="line"></span><br><span class="line">      %0 = &quot;toy.constant&quot;()</span><br><span class="line">         &#123; value = dense&lt;[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]&gt; : tensor&lt;2x3xf64&gt; &#125;</span><br><span class="line">        : () -&gt; tensor&lt;2x3xf64&gt;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检验Op的语义"><a href="#检验Op的语义" class="headerlink" title="检验Op的语义"></a>检验Op的语义</h3><p>设置 <code>hasVerifier = 1</code> 时会在头文件中生成函数签名 <code>::mlir::Logical verify()</code>。</p>
<h3 id="定义-build"><a href="#定义-build" class="headerlink" title="定义 build"></a>定义 <code>build</code></h3><p>Tablegen能够自动生成一些简单的Op创建函数，剩下的创建函数则需要填充 <code>builders</code> 字段来生成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def ConstantOp : Toy_Op&lt;&quot;constant&quot;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // Add custom build methods for the constant operation. These methods populate</span><br><span class="line">  // the `state` that MLIR uses to create operations, i.e. these are used when</span><br><span class="line">  // using `builder.create&lt;ConstantOp&gt;(...)`.</span><br><span class="line">  let builders = [</span><br><span class="line">    // Build a constant with a given constant tensor value.</span><br><span class="line">    OpBuilder&lt;(ins &quot;DenseElementsAttr&quot;:$value), [&#123;</span><br><span class="line">      // Call into an autogenerated `build` method.</span><br><span class="line">      build(builder, result, value.getType(), value);</span><br><span class="line">    &#125;]&gt;,</span><br><span class="line"></span><br><span class="line">    // Build a constant with a given constant floating-point value. This builder</span><br><span class="line">    // creates a declaration for `ConstantOp::build` with the given parameters.</span><br><span class="line">    OpBuilder&lt;(ins &quot;double&quot;:$value)&gt;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指定MLIR代码格式"><a href="#指定MLIR代码格式" class="headerlink" title="指定MLIR代码格式"></a>指定MLIR代码格式</h2><p>在完整的实现中，<code>$INSTALL_PATH/examples/toyc-ch2 ast.toy -emit=mlir -mlir-print-debuginfo 2&gt; codegen.mlir</code> 能够生成MLIR的generic形式。<br>然而这种形式阅读性不够好，通过自定义指令格式能够获得更好的可读性。</p>
<p>e.g. <code>toy.print</code> 指令在generic格式下会被打印为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;toy.print&quot;(%5) : (tensor&lt;*xf64&gt;) -&gt; () loc(&quot;test/Examples/Toy/Ch2/codegen.toy&quot;:13:3)</span><br></pre></td></tr></table></figure>
<p>然而在定义中它的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toy.print %5 : tensor&lt;*xf64&gt; loc(...)</span><br></pre></td></tr></table></figure>

<p>通过填充 <code>assemblyFormat</code> 和 <code>hasAssemblyFormat</code> 字段能够做到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/// Consider a stripped definition of `toy.print` here.</span><br><span class="line">def PrintOp : Toy_Op&lt;&quot;print&quot;&gt; &#123;</span><br><span class="line">  let arguments = (ins F64Tensor:$input);</span><br><span class="line"></span><br><span class="line">  // Divert the printer and parser to `parse` and `print` methods on our operation,</span><br><span class="line">  // to be implemented in the .cpp file. More details on these methods is shown below.</span><br><span class="line">  let hasCustomAssemblyFormat = 1;</span><br><span class="line"></span><br><span class="line">  // In the following format we have two directives, `attr-dict` and `type`.</span><br><span class="line">  // These correspond to the attribute dictionary and the type of a given</span><br><span class="line">  // variable represectively.</span><br><span class="line">  let assemblyFormat = &quot;$input attr-dict `:` type($input)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>asseblyFormat</code> 字段填入的为declarative格式，主要包括下列三个部分：</p>
<ul>
<li>directives：示例中的 <code>type</code> </li>
<li>literals：由 &#96;&#96; 包围，或者关键字</li>
<li>variables：在Op中注册的数据项，如操作数，结果，后继等，以 <code>$</code> 开头</li>
</ul>
<h3 id="Dialect-h-和-Dialect-cpp"><a href="#Dialect-h-和-Dialect-cpp" class="headerlink" title="Dialect.h 和 Dialect.cpp"></a><code>Dialect.h</code> 和 <code>Dialect.cpp</code></h3><p>该文件需要引用上述生成的文件，用来实现各种解析规则、非默认的 <code>build</code> 方法和 <code>verify</code> 方法。</p>
<p>MLIR相关的内容都放在了目录 <code>mlir</code> 下。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>从文档中可以看出来官方很希望我们用ODS方式来实现我们的MLIR dialect和Op。<br>所有的dialect的文档都是用ODS格式写的。</p>
<h1 id="Chap3"><a href="#Chap3" class="headerlink" title="Chap3"></a>Chap3</h1><h2 id="高层次上语言专有的代码变换"><a href="#高层次上语言专有的代码变换" class="headerlink" title="高层次上语言专有的代码变换"></a>高层次上语言专有的代码变换</h2><p>和编写dialect&#x2F;Op一样，MLIR提供了C++和ODS两种方式来编写代码转换。<br>核心的转换思路都是DAG-to-DAG的转换：匹配一组Op的DAG，然后用另一个DAG去替换它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPattern</span> : <span class="keyword">public</span> RewritePattern &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// This overload constructs a pattern that only matches operations with the</span></span><br><span class="line">  <span class="comment">/// root name of `MyOp`.</span></span><br><span class="line">  <span class="built_in">MyPattern</span>(PatternBenefit benefit, MLIRContext *context)</span><br><span class="line">      : <span class="built_in">RewritePattern</span>(MyOp::<span class="built_in">getOperationName</span>(), benefit, context) &#123;&#125;</span><br><span class="line">  <span class="comment">/// This overload constructs a pattern that matches any operation type.</span></span><br><span class="line">  <span class="built_in">MyPattern</span>(PatternBenefit benefit)</span><br><span class="line">      : <span class="built_in">RewritePattern</span>(benefit, <span class="built_in">MatchAnyOpTypeTag</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// In this section, the `match` and `rewrite` implementation is specified</span></span><br><span class="line">  <span class="comment">/// using the separate hooks.</span></span><br><span class="line">  <span class="function">LogicalResult <span class="title">match</span><span class="params">(Operation *op)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The `match` method returns `success()` if the pattern is a match, failure</span></span><br><span class="line">    <span class="comment">// otherwise.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rewrite</span><span class="params">(Operation *op, PatternRewriter &amp;rewriter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The `rewrite` method performs mutations on the IR rooted at `op` using</span></span><br><span class="line">    <span class="comment">// the provided rewriter. All mutations must go through the provided</span></span><br><span class="line">    <span class="comment">// rewriter.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// In this section, the `match` and `rewrite` implementation is specified</span></span><br><span class="line">  <span class="comment">/// using a single hook.</span></span><br><span class="line">  <span class="function">LogicalResult <span class="title">matchAndRewrite</span><span class="params">(Operation *op, PatternRewriter &amp;rewriter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The `matchAndRewrite` method performs both the matching and the mutation.</span></span><br><span class="line">    <span class="comment">// Note that the match must reach a successful point before IR mutation may</span></span><br><span class="line">    <span class="comment">// take place.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Pattern的定义需要继承 <code>RewritePattern</code></li>
<li>构造函数的参数 <code>benefit</code> 是一个可以被动态计算的值，大致是用来确定变换的优先级 (TODO: 文档里说的东西我没理解)</li>
<li><code>RewritePatern(MyOp&quot;&quot;getOperationName(), ...)</code> 中指定了匹配的DAG中根Op的名称；如果不指定则需要加上 <code>MatchAnyOpTypeTag</code> 来匹配任何可能的pattern</li>
<li><code>match</code> 中不能进行代码变换</li>
<li><code>rewrite</code> 中的代码变换必须用参数中的 <code>PatternRewriter</code> 进行；根Op必须进行以下操作之一：updated in-place、replaced或者erased</li>
<li><code>match</code> 和 <code>rewrite</code> 分别是匹配和重写的具体实现，但是当这两个过程中存在一些复杂的分析或者计算过程时，为了结果复用，可以将两者合并实现为 <code>matchAndRewrite</code></li>
</ul>
<h2 id="transpose-transpose-X-X"><a href="#transpose-transpose-X-X" class="headerlink" title="transpose(transpose(X)) -&gt; X"></a><code>transpose(transpose(X)) -&gt; X</code></h2><p>对于张量 <code>X</code> 而言，连续两次转置操作等价于恒等变换，因此能够进行代码变换来消除冗余操作。</p>
<p>源代码形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def transpose_transpose(x) &#123;</span><br><span class="line">  return transpose(transpose(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中间表示形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">toy.func @transpose_transpose(%arg0: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; &#123;</span><br><span class="line">  %0 = toy.transpose(%arg0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  %1 = toy.transpose(%0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  toy.return %1 : tensor&lt;*xf64&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Fold transpose(transpose(x)) -&gt; x</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SimplifyRedundantTranspose</span> : <span class="keyword">public</span> mlir::OpRewritePattern&lt;TransposeOp&gt; &#123;</span><br><span class="line">  <span class="comment">/// We register this pattern to match every toy.transpose in the IR.</span></span><br><span class="line">  <span class="comment">/// The &quot;benefit&quot; is used by the framework to order the patterns and process</span></span><br><span class="line">  <span class="comment">/// them in order of profitability.</span></span><br><span class="line">  <span class="built_in">SimplifyRedundantTranspose</span>(mlir::MLIRContext *context)</span><br><span class="line">      : <span class="built_in">OpRewritePattern</span>&lt;TransposeOp&gt;(context, <span class="comment">/*benefit=*/</span><span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This method is attempting to match a pattern and rewrite it. The rewriter</span></span><br><span class="line">  <span class="comment">/// argument is the orchestrator of the sequence of rewrites. It is expected</span></span><br><span class="line">  <span class="comment">/// to interact with it to perform any changes to the IR from here.</span></span><br><span class="line">  <span class="function">mlir::LogicalResult</span></span><br><span class="line"><span class="function">  <span class="title">matchAndRewrite</span><span class="params">(TransposeOp op,</span></span></span><br><span class="line"><span class="params"><span class="function">                  mlir::PatternRewriter &amp;rewriter)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Look through the input of the current transpose.</span></span><br><span class="line">    mlir::Value transposeInput = op.<span class="built_in">getOperand</span>();</span><br><span class="line">    TransposeOp transposeInputOp = transposeInput.<span class="built_in">getDefiningOp</span>&lt;TransposeOp&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Input defined by another transpose? If not, no match.</span></span><br><span class="line">    <span class="keyword">if</span> (!transposeInputOp)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">failure</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Otherwise, we have a redundant transpose. Use the rewriter.</span></span><br><span class="line">    rewriter.<span class="built_in">replaceOp</span>(op, &#123;transposeInputOp.<span class="built_in">getOperand</span>()&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>将根Op设置为 <code>TransposeOp</code> 然后判定其参数是不是也是一个 <code>TransposeOp</code>，即可完成判定</li>
<li>代码重写通过 <code>rewriter</code> 完成，用最内层的操作数替换</li>
</ul>
<h4 id="Canonicalization-pass"><a href="#Canonicalization-pass" class="headerlink" title="Canonicalization pass"></a>Canonicalization pass</h4><p>规范化pass能够应有上述的重写规则对Op进行代码变换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register our patterns for rewrite by the Canonicalization framework.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TransposeOp::getCanonicalizationPatterns</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    RewritePatternSet &amp;results, MLIRContext *context)</span> </span>&#123;</span><br><span class="line">  results.<span class="built_in">add</span>&lt;SimplifyRedundantTranspose&gt;(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了启动这个变换还需要将 <code>TransposeOp</code> 的 <code>hasCanonicalizer</code> 字段设置为1。</p>
<h3 id="在MLIR-pass-manager中注册"><a href="#在MLIR-pass-manager中注册" class="headerlink" title="在MLIR pass manager中注册"></a>在MLIR pass manager中注册</h3><p>在驱动 <code>toyc.cpp</code> 中需要将上述优化遍注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mlir::PassManager <span class="title">pm</span><span class="params">(<span class="keyword">module</span>-&gt;getName())</span></span>;</span><br><span class="line">pm.<span class="built_in">addNestedPass</span>&lt;mlir::toy::FuncOp&gt;(mlir::<span class="built_in">createCanonicalizerPass</span>());</span><br></pre></td></tr></table></figure>

<h3 id="pure-Op和代码删除"><a href="#pure-Op和代码删除" class="headerlink" title="pure Op和代码删除"></a>pure Op和代码删除</h3><p>上述pass只能清除掉一个转置操作，即没有进行对整个DAG进行替换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toy.func @transpose_transpose(%arg0: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; &#123;</span><br><span class="line">  %0 = toy.transpose(%arg0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  toy.return %arg0 : tensor&lt;*xf64&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为MLIR会假设所有的Op都是有副作用的，因此会保守地进行代码删除。<br>向 <code>TransposeOp</code> 中添加pure trait能够将两个转置操作都消除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def TransposeOp : Toy_Op&lt;&quot;transpose&quot;, [Pure]&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reshape优化"><a href="#reshape优化" class="headerlink" title="reshape优化"></a>reshape优化</h2><p>对张量进行同样形状的reshape操作也是一种冗余，比如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def main() &#123;</span><br><span class="line">  var a&lt;2,1&gt; = [1, 2];</span><br><span class="line">  var b&lt;2,1&gt; = a;</span><br><span class="line">  var c&lt;2,1&gt; = b;</span><br><span class="line">  print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module &#123;</span><br><span class="line">  toy.func @main() &#123;</span><br><span class="line">    %0 = toy.constant dense&lt;[1.000000e+00, 2.000000e+00]&gt; : tensor&lt;2xf64&gt;</span><br><span class="line">    %1 = toy.reshape(%0 : tensor&lt;2xf64&gt;) to tensor&lt;2x1xf64&gt;</span><br><span class="line">    %2 = toy.reshape(%1 : tensor&lt;2x1xf64&gt;) to tensor&lt;2x1xf64&gt;</span><br><span class="line">    %3 = toy.reshape(%2 : tensor&lt;2x1xf64&gt;) to tensor&lt;2x1xf64&gt;</span><br><span class="line">    toy.print %3 : tensor&lt;2x1xf64&gt;</span><br><span class="line">    toy.return</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DRR实现"><a href="#DRR实现" class="headerlink" title="DRR实现"></a>DRR实现</h3><p>DRR (Table-driven Declarative Rewrite Rule) 使用tablegen描述代码的代码变换规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Pattern&lt;</span><br><span class="line">  dag sourcePattern, list&lt;dag&gt; resultPatterns,</span><br><span class="line">  list&lt;dag&gt; additionalConstraints = [],</span><br><span class="line">  dag benefitsAdded = (addBenefit 0)&gt;;</span><br><span class="line"></span><br><span class="line">// Transpose(Tranpose(x)) = x</span><br><span class="line">def TTOptPattern : Pattern&lt;(TransposeOp(TransposeOp $arg)),</span><br><span class="line">                           ($arg)&gt;;</span><br></pre></td></tr></table></figure>

<p>但是在进行reshape的优化时，我们需要根据reshape的参数来确定优化是否能够执行，而不是简单进行模式匹配。<br>下面的DRR实现了冗余reshape消除优化，增加了约束条件——当输入和输出的shape一致时进行代码变换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def TypesAreIdentical : Constraint&lt;CPred&lt;&quot;$0.getType() == $1.getType()&quot;&gt;&gt;;</span><br><span class="line">def RedundantReshapeOptPattern : Pattern&lt;</span><br><span class="line">  (ReshapeOp:$res $arg), (replaceWithValue $arg),</span><br><span class="line">  [(TypesAreIdentical $res, $arg)]&gt;;</span><br></pre></td></tr></table></figure>

<p>在更特殊的情况下，我们还需要对参数进行变化，这需要通过 <code>NativeCodeCall</code> 进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def ReshapeConstant : NativeCodeCall&lt;&quot;$0.reshape(($1.getType()).cast&lt;ShapedType&gt;())&quot;&gt;;</span><br><span class="line">def FoldConstantReshapeOptPattern : Pat&lt;</span><br><span class="line">  (ReshapeOp:$res (ConstantOp $arg)),</span><br><span class="line">  (ConstantOp (ReshapeConstant $arg, $res))&gt;;</span><br></pre></td></tr></table></figure>

<h1 id="Chap4"><a href="#Chap4" class="headerlink" title="Chap4"></a>Chap4</h1><h2 id="通用代码变换"><a href="#通用代码变换" class="headerlink" title="通用代码变换"></a>通用代码变换</h2><p>在MLIR中，通用pass不需要为不同的dialect分别实现。<br>之前在编写转置优化时，<code>getCanonicalizationPatterns</code> 就是一个用来注册pass的hook。<br>但是hook的可扩展性比较有限，不能满足通用优化遍的需求，因此MLIR提供了interface来支持通用pass。</p>
<h2 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h2><p>MLIR提供了通用的inliner并允许我们将其挂载到toy dialect中，我们需要提供让inliner挂载的interface。</p>
<h3 id="Dialect-interface"><a href="#Dialect-interface" class="headerlink" title="Dialect interface"></a>Dialect interface</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This class defines the interface for handling inlining with Toy operations.</span></span><br><span class="line"><span class="comment">/// We simplify inherit from the base interface class and override</span></span><br><span class="line"><span class="comment">/// the necessary methods.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ToyInlinerInterface</span> : <span class="keyword">public</span> DialectInlinerInterface &#123;</span><br><span class="line">  <span class="keyword">using</span> DialectInlinerInterface::DialectInlinerInterface;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This hook checks to see if the given callable operation is legal to inline</span></span><br><span class="line">  <span class="comment">/// into the given call. For Toy this hook can simply return true, as the Toy</span></span><br><span class="line">  <span class="comment">/// Call operation is always inlinable.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isLegalToInline</span><span class="params">(Operation *call, Operation *callable,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">bool</span> wouldBeCloned)</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This hook checks to see if the given operation is legal to inline into the</span></span><br><span class="line">  <span class="comment">/// given region. For Toy this hook can simply return true, as all Toy</span></span><br><span class="line">  <span class="comment">/// operations are inlinable.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isLegalToInline</span><span class="params">(Operation *, Region *, <span class="type">bool</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       IRMapping &amp;)</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This hook cheks if the given &#x27;src&#x27; region can be inlined into the &#x27;dest&#x27;</span></span><br><span class="line">  <span class="comment">/// region. The regions here are the bodies of the callable functions. For</span></span><br><span class="line">  <span class="comment">/// Toy, any function can be inlined, so we simply return true.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isLegalToInline</span><span class="params">(Region *dest, Region *src, <span class="type">bool</span> wouldBeCloned,</span></span></span><br><span class="line"><span class="params"><span class="function">                       IRMapping &amp;valueMapping)</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This hook is called when a terminator operation has been inlined. The only</span></span><br><span class="line">  <span class="comment">/// terminator that we have in the Toy dialect is the return</span></span><br><span class="line">  <span class="comment">/// operation(toy.return). We handle the return by replacing the values</span></span><br><span class="line">  <span class="comment">/// previously returned by the call operation with the operands of the</span></span><br><span class="line">  <span class="comment">/// return.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleTerminator</span><span class="params">(Operation *op,</span></span></span><br><span class="line"><span class="params"><span class="function">                        MutableArrayRef&lt;Value&gt; valuesToRepl)</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Only &quot;toy.return&quot; needs to be handled here.</span></span><br><span class="line">    <span class="keyword">auto</span> returnOp = <span class="built_in">cast</span>&lt;ReturnOp&gt;(op);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace the values directly with the return operands.</span></span><br><span class="line">    <span class="built_in">assert</span>(returnOp.<span class="built_in">getNumOperands</span>() == valuesToRepl.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;it : llvm::<span class="built_in">enumerate</span>(returnOp.<span class="built_in">getOperands</span>()))</span><br><span class="line">      valuesToRepl[it.<span class="built_in">index</span>()].<span class="built_in">replaceAllUsesWith</span>(it.<span class="built_in">value</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这部分提供了在toy lang中进行内联操作的约束条件，重载了interface提供的虚函数hook</li>
</ul>
<p>另一方面，inliner还需要设置函数在MLIR生成过程中的可见性，因为inliner会删掉被设置为private且没有没使用的函数的定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Emit a new function and add it to the MLIR module.</span></span><br><span class="line">mlir::<span class="function">toy::FuncOp <span class="title">mlirGen</span><span class="params">(FunctionAST &amp;funcAST)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// If this function isn&#x27;t main, then set the visibility to private.</span></span><br><span class="line">  <span class="keyword">if</span> (funcAST.<span class="built_in">getProto</span>()-&gt;<span class="built_in">getName</span>() != <span class="string">&quot;main&quot;</span>)</span><br><span class="line">    function.<span class="built_in">setPrivate</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在dialect中注册"><a href="#在dialect中注册" class="headerlink" title="在dialect中注册"></a>在dialect中注册</h4><p>和Op一样，interface也要在dialect中注册才能使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyDialect::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">addInterfaces</span>&lt;ToyInlinerInterface&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Operation-interface"><a href="#Operation-interface" class="headerlink" title="Operation interface"></a>Operation interface</h3><p>Toy lang中使用 <code>toy.generic_call</code> 表示代码函数调用，使用 <code>toy.func</code> 表示函数定义。<br>通过operation interface能够让iniliner知道要对这两个Op分别是call-like和callable-like。</p>
<p>在 <code>Ops.td</code> 中需要引用interface的相关文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &quot;mlir/Interfaces/CallInterfaces.td&quot;</span><br></pre></td></tr></table></figure>

<p>添加相关trait：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def FuncOp : Toy_Op&lt;&quot;func&quot;,</span><br><span class="line">    [DeclareOpInterfaceMethods&lt;CallableOpInterface&gt;]&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def GenericCallOp : Toy_Op&lt;&quot;generic_call&quot;,</span><br><span class="line">    [DeclareOpInterfaceMethods&lt;CallOpInterface&gt;]&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>DeclareOpInterfaceMethods</code> 是ODS direcitive，能自动生成所有的方法函数签名，使我们只用提供函数的实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Returns the region on the function operation that is callable.</span></span><br><span class="line"><span class="function">Region *<span class="title">FuncOp::getCallableRegion</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;<span class="built_in">getBody</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Return the callee of the generic call operation, this is required by the</span></span><br><span class="line"><span class="comment">/// call interface.</span></span><br><span class="line"><span class="function">CallInterfaceCallable <span class="title">GenericCallOp::getCallableForCallee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">getAttrOfType</span>&lt;SymbolRefAttr&gt;(<span class="string">&quot;callee&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Set the callee for the generic call operation, this is required by the call</span></span><br><span class="line"><span class="comment">/// interface.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenericCallOp::setCalleeFromCallable</span><span class="params">(CallInterfaceCallable callee)</span> </span>&#123;</span><br><span class="line">  (*<span class="keyword">this</span>)-&gt;<span class="built_in">setAttr</span>(<span class="string">&quot;callee&quot;</span>, callee.<span class="built_in">get</span>&lt;SymbolRefAttr&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Get the argument operands to the called function, this is required by the</span></span><br><span class="line"><span class="comment">/// call interface.</span></span><br><span class="line"><span class="function">Operation::operand_range <span class="title">GenericCallOp::getArgOperands</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">inputs</span>(); &#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加到pass-manager中"><a href="#添加到pass-manager中" class="headerlink" title="添加到pass manager中"></a>添加到pass manager中</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.<span class="built_in">addPass</span>(mlir::<span class="built_in">createInlinerPass</span>());</span><br></pre></td></tr></table></figure>

<h3 id="处理类型转换"><a href="#处理类型转换" class="headerlink" title="处理类型转换"></a>处理类型转换</h3><p>在toy lang中，即使一个张量的shape是确定的，在传入的时候也会被转换为不定形状的 <code>tensor&lt;*xf64&gt;</code>，为此iniliner需要显式类型转换，实现为 <code>toy.cast</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def CastOp : Toy_Op&lt;&quot;cast&quot;, [</span><br><span class="line">    DeclareOpInterfaceMethods&lt;CastOpInterface&gt;,</span><br><span class="line">    Pure,</span><br><span class="line">    SameOperandsAndResultShape]</span><br><span class="line">  &gt; &#123;</span><br><span class="line">  let summary = &quot;shape cast operation&quot;;</span><br><span class="line">  let description = [&#123;</span><br><span class="line">    The &quot;cast&quot; operation converts a tensor from one type to an equivalent type</span><br><span class="line">    without changing any data elements. The source and destination types</span><br><span class="line">    must both be tensor types with the same element type. If both are ranked,</span><br><span class="line">    then shape is required to match. The operation is invalid if converting</span><br><span class="line">    to a mismatching constant dimension.</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  let arguments = (ins F64Tensor:$input);</span><br><span class="line">  let results = (outs F64Tensor:$output);</span><br><span class="line">  let assemblyFormat = &quot;$input attr-dict `:` type($input) `to` type($output)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Trait list中添加了 <code>CastOpInterface</code>，提供了一些转型用的工具，如检验转型是否正确</li>
</ul>
<p>在实现中提供检验转型是否能成功的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Returns true if the given set of input and result types are compatible with</span></span><br><span class="line"><span class="comment">/// this cast operation. This is required by the `CastOpInterface` to verify</span></span><br><span class="line"><span class="comment">/// this operation and provide other additional utilities.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CastOp::areCastCompatible</span><span class="params">(TypeRange inputs, TypeRange outputs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inputs.<span class="built_in">size</span>() != <span class="number">1</span> || outputs.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// The inputs must be Tensors with the same element type.</span></span><br><span class="line">  TensorType input = inputs.<span class="built_in">front</span>().<span class="built_in">dyn_cast</span>&lt;TensorType&gt;();</span><br><span class="line">  TensorType output = outputs.<span class="built_in">front</span>().<span class="built_in">dyn_cast</span>&lt;TensorType&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!input || !output || input.<span class="built_in">getElementType</span>() != output.<span class="built_in">getElementType</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// The shape is required to match if both types are ranked.</span></span><br><span class="line">  <span class="keyword">return</span> !input.<span class="built_in">hasRank</span>() || !output.<span class="built_in">hasRank</span>() || input == output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在dialect-interface重载相关hook"><a href="#在dialect-interface重载相关hook" class="headerlink" title="在dialect interface重载相关hook"></a>在dialect interface重载相关hook</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ToyInlinerInterface</span> : <span class="keyword">public</span> DialectInlinerInterface &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Attempts to materialize a conversion for a type mismatch between a call</span></span><br><span class="line">  <span class="comment">/// from this dialect, and a callable region. This method should generate an</span></span><br><span class="line">  <span class="comment">/// operation that takes &#x27;input&#x27; as the only operand, and produces a single</span></span><br><span class="line">  <span class="comment">/// result of &#x27;resultType&#x27;. If a conversion can not be generated, nullptr</span></span><br><span class="line">  <span class="comment">/// should be returned.</span></span><br><span class="line">  <span class="function">Operation *<span class="title">materializeCallConversion</span><span class="params">(OpBuilder &amp;builder, Value input,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       Type resultType,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       Location conversionLoc)</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.<span class="built_in">create</span>&lt;CastOp&gt;(conversionLoc, resultType, input);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="过程内shape传播"><a href="#过程内shape传播" class="headerlink" title="过程内shape传播"></a>过程内shape传播</h2><p>内联前程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">toy.func @multiply_transpose(%arg0: tensor&lt;*xf64&gt;, %arg1: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; &#123;</span><br><span class="line">  %0 = toy.transpose(%arg0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  %1 = toy.transpose(%arg1 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  %2 = toy.mul %0, %1 : tensor&lt;*xf64&gt;</span><br><span class="line">  toy.return %2 : tensor&lt;*xf64&gt;</span><br><span class="line">&#125;</span><br><span class="line">toy.func @main() &#123;</span><br><span class="line">  %0 = toy.constant dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;</span><br><span class="line">  %1 = toy.reshape(%0 : tensor&lt;2x3xf64&gt;) to tensor&lt;2x3xf64&gt;</span><br><span class="line">  %2 = toy.constant dense&lt;[1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00]&gt; : tensor&lt;6xf64&gt;</span><br><span class="line">  %3 = toy.reshape(%2 : tensor&lt;6xf64&gt;) to tensor&lt;2x3xf64&gt;</span><br><span class="line">  %4 = toy.generic_call @multiply_transpose(%1, %3) : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;</span><br><span class="line">  %5 = toy.generic_call @multiply_transpose(%3, %1) : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;</span><br><span class="line">  toy.print %5 : tensor&lt;*xf64&gt;</span><br><span class="line">  toy.return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内联后程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toy.func @main() &#123;</span><br><span class="line">  %0 = toy.constant dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;</span><br><span class="line">  %1 = toy.constant dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;</span><br><span class="line">  %2 = toy.cast %1 : tensor&lt;2x3xf64&gt; to tensor&lt;*xf64&gt;</span><br><span class="line">  %3 = toy.cast %0 : tensor&lt;2x3xf64&gt; to tensor&lt;*xf64&gt;</span><br><span class="line">  %4 = toy.transpose(%2 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  %5 = toy.transpose(%3 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  %6 = toy.mul %4, %5 : tensor&lt;*xf64&gt;</span><br><span class="line">  toy.print %6 : tensor&lt;*xf64&gt;</span><br><span class="line">  toy.return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中出现了确定形状和不定形状张量类型的混合。<br>为了让代码规范，shape传播可以被实现为toy dialect专有的pass，但是这个操作也很通用。<br>将代码变换实现为通用的能够提高整个系统的可扩展性。<br>完成这个pass的核心在于需要定义一个Op，它能够根据输入的类型推断合理的输出类型。</p>
<h3 id="定义operation-interface"><a href="#定义operation-interface" class="headerlink" title="定义operation interface"></a>定义operation interface</h3><p>决定将这个Op实现为通用的组件，就需要将其实现为operation interface。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def ShapeInferenceOpInterface : OpInterface&lt;&quot;ShapeInference&quot;&gt; &#123;</span><br><span class="line">  let description = [&#123;</span><br><span class="line">    Interface to access a registered method to infer the return types for an</span><br><span class="line">    operation that can be used during type inference.</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来需要定义这个interface中的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def ShapeInferenceOpInterface : OpInterface&lt;&quot;ShapeInference&quot;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  let methods = [</span><br><span class="line">    InterfaceMethod&lt;&quot;Infer and set the output shape for the current operation.&quot;,</span><br><span class="line">                    &quot;void&quot;, &quot;inferShapes&quot;&gt;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Interface方法包括：</p>
<ul>
<li>描述信息</li>
<li>C++返回类型</li>
<li>方法名称</li>
<li><a target="_blank" rel="noopener" href="https://mlir.llvm.org/docs/Interfaces/#attributeoperationtype-interfaces">可选项</a></li>
</ul>
<p>和之前使用inliner一样，向相关的toy Op添加trait，并以C++形式实现相关方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def MulOp : Toy_Op&lt;&quot;mul&quot;,</span><br><span class="line">    [..., DeclareOpInterfaceMethods&lt;ShapeInferenceOpInterface&gt;]&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Infer the output shape of the MulOp, this is required by the shape inference</span></span><br><span class="line"><span class="comment">/// interface.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MulOp::inferShapes</span><span class="params">()</span> </span>&#123; <span class="built_in">getResult</span>().<span class="built_in">setType</span>(<span class="built_in">getLhs</span>().<span class="built_in">getType</span>()); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义pass"><a href="#定义pass" class="headerlink" title="定义pass"></a>定义pass</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeInferencePass</span></span><br><span class="line">    : <span class="keyword">public</span> mlir::PassWrapper&lt;ShapeInferencePass, OperationPass&lt;FuncOp&gt;&gt; &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">runOnOperation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    FuncOp function = <span class="built_in">getOperation</span>();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>OperationPass&lt;FuncOp&gt;</code> 表示该pass只在func上使用</li>
<li>重载 <code>runOnOperation</code></li>
</ul>
<p>创建辅助函数以实例化该pass：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;mlir::Pass&gt; mlir::toy::<span class="built_in">createShapeInferencePass</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ShapeInferencePass&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向pass manager中注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.<span class="built_in">addPass</span>(mlir::<span class="built_in">createShapeInferencePass</span>());</span><br></pre></td></tr></table></figure>

<h3 id="Shape-inference的大致实现"><a href="#Shape-inference的大致实现" class="headerlink" title="Shape inference的大致实现"></a>Shape inference的大致实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ask the operation to infer its output shapes.</span></span><br><span class="line"><span class="built_in">LLVM_DEBUG</span>(llvm::<span class="built_in">dbgs</span>() &lt;&lt; <span class="string">&quot;Inferring shape for: &quot;</span> &lt;&lt; *op &lt;&lt; <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// We check if an operation has a particular interface by casting.</span></span><br><span class="line"><span class="keyword">if</span> (ShapeInference shapeOp = <span class="built_in">dyn_cast</span>&lt;ShapeInference&gt;(op)) &#123;</span><br><span class="line">  shapeOp.<span class="built_in">inferShapes</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  op-&gt;<span class="built_in">emitError</span>(<span class="string">&quot;unable to infer shape of operation without shape &quot;</span></span><br><span class="line">                <span class="string">&quot;inference interface&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">signalPassFailure</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Chap5"><a href="#Chap5" class="headerlink" title="Chap5"></a>Chap5</h1><p>生成能够真正执行的代码需要使用LLVM，但是直接通过LLVM builder会非常麻烦，因此真正采取的方法是对MLIR代码进行部分降级，达到一个各种dialect混合的状态。</p>
<p>这一节会将toy dialect中的某些结构转换为affine dialect：专门用来表示并优化计算密集的部分；将张量转换为 <code>memref</code> 使数据对象能够在affine循环中引用。<br>这是因为tensor只表示一个数据类型，而不存在于内存中。</p>
<h2 id="Dialect转换"><a href="#Dialect转换" class="headerlink" title="Dialect转换"></a>Dialect转换</h2><p>MLIR提供了一个框架 <code>DialectConversion</code> 对不同的dialect进行转换。<br>这个框架需要以下信息：</p>
<ul>
<li>conversion target</li>
<li>rewrite pattern</li>
<li>type converter (option)</li>
</ul>
<h3 id="Conversion-target"><a href="#Conversion-target" class="headerlink" title="Conversion target"></a>Conversion target</h3><p>表示一个计算密集的部分可用的dialect有 <code>affine</code>, <code>arith</code>, <code>func</code>, <code>memref</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyToAffineLoweringPass::runOnOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The first thing to define is the conversion target. This will define the</span></span><br><span class="line">  <span class="comment">// final target for this lowering.</span></span><br><span class="line">  <span class="function">mlir::ConversionTarget <span class="title">target</span><span class="params">(getContext())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We define the specific operations, or dialects, that are legal targets for</span></span><br><span class="line">  <span class="comment">// this lowering. In our case, we are lowering to a combination of the</span></span><br><span class="line">  <span class="comment">// `Affine`, `Arith`, `Func`, and `MemRef` dialects.</span></span><br><span class="line">  target.<span class="built_in">addLegalDialect</span>&lt;affine::AffineDialect, arith::ArithDialect,</span><br><span class="line">                         func::FuncDialect, memref::MemRefDialect&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We also define the Toy dialect as Illegal so that the conversion will fail</span></span><br><span class="line">  <span class="comment">// if any of these operations are *not* converted. Given that we actually want</span></span><br><span class="line">  <span class="comment">// a partial lowering, we explicitly mark the Toy operations that don&#x27;t want</span></span><br><span class="line">  <span class="comment">// to lower, `toy.print`, as *legal*. `toy.print` will still need its operands</span></span><br><span class="line">  <span class="comment">// to be updated though (as we convert from TensorType to MemRefType), so we</span></span><br><span class="line">  <span class="comment">// only treat it as `legal` if its operands are legal.</span></span><br><span class="line">  target.<span class="built_in">addIllegalDialect</span>&lt;ToyDialect&gt;();</span><br><span class="line">  target.<span class="built_in">addDynamicallyLegalOp</span>&lt;toy::PrintOp&gt;([](toy::PrintOp op) &#123;</span><br><span class="line">    <span class="keyword">return</span> llvm::<span class="built_in">none_of</span>(op-&gt;<span class="built_in">getOperandTypes</span>(),</span><br><span class="line">                         [](Type type) &#123; <span class="keyword">return</span> type.<span class="built_in">isa</span>&lt;TensorType&gt;(); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Conversion target是保存降级后的代码的context</li>
<li>将toy dialect设置为illegal能够保证代码被完全转换；除了 <code>toy.print</code></li>
</ul>
<h3 id="Conversion-pattern"><a href="#Conversion-pattern" class="headerlink" title="Conversion pattern"></a>Conversion pattern</h3><p>定义了conversion target之后，代码降级的过程就能够被定义为从illegal dialect向legal dialect的转换。<br>相较于在dialect内优化代码的rewrite pattern，conversion pattern能够接受 <code>operands</code> 参数来处理操作数的类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Lower the `toy.transpose` operation to an affine loop nest.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TransposeOpLowering</span> : <span class="keyword">public</span> mlir::ConversionPattern &#123;</span><br><span class="line">  <span class="built_in">TransposeOpLowering</span>(mlir::MLIRContext *ctx)</span><br><span class="line">      : mlir::<span class="built_in">ConversionPattern</span>(TransposeOp::<span class="built_in">getOperationName</span>(), <span class="number">1</span>, ctx) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Match and rewrite the given `toy.transpose` operation, with the given</span></span><br><span class="line">  <span class="comment">/// operands that have been remapped from `tensor&lt;...&gt;` to `memref&lt;...&gt;`.</span></span><br><span class="line">  <span class="function">mlir::LogicalResult</span></span><br><span class="line"><span class="function">  <span class="title">matchAndRewrite</span><span class="params">(mlir::Operation *op, ArrayRef&lt;mlir::Value&gt; operands,</span></span></span><br><span class="line"><span class="params"><span class="function">                  mlir::ConversionPatternRewriter &amp;rewriter)</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> loc = op-&gt;<span class="built_in">getLoc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call to a helper function that will lower the current operation to a set</span></span><br><span class="line">    <span class="comment">// of affine loops. We provide a functor that operates on the remapped</span></span><br><span class="line">    <span class="comment">// operands, as well as the loop induction variables for the inner most</span></span><br><span class="line">    <span class="comment">// loop body.</span></span><br><span class="line">    <span class="built_in">lowerOpToLoops</span>(</span><br><span class="line">        op, operands, rewriter,</span><br><span class="line">        [loc](mlir::PatternRewriter &amp;rewriter,</span><br><span class="line">              ArrayRef&lt;mlir::Value&gt; memRefOperands,</span><br><span class="line">              ArrayRef&lt;mlir::Value&gt; loopIvs) &#123;</span><br><span class="line">          <span class="comment">// Generate an adaptor for the remapped operands of the TransposeOp.</span></span><br><span class="line">          <span class="comment">// This allows for using the nice named accessors that are generated</span></span><br><span class="line">          <span class="comment">// by the ODS. This adaptor is automatically provided by the ODS</span></span><br><span class="line">          <span class="comment">// framework.</span></span><br><span class="line">          TransposeOpAdaptor <span class="built_in">transposeAdaptor</span>(memRefOperands);</span><br><span class="line">          mlir::Value input = transposeAdaptor.<span class="built_in">input</span>();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Transpose the elements by generating a load from the reverse</span></span><br><span class="line">          <span class="comment">// indices.</span></span><br><span class="line">          SmallVector&lt;mlir::Value, <span class="number">2</span>&gt; <span class="built_in">reverseIvs</span>(llvm::<span class="built_in">reverse</span>(loopIvs));</span><br><span class="line">          <span class="keyword">return</span> rewriter.<span class="built_in">create</span>&lt;mlir::AffineLoadOp&gt;(loc, input, reverseIvs);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现后conversion pattern需要注册会conversion target中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyToAffineLoweringPass::runOnOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now that the conversion target has been defined, we just need to provide</span></span><br><span class="line">  <span class="comment">// the set of patterns that will lower the Toy operations.</span></span><br><span class="line">  <span class="function">mlir::RewritePatternSet <span class="title">patterns</span><span class="params">(&amp;getContext())</span></span>;</span><br><span class="line">  patterns.<span class="built_in">add</span>&lt;..., TransposeOpLowering&gt;(&amp;<span class="built_in">getContext</span>());</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="部分降级"><a href="#部分降级" class="headerlink" title="部分降级"></a>部分降级</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyToAffineLoweringPass::runOnOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// With the target and rewrite patterns defined, we can now attempt the</span></span><br><span class="line">  <span class="comment">// conversion. The conversion will signal failure if any of our *illegal*</span></span><br><span class="line">  <span class="comment">// operations were not converted successfully.</span></span><br><span class="line">  <span class="keyword">if</span> (mlir::<span class="built_in">failed</span>(mlir::<span class="built_in">applyPartialConversion</span>(<span class="built_in">getOperation</span>(), target, patterns)))</span><br><span class="line">    <span class="built_in">signalPassFailure</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>partialConversion</code> 是若干转换方法降级方式中的一种</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>一方面，我们将张量转换为了 <code>memref</code>；另一方面，<code>toy.print</code> 仍然以张量为参数类型。<br>两者之间需要建立某种临时的辅助保证部分降级后的代码的正确性。<br>以下几种方法都是可行的：</p>
<ul>
<li>生成 <code>load</code> 操作来实例化tensor<ul>
<li>可以不对 <code>toy.print</code> 进行修改</li>
<li>但是会影响affine的优化效果</li>
</ul>
</li>
<li>另外创建一个类似 <code>toy.print</code> 但是能接受 <code>memref</code> 为参数的Op<ul>
<li>不会引入额外的复制开销</li>
<li>但是会在dialect中引入冗余的Op</li>
</ul>
</li>
<li>更新 <code>toy.print</code> 的定义<ul>
<li>让toy dialect参与多个抽象层次，与MLIR的设计理念碰撞</li>
</ul>
</li>
</ul>
<p>从简便性考虑，教程最后采纳了第三种方案，允许 <code>toy.print</code> 接受 <code>memref</code> 作为参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def PrintOp : Toy_Op&lt;&quot;print&quot;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // The print operation takes an input tensor to print.</span><br><span class="line">  // We also allow a F64MemRef to enable interop during partial lowering.</span><br><span class="line">  let arguments = (ins AnyTypeOf&lt;[F64Tensor, F64MemRef]&gt;:$input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Chap-6"><a href="#Chap-6" class="headerlink" title="Chap 6"></a>Chap 6</h1><h2 id="降级到LLVM并生成代码"><a href="#降级到LLVM并生成代码" class="headerlink" title="降级到LLVM并生成代码"></a>降级到LLVM并生成代码</h2><p>在上一个步骤中，为了进行代码优化，我们进行了局部降级。<br>现在为了生成可执行文件，我们必须要将代码彻底降级为LLVM dialect。</p>
<h3 id="对-toy-print-降级"><a href="#对-toy-print-降级" class="headerlink" title="对 toy.print 降级"></a>对 <code>toy.print</code> 降级</h3><p>方便起见，<code>toy.print</code> 会被转换为在每个元素上调用 <code>printf</code>。<br>MLIR的转换是逐级进行的，因此不用直接映射到LLVM IR上。<br>因此我们可以先生成SCF风格的 <code>printf</code> 循环而不是LLVM IR的基本块。</p>
<h4 id="创建-printf-的函数声明"><a href="#创建-printf-的函数声明" class="headerlink" title="创建 printf 的函数声明"></a>创建 <code>printf</code> 的函数声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Return a symbol reference to the printf function, inserting it into the</span></span><br><span class="line"><span class="comment">/// module if necessary.</span></span><br><span class="line"><span class="function"><span class="type">static</span> FlatSymbolRefAttr <span class="title">getOrInsertPrintf</span><span class="params">(PatternRewriter &amp;rewriter,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           ModuleOp <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           LLVM::LLVMDialect *llvmDialect)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> *context = <span class="keyword">module</span>.<span class="built_in">getContext</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">module</span>.<span class="built_in">lookupSymbol</span>&lt;LLVM::LLVMFuncOp&gt;(<span class="string">&quot;printf&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> SymbolRefAttr::<span class="built_in">get</span>(<span class="string">&quot;printf&quot;</span>, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a function declaration for printf, the signature is:</span></span><br><span class="line">  <span class="comment">//   * `i32 (i8*, ...)`</span></span><br><span class="line">  <span class="keyword">auto</span> llvmI32Ty = IntegerType::<span class="built_in">get</span>(context, <span class="number">32</span>);</span><br><span class="line">  <span class="keyword">auto</span> llvmI8PtrTy =</span><br><span class="line">      LLVM::LLVMPointerType::<span class="built_in">get</span>(IntegerType::<span class="built_in">get</span>(context, <span class="number">8</span>));</span><br><span class="line">  <span class="keyword">auto</span> llvmFnType = LLVM::LLVMFunctionType::<span class="built_in">get</span>(llvmI32Ty, llvmI8PtrTy,</span><br><span class="line">                                                <span class="comment">/*isVarArg=*/</span><span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert the printf function into the body of the parent module.</span></span><br><span class="line">  <span class="function">PatternRewriter::InsertionGuard <span class="title">insertGuard</span><span class="params">(rewriter)</span></span>;</span><br><span class="line">  rewriter.<span class="built_in">setInsertionPointToStart</span>(<span class="keyword">module</span>.<span class="built_in">getBody</span>());</span><br><span class="line">  rewriter.<span class="built_in">create</span>&lt;LLVM::LLVMFuncOp&gt;(<span class="keyword">module</span>.<span class="built_in">getLoc</span>(), <span class="string">&quot;printf&quot;</span>, llvmFnType);</span><br><span class="line">  <span class="keyword">return</span> SymbolRefAttr::<span class="built_in">get</span>(<span class="string">&quot;printf&quot;</span>, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Conversion-target-1"><a href="#Conversion-target-1" class="headerlink" title="Conversion target"></a>Conversion target</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mlir::ConversionTarget <span class="title">target</span><span class="params">(getContext())</span></span>;</span><br><span class="line">target.<span class="built_in">addLegalDialect</span>&lt;mlir::LLVMDialect&gt;();</span><br><span class="line">target.<span class="built_in">addLegalOp</span>&lt;mlir::ModuleOp&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="Type-converter"><a href="#Type-converter" class="headerlink" title="Type converter"></a>Type converter</h4><p><code>memref</code> 需要被转换为LLVM IR能够表示的类型，而type converter能够描述类型的映射关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LLVMTypeConverter <span class="title">typeConverter</span><span class="params">(&amp;getContext())</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="Conversion-pattern-1"><a href="#Conversion-pattern-1" class="headerlink" title="Conversion pattern"></a>Conversion pattern</h4><p>在降级的过程中，整个MLIR包含以下要素：</p>
<ul>
<li><code>toy</code></li>
<li><code>affine</code></li>
<li><code>arith</code></li>
<li><code>std</code></li>
</ul>
<p>好在 <code>affine</code>，<code>arith</code> 和 <code>std</code> 都已经内置像向LLVM dialect转换的pattern：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mlir::RewritePatternSet <span class="title">patterns</span><span class="params">(&amp;getContext())</span></span>;</span><br><span class="line">mlir::<span class="built_in">populateAffineToStdConversionPatterns</span>(patterns, &amp;<span class="built_in">getContext</span>());</span><br><span class="line">mlir::cf::<span class="built_in">populateSCFToControlFlowConversionPatterns</span>(patterns, &amp;<span class="built_in">getContext</span>());</span><br><span class="line">mlir::arith::<span class="built_in">populateArithToLLVMConversionPatterns</span>(typeConverter,</span><br><span class="line">                                                        patterns);</span><br><span class="line">mlir::<span class="built_in">populateFuncToLLVMConversionPatterns</span>(typeConverter, patterns);</span><br><span class="line">mlir::cf::<span class="built_in">populateControlFlowToLLVMConversionPatterns</span>(patterns, &amp;<span class="built_in">getContext</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// The only remaining operation, to lower from the `toy` dialect, is the</span></span><br><span class="line"><span class="comment">// PrintOp.</span></span><br><span class="line">patterns.<span class="built_in">add</span>&lt;PrintOpLowering&gt;(&amp;<span class="built_in">getContext</span>());</span><br></pre></td></tr></table></figure>

<h3 id="完全降级"><a href="#完全降级" class="headerlink" title="完全降级"></a>完全降级</h3><p>与之前的部分降级相对，是另一种降级方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mlir::ModuleOp <span class="keyword">module</span> = <span class="built_in">getOperation</span>();</span><br><span class="line"><span class="keyword">if</span> (mlir::<span class="built_in">failed</span>(mlir::<span class="built_in">applyFullConversion</span>(<span class="keyword">module</span>, target, patterns)))</span><br><span class="line">  <span class="built_in">signalPassFailure</span>();</span><br></pre></td></tr></table></figure>

<h2 id="离开MLIR和代码生成"><a href="#离开MLIR和代码生成" class="headerlink" title="离开MLIR和代码生成"></a>离开MLIR和代码生成</h2><p>LLVM dialect能够直接生成LLVM IR，接下来的工作只不过是调用工具而已。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;llvm::Module&gt; llvmModule = mlir::<span class="built_in">translateModuleToLLVMIR</span>(<span class="keyword">module</span>);</span><br><span class="line"> <span class="keyword">if</span> (!llvmModule)</span><br><span class="line">   <span class="comment">/* ... an error was encountered ... */</span></span><br></pre></td></tr></table></figure>

<h3 id="设置JIT"><a href="#设置JIT" class="headerlink" title="设置JIT"></a>设置JIT</h3><p>如果直接生成LLVM IR进行静态编译，还可以设置JIT编译 <code>.mlir</code> 文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">runJit</span><span class="params">(mlir::ModuleOp <span class="keyword">module</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize LLVM targets.</span></span><br><span class="line">  llvm::<span class="built_in">InitializeNativeTarget</span>();</span><br><span class="line">  llvm::<span class="built_in">InitializeNativeTargetAsmPrinter</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An optimization pipeline to use within the execution engine.</span></span><br><span class="line">  <span class="keyword">auto</span> optPipeline = mlir::<span class="built_in">makeOptimizingTransformer</span>(</span><br><span class="line">      <span class="comment">/*optLevel=*/</span>EnableOpt ? <span class="number">3</span> : <span class="number">0</span>, <span class="comment">/*sizeLevel=*/</span><span class="number">0</span>,</span><br><span class="line">      <span class="comment">/*targetMachine=*/</span><span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an MLIR execution engine. The execution engine eagerly JIT-compiles</span></span><br><span class="line">  <span class="comment">// the module.</span></span><br><span class="line">  <span class="keyword">auto</span> maybeEngine = mlir::ExecutionEngine::<span class="built_in">create</span>(<span class="keyword">module</span>,</span><br><span class="line">      <span class="comment">/*llvmModuleBuilder=*/</span><span class="literal">nullptr</span>, optPipeline);</span><br><span class="line">  <span class="built_in">assert</span>(maybeEngine &amp;&amp; <span class="string">&quot;failed to construct an execution engine&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> &amp;engine = maybeEngine.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invoke the JIT-compiled function.</span></span><br><span class="line">  <span class="keyword">auto</span> invocationResult = engine-&gt;<span class="built_in">invoke</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (invocationResult) &#123;</span><br><span class="line">    llvm::<span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;JIT invocation failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Chap-7"><a href="#Chap-7" class="headerlink" title="Chap 7"></a>Chap 7</h1><p>本节讨论如何在MLIR中添加一个新的复合数据对象。</p>
<h2 id="Toy-lang中的语法"><a href="#Toy-lang中的语法" class="headerlink" title="Toy lang中的语法"></a>Toy lang中的语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># A struct is defined by using the `struct` keyword followed by a name.</span><br><span class="line">struct MyStruct &#123;</span><br><span class="line">  # Inside of the struct is a list of variable declarations without initializers</span><br><span class="line">  # or shapes, which may also be other previously defined structs.</span><br><span class="line">  var a;</span><br><span class="line">  var b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在MLIR中增加定义"><a href="#在MLIR中增加定义" class="headerlink" title="在MLIR中增加定义"></a>在MLIR中增加定义</h2><h3 id="定义type"><a href="#定义type" class="headerlink" title="定义type"></a>定义type</h3><h4 id="定义存储方式"><a href="#定义存储方式" class="headerlink" title="定义存储方式"></a>定义存储方式</h4><p>MLIR中的类型本质上是对 <code>TypeStorage</code> 对象的包装。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This class represents the internal storage of the Toy `StructType`.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StructTypeStorage</span> : <span class="keyword">public</span> mlir::TypeStorage &#123;</span><br><span class="line">  <span class="comment">/// The `KeyTy` is a required type that provides an interface for the storage</span></span><br><span class="line">  <span class="comment">/// instance. This type will be used when uniquing an instance of the type</span></span><br><span class="line">  <span class="comment">/// storage. For our struct type, we will unique each instance structurally on</span></span><br><span class="line">  <span class="comment">/// the elements that it contains.</span></span><br><span class="line">  <span class="keyword">using</span> KeyTy = llvm::ArrayRef&lt;mlir::Type&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// A constructor for the type storage instance.</span></span><br><span class="line">  <span class="built_in">StructTypeStorage</span>(llvm::ArrayRef&lt;mlir::Type&gt; elementTypes)</span><br><span class="line">      : <span class="built_in">elementTypes</span>(elementTypes) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Define the comparison function for the key type with the current storage</span></span><br><span class="line">  <span class="comment">/// instance. This is used when constructing a new instance to ensure that we</span></span><br><span class="line">  <span class="comment">/// haven&#x27;t already uniqued an instance of the given key.</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> KeyTy &amp;key) <span class="type">const</span> &#123; <span class="keyword">return</span> key == elementTypes; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Define a hash function for the key type. This is used when uniquing</span></span><br><span class="line">  <span class="comment">/// instances of the storage.</span></span><br><span class="line">  <span class="comment">/// Note: This method isn&#x27;t necessary as both llvm::ArrayRef and mlir::Type</span></span><br><span class="line">  <span class="comment">/// have hash functions available, so we could just omit this entirely.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> llvm::hash_code <span class="title">hashKey</span><span class="params">(<span class="type">const</span> KeyTy &amp;key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> llvm::<span class="built_in">hash_value</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Define a construction function for the key type from a set of parameters.</span></span><br><span class="line">  <span class="comment">/// These parameters will be provided when constructing the storage instance</span></span><br><span class="line">  <span class="comment">/// itself, see the `StructType::get` method further below.</span></span><br><span class="line">  <span class="comment">/// Note: This method isn&#x27;t necessary because KeyTy can be directly</span></span><br><span class="line">  <span class="comment">/// constructed with the given parameters.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> KeyTy <span class="title">getKey</span><span class="params">(llvm::ArrayRef&lt;mlir::Type&gt; elementTypes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">KeyTy</span>(elementTypes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Define a construction method for creating a new instance of this storage.</span></span><br><span class="line">  <span class="comment">/// This method takes an instance of a storage allocator, and an instance of a</span></span><br><span class="line">  <span class="comment">/// `KeyTy`. The given allocator must be used for *all* necessary dynamic</span></span><br><span class="line">  <span class="comment">/// allocations used to create the type storage and its internal.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> StructTypeStorage *<span class="title">construct</span><span class="params">(mlir::TypeStorageAllocator &amp;allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">const</span> KeyTy &amp;key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Copy the elements from the provided `KeyTy` into the allocator.</span></span><br><span class="line">    llvm::ArrayRef&lt;mlir::Type&gt; elementTypes = allocator.<span class="built_in">copyInto</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate the storage instance and construct it.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span> (allocator.<span class="built_in">allocate</span>&lt;StructTypeStorage&gt;())</span><br><span class="line">        <span class="built_in">StructTypeStorage</span>(elementTypes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The following field contains the element types of the struct.</span></span><br><span class="line">  llvm::ArrayRef&lt;mlir::Type&gt; elementTypes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h4><p>上述代码描述了类型该如何保存，而下面的定义才是真正用来交互的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This class defines the Toy struct type. It represents a collection of</span></span><br><span class="line"><span class="comment">/// element types. All derived types in MLIR must inherit from the CRTP class</span></span><br><span class="line"><span class="comment">/// &#x27;Type::TypeBase&#x27;. It takes as template parameters the concrete type</span></span><br><span class="line"><span class="comment">/// (StructType), the base class to use (Type), and the storage class</span></span><br><span class="line"><span class="comment">/// (StructTypeStorage).</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StructType</span> : <span class="keyword">public</span> mlir::Type::TypeBase&lt;StructType, mlir::Type,</span><br><span class="line">                                               StructTypeStorage&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// Inherit some necessary constructors from &#x27;TypeBase&#x27;.</span></span><br><span class="line">  <span class="keyword">using</span> Base::Base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Create an instance of a `StructType` with the given element types. There</span></span><br><span class="line">  <span class="comment">/// *must* be at least one element type.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> StructType <span class="title">get</span><span class="params">(llvm::ArrayRef&lt;mlir::Type&gt; elementTypes)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elementTypes.<span class="built_in">empty</span>() &amp;&amp; <span class="string">&quot;expected at least 1 element type&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call into a helper &#x27;get&#x27; method in &#x27;TypeBase&#x27; to get a uniqued instance</span></span><br><span class="line">    <span class="comment">// of this type. The first parameter is the context to unique in. The</span></span><br><span class="line">    <span class="comment">// parameters after are forwarded to the storage instance.</span></span><br><span class="line">    mlir::MLIRContext *ctx = elementTypes.<span class="built_in">front</span>().<span class="built_in">getContext</span>();</span><br><span class="line">    <span class="keyword">return</span> Base::<span class="built_in">get</span>(ctx, elementTypes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Returns the element types of this struct type.</span></span><br><span class="line">  <span class="function">llvm::ArrayRef&lt;mlir::Type&gt; <span class="title">getElementTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &#x27;getImpl&#x27; returns a pointer to the internal storage instance.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getImpl</span>()-&gt;elementTypes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Returns the number of element type held by this struct.</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">getNumElementTypes</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getElementTypes</span>().<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>向toy dialect注册该类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyDialect::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">addTypes</span>&lt;StructType&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="暴露在ODS中"><a href="#暴露在ODS中" class="headerlink" title="暴露在ODS中"></a>暴露在ODS中</h3><p>使用ODS添加相关定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Provide a definition for the Toy StructType for use in ODS. This allows for</span><br><span class="line">// using StructType in a similar way to Tensor or MemRef. We use `DialectType`</span><br><span class="line">// to demarcate the StructType as belonging to the Toy dialect.</span><br><span class="line">def Toy_StructType :</span><br><span class="line">    DialectType&lt;Toy_Dialect, CPred&lt;&quot;$_self.isa&lt;StructType&gt;()&quot;&gt;,</span><br><span class="line">                &quot;Toy struct type&quot;&gt;;</span><br><span class="line"></span><br><span class="line">// Provide a definition of the types that are used within the Toy dialect.</span><br><span class="line">def Toy_Type : AnyTypeOf&lt;[F64Tensor, Toy_StructType]&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="定义解析方式"><a href="#定义解析方式" class="headerlink" title="定义解析方式"></a>定义解析方式</h3><p>为了解析 <code>StructType</code>，需要在 <code>ToyDialect</code> 中添加解析方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ToyDialect</span> : <span class="keyword">public</span> mlir::Dialect &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// Parse an instance of a type registered to the toy dialect.</span></span><br><span class="line">  <span class="function">mlir::Type <span class="title">parseType</span><span class="params">(mlir::DialectAsmParser &amp;parser)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Print an instance of a type registered to the toy dialect.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printType</span><span class="params">(mlir::Type type,</span></span></span><br><span class="line"><span class="params"><span class="function">                 mlir::DialectAsmPrinter &amp;printer)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在实现上，我们需要给出正式的ODS语法：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct-type ::= `struct` `&lt;` type (`,` type)* `&gt;`</span><br></pre></td></tr></table></figure>

<p>根据语法实现parser和printer：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Parse an instance of a type registered to the toy dialect.</span></span><br><span class="line"><span class="function">mlir::Type <span class="title">ToyDialect::parseType</span><span class="params">(mlir::DialectAsmParser &amp;parser)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Parse a struct type in the following form:</span></span><br><span class="line">  <span class="comment">//   struct-type ::= `struct` `&lt;` type (`,` type)* `&gt;`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> All MLIR parser function return a ParseResult. This is a</span></span><br><span class="line">  <span class="comment">// specialization of LogicalResult that auto-converts to a `true` boolean</span></span><br><span class="line">  <span class="comment">// value on failure to allow for chaining, but may be used with explicit</span></span><br><span class="line">  <span class="comment">// `mlir::failed/mlir::succeeded` as desired.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse: `struct` `&lt;`</span></span><br><span class="line">  <span class="keyword">if</span> (parser.<span class="built_in">parseKeyword</span>(<span class="string">&quot;struct&quot;</span>) || parser.<span class="built_in">parseLess</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Type</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the element types of the struct.</span></span><br><span class="line">  SmallVector&lt;mlir::Type, <span class="number">1</span>&gt; elementTypes;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// Parse the current element type.</span></span><br><span class="line">    SMLoc typeLoc = parser.<span class="built_in">getCurrentLocation</span>();</span><br><span class="line">    mlir::Type elementType;</span><br><span class="line">    <span class="keyword">if</span> (parser.<span class="built_in">parseType</span>(elementType))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the type is either a TensorType or another StructType.</span></span><br><span class="line">    <span class="keyword">if</span> (!elementType.<span class="built_in">isa</span>&lt;mlir::TensorType, StructType&gt;()) &#123;</span><br><span class="line">      parser.<span class="built_in">emitError</span>(typeLoc, <span class="string">&quot;element type for a struct must either &quot;</span></span><br><span class="line">                                <span class="string">&quot;be a TensorType or a StructType, got: &quot;</span>)</span><br><span class="line">          &lt;&lt; elementType;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    elementTypes.<span class="built_in">push_back</span>(elementType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the optional: `,`</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">succeeded</span>(parser.<span class="built_in">parseOptionalComma</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse: `&gt;`</span></span><br><span class="line">  <span class="keyword">if</span> (parser.<span class="built_in">parseGreater</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Type</span>();</span><br><span class="line">  <span class="keyword">return</span> StructType::<span class="built_in">get</span>(elementTypes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Print an instance of a type registered to the toy dialect.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyDialect::printType</span><span class="params">(mlir::Type type,</span></span></span><br><span class="line"><span class="params"><span class="function">                           mlir::DialectAsmPrinter &amp;printer)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Currently the only toy type is a struct type.</span></span><br><span class="line">  StructType structType = type.<span class="built_in">cast</span>&lt;StructType&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print the struct type according to the parser format.</span></span><br><span class="line">  printer &lt;&lt; <span class="string">&quot;struct&lt;&quot;</span>;</span><br><span class="line">  llvm::<span class="built_in">interleaveComma</span>(structType.<span class="built_in">getElementTypes</span>(), printer);</span><br><span class="line">  printer &lt;&lt; <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加使用-StructType-的Op"><a href="#添加使用-StructType-的Op" class="headerlink" title="添加使用 StructType 的Op"></a>添加使用 <code>StructType</code> 的Op</h2><h3 id="更新既有的Op"><a href="#更新既有的Op" class="headerlink" title="更新既有的Op"></a>更新既有的Op</h3><p>如 <code>ReterunOp</code> 需要添加对 <code>StructType</code> 的支持：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def ReturnOp : Toy_Op&lt;&quot;return&quot;, [Terminator, HasParent&lt;&quot;FuncOp&quot;&gt;]&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  let arguments = (ins Variadic&lt;Toy_Type&gt;:$input);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现新的Op"><a href="#实现新的Op" class="headerlink" title="实现新的Op"></a>实现新的Op</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%0 = toy.struct_constant [</span><br><span class="line">  dense&lt;[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]&gt; : tensor&lt;2x3xf64&gt;</span><br><span class="line">] : !toy.struct&lt;tensor&lt;*xf64&gt;&gt;</span><br><span class="line"></span><br><span class="line">%1 = toy.struct_access %0[0] : !toy.struct&lt;tensor&lt;*xf64&gt;&gt; -&gt; tensor&lt;*xf64&gt;</span><br></pre></td></tr></table></figure>

</div><div class="article-licensing box"><div class="licensing-title"><p>MLIR Toy Tutorial</p><p><a href="http://example.com/2024/01/04/MLIR/2_Toy-tutorial/">http://example.com/2024/01/04/MLIR/2_Toy-tutorial/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ReRoozen</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-01-04</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-03-01</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/01/10/MLIR/3_ODS/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MLIR ODS</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/01/03/MLIR/999_%E6%9D%82%E8%B0%88/"><span class="level-item">MLIR杂谈</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/gallery/head-portrial.jpg" alt="ReRoozen"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ReRoozen</p><p class="is-size-6 is-block">I need more power!!!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Within Heaven and Hell</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Benchmarks/"><span class="level-start"><span class="level-item">Benchmarks</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CMAKE/"><span class="level-start"><span class="level-item">CMAKE</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Patterns-in-CPP/"><span class="level-start"><span class="level-item">Design Patterns in CPP</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/LLVM/"><span class="level-start"><span class="level-item">LLVM</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/LLVM-Meetings/"><span class="level-start"><span class="level-item">LLVM Meetings</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/MLIR/"><span class="level-start"><span class="level-item">MLIR</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Modern-CPP/"><span class="level-start"><span class="level-item">Modern CPP</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/PFPL/"><span class="level-start"><span class="level-item">PFPL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Performance-Profiling/"><span class="level-start"><span class="level-item">Performance Profiling</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Polyhedral/"><span class="level-start"><span class="level-item">Polyhedral</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Writing/"><span class="level-start"><span class="level-item">Writing</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/vim/"><span class="level-start"><span class="level-item">vim</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-16T05:24:08.000Z">2024-04-16</time></p><p class="title"><a href="/2024/04/16/PerformanceMeasuring/02-MemoryHierarchical/">02-Measuring Memory Hierarchy</a></p><p class="categories"><a href="/categories/Performance-Profiling/">Performance Profiling</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-16T01:48:32.000Z">2024-04-16</time></p><p class="title"><a href="/2024/04/16/PerformanceMeasuring/01-CPU/">01-Measuring CPU Time</a></p><p class="categories"><a href="/categories/Performance-Profiling/">Performance Profiling</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-06T10:34:12.000Z">2024-04-06</time></p><p class="title"><a href="/2024/04/06/DesingnPatterns/1-CreationalPattern/">1-CreationalPattern</a></p><p class="categories"><a href="/categories/Design-Patterns-in-CPP/">Design Patterns in CPP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-05T12:19:36.000Z">2024-04-05</time></p><p class="title"><a href="/2024/04/05/DesingnPatterns/0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/">Prequest knowledge</a></p><p class="categories"><a href="/categories/Design-Patterns-in-CPP/">Design Patterns in CPP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-03T08:03:39.000Z">2024-04-03</time></p><p class="title"><a href="/2024/04/03/CPPTemplate/9-Require%E5%92%8Cconcept/">9-Require and concept</a></p><p class="categories"><a href="/categories/Modern-CPP/">Modern CPP</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">八月 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="ReRoozen&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 ReRoozen</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2024</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>