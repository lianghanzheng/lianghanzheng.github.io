<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: MLIR - ReRoozen&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ReRoozen&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ReRoozen&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="ReRoozen&#039;s Blog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="ReRoozen&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="ReRoozen"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"ReRoozen's Blog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"ReRoozen"},"publisher":{"@type":"Organization","name":"ReRoozen's Blog","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="ReRoozen&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">MLIR</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-25T07:02:18.000Z" title="2024/3/25 15:02:18">2024-03-25</time>发表</span><span class="level-item"><time dateTime="2024-04-16T14:06:30.618Z" title="2024/4/16 22:06:30">2024-04-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/MLIR/">MLIR</a></span><span class="level-item">3 分钟读完 (大约409个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/25/MLIR/APP-A%20CommonDialects/">CommonDialects</a></p><div class="content"><h1 id="scf-dialect"><a href="#scf-dialect" class="headerlink" title="scf dialect"></a>scf dialect</h1><p>scf方言中的Op能够用来表征任意的代码块结构。</p>
<h2 id="ConditionOp"><a href="#ConditionOp" class="headerlink" title="ConditionOp"></a>ConditionOp</h2><h2 id="IfOp"><a href="#IfOp" class="headerlink" title="IfOp"></a>IfOp</h2><p>Example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%x, %y = scf.if %b -&gt; (f32, f32) &#123;</span><br><span class="line">  %x_true = ...</span><br><span class="line">  %y_true = ...</span><br><span class="line">  scf.yield %x_true, %y_true : f32, f32</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  %x_false = ...</span><br><span class="line">  %y_false = ...</span><br><span class="line">  scf.yield %x_false, %y_false : f32, f32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于传统的数据流分析，<code>scf.if</code> 能够指定哪些变量在出口处活跃。</p>
<p><code>scf.yeild</code> 表示一个控制块的结束，如果 <code>scf.if</code> 没有返回值，那么它能够被省略，被隐式地插入在代码中。</p>
<p>如果 <code>if</code> 语句中存在逻辑表达式的计算，那么会额外引入一个 <code>scf.if</code> 结构计算这个逻辑表达式的值，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isCoordChanged || iter == <span class="number">0</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%75 = scf.if %42 -&gt; (i1) &#123;</span><br><span class="line">  scf.yield %true : i1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  %209 = memref.load %37[%c0] : memref&lt;1xi32&gt;</span><br><span class="line">  %210 = arith.cmpi eq, %209, %c0_i32 : i32</span><br><span class="line">  scf.yield %210 : i1</span><br><span class="line">&#125;</span><br><span class="line">scf.if %75 &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="memref-dialect"><a href="#memref-dialect" class="headerlink" title="memref dialect"></a>memref dialect</h1><h2 id="GetGlobalOp"><a href="#GetGlobalOp" class="headerlink" title="GetGlobalOp"></a>GetGlobalOp</h2><p>获得一个全局变量的指针。</p>
<h1 id="llvm-dialect"><a href="#llvm-dialect" class="headerlink" title="llvm dialect"></a>llvm dialect</h1><h2 id="GEPOp-getelementptr"><a href="#GEPOp-getelementptr" class="headerlink" title="GEPOp (getelementptr)"></a>GEPOp (getelementptr)</h2><p>相当于从LLVM IR中的 <code>getelementptr</code> 指令，根据偏移量从计算结构体中元素的地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123; <span class="type">long</span> num; <span class="type">int</span> dim; Point *p; &#125; Point *points;</span><br><span class="line"><span class="type">int</span> num	=  points-&gt;num;				<span class="comment">// number of points</span></span><br><span class="line"><span class="type">int</span> dim	=  points-&gt;dim;				<span class="comment">// number of dimension</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%24 = llvm.getelementptr %arg1[%c0_i32, 0] : (!llvm.ptr&lt;!llvm.struct&lt;(i64, i32, !llvm.ptr&lt;!llvm.struct&lt;(f32, memref&lt;?xf32&gt;, i64, f32)&gt;&gt;)&gt;&gt;, i32) -&gt; !llvm.ptr&lt;i64&gt;</span><br><span class="line">%25 = llvm.load %24 : !llvm.ptr&lt;i64&gt;</span><br><span class="line">%26 = arith.trunci %25 : i64 to i32</span><br><span class="line">%27 = llvm.getelementptr %arg1[%c0_i32, 1] : (!llvm.ptr&lt;!llvm.struct&lt;(i64, i32, !llvm.ptr&lt;!llvm.struct&lt;(f32, memref&lt;?xf32&gt;, i64, f32)&gt;&gt;)&gt;&gt;, i32) -&gt; !llvm.ptr&lt;i32&gt;</span><br><span class="line">%28 = llvm.load %27 : !llvm.ptr&lt;i32&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg1</code> 是一个结构体</li>
<li><code>%c0_i32</code> 是一个32位类型的常量0，表示以结构体大小为基准的偏移量</li>
<li><code>0</code> 是结构体内的偏移量，表示结构体内的第一个元素</li>
<li>GEPOp只计算地址，所以要 <code>load</code> 以下</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-11T08:24:12.000Z" title="2024/1/11 16:24:12">2024-01-11</time>发表</span><span class="level-item"><time dateTime="2024-03-01T07:13:23.261Z" title="2024/3/1 15:13:23">2024-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/MLIR/">MLIR</a></span><span class="level-item">7 分钟读完 (大约1085个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/11/MLIR/4_Toy%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/">MLIR Toy Code Reading</a></p><div class="content"><h1 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h1><p>直接看完了toy tutorial和ODS文档感觉还是有很多东西都似是而非，还是需要回到具体的代码中才能把相关的概念全都搞懂。</p>
<h1 id="Chap2"><a href="#Chap2" class="headerlink" title="Chap2"></a>Chap2</h1><p><code>$INSTALL_PATH/examples/toyc-ch2</code> 的功能显然比 <code>toyc-ch1</code> 功能更多，能够把AST转换为mlir代码。两个代码的目录树分别如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ch1</span></span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── toy</span><br><span class="line">│       ├── AST.h</span><br><span class="line">│       ├── Lexer.h</span><br><span class="line">│       └── Parser.h</span><br><span class="line">├── parser</span><br><span class="line">│   └── AST.cpp</span><br><span class="line">└── toyc.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># ch2</span></span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── toy</span><br><span class="line">│       ├── AST.h</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">│       ├── Dialect.h</span><br><span class="line">│       ├── Lexer.h</span><br><span class="line">│       ├── MLIRGen.h</span><br><span class="line">│       ├── Ops.td</span><br><span class="line">│       └── Parser.h</span><br><span class="line">├── mlir</span><br><span class="line">│   ├── Dialect.cpp</span><br><span class="line">│   └── MLIRGen.cpp</span><br><span class="line">├── parser</span><br><span class="line">│   └── AST.cpp</span><br><span class="line">└── toyc.cpp</span><br></pre></td></tr></table></figure>

<h2 id="CMake配置注意事项"><a href="#CMake配置注意事项" class="headerlink" title="CMake配置注意事项"></a>CMake配置注意事项</h2><ul>
<li>TODO: 设置编译器为clang时，编译选项 <code>-fno-lifetime-dse</code> 会产生冲突</li>
<li>rtti特性会导致链接出错，需要加上 <code>-fno-rtti</code></li>
</ul>
<h2 id="toyc-cpp"><a href="#toyc-cpp" class="headerlink" title="toyc.cpp"></a><code>toyc.cpp</code></h2><p>Toy lang编译器的驱动。<br>使用LLVM命令行工具做了一堆防止点炒饭的代码，有价值的部分就是函数 <code>dumpMLIR</code>。<br>该函数首先调用 <code>parseInputFile</code> 将toy lang的最上层结构——Moudle——解析，并以AST的形式 <code>std::unique_ptr&lt;MouduleAST&gt;</code> 传回，得到一个可用于后续工作的AST。<br>MLIR的生成交给 <code>mlirGen</code> 函数完成，定义在 <code>toy/MLIR/MLIRGen.cpp</code> 中。</p>
<h2 id="MLITGen-cpp"><a href="#MLITGen-cpp" class="headerlink" title="MLITGen.cpp"></a><code>MLITGen.cpp</code></h2><p>实现代码转换的功能模块叫做 <code>MLIRGenImpl</code>，其方法 <code>mlirGen</code> 负责将AST转换为mlir。<br>从中可以看出，MLIR最高级的结构由 <code>ModuleOp</code> 表示，开辟了全局的region。</p>
<p>之后的过程就是不断遍历AST然后递归地调用 <code>mlirGen</code> 的不同重载来填充 <code>ModuleOp</code>。<br>最后回到 <code>toyc.cpp</code> 中的函数 <code>dumpMLIR</code>，使用 <code>ModuleOp::dump</code> 方法打印我们得到的MLIR。</p>
<blockquote>
<p>在打印MLIR代码这件事情上，还可以用 <code>MLIRContext::print</code> 来达到一样的目的。</p>
</blockquote>
<h2 id="核心文件"><a href="#核心文件" class="headerlink" title="核心文件"></a>核心文件</h2><ul>
<li><code>Ops.td</code></li>
<li><code>Dialect.cpp</code></li>
</ul>
<h2 id="从tablegen到CPP"><a href="#从tablegen到CPP" class="headerlink" title="从tablegen到CPP"></a>从tablegen到CPP</h2><p>从之前的教程能够看出，从 <code>Ops.td</code> 到CPP接口需要分别生成dialect和Op的相关文件。<br>根据 <code>$BUILD_PATH/tools/mlir/examples/toy/Ch2/include/toy</code> 中的内容可以推导出相关命名规则如下：</p>
<ul>
<li>在项目的include目录下创建存放dialect的目录，命名为dialect的名字</li>
<li><code>-gen-dialect-decls</code> 生成的文件命名为 <code>Dialect.h.inc</code></li>
<li><code>-gen-dialect-defs</code> 生成的文件命名为 <code>Dialect.cpp.inc</code></li>
<li><code>-gen-op-decls</code> 生成的文件命名为 <code>Ops.h.inc</code></li>
<li><code>-gen-op-defs</code> 生成的文件命名为 <code>Ops.cpp.inc</code></li>
<li>相关文件的生成都写在了 <code>CMakeLists.txt</code></li>
</ul>
<h2 id="Ops-td"><a href="#Ops-td" class="headerlink" title="Ops.td"></a><code>Ops.td</code></h2><h3 id="builder"><a href="#builder" class="headerlink" title="builder"></a>builder</h3><p>即使不填充相关filed，编译器也会自动生成三个builder，包括函数签名和实现。</p>
<p>Builder的定义可以只跟一个定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpBuilder&lt;(ins &quot;double&quot;:$value)&gt;</span><br></pre></td></tr></table></figure>

<p>其对应的函数签名如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(::mlir::OpBuilder &amp;odsBuilder, ::mlir::OperationState &amp;odsState, <span class="type">double</span> value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>具体的实现需要自己去填补。</p>
<p>但是当builder足够简单时，也可以把实现写入tablegen中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OpBuilder&lt;(ins &quot;DenseElementsAttr&quot;:$value), [&#123;</span><br><span class="line">      build($_builder, $_state, value.getType(), value);</span><br><span class="line">    &#125;]&gt;,</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[&#123;...&#125;]</code> 中的内容为C++代码，用来描述比较简单的builder的定义</li>
</ul>
<p>其对应函数签名和实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConstantOp::build</span><span class="params">(::mlir::OpBuilder &amp;odsBuilder, ::mlir::OperationState &amp;odsState, DenseElementsAttr value)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">build</span>(odsBuilder, odsState, value.<span class="built_in">getType</span>(), value);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Builder实现中的一些困惑事项"><a href="#Builder实现中的一些困惑事项" class="headerlink" title="Builder实现中的一些困惑事项"></a>Builder实现中的一些困惑事项</h4><ul>
<li><code>ParseResult</code> 会将 <code>LogicalResult</code> 的值反转，目的是让语法解析像BNF那样用 <code>||</code> 连接<ul>
<li>Each of these methods returns a <code>ParseResult</code>. This class is a wrapper around <code>LogicalResult</code> that can be converted to a boolean <code>true</code> value on failure, or <code>false</code> on success.</li>
</ul>
</li>
<li><code>verify</code> 中仍然使用原本的 <code>LogicalResult</code></li>
</ul>
<h1 id="Chap-3"><a href="#Chap-3" class="headerlink" title="Chap 3"></a>Chap 3</h1><p>本章节的核心内容为：</p>
<ul>
<li><code>ToyCombine.cpp</code></li>
<li><code>ToyCombine.td</code></li>
</ul>
<p>以及在驱动 <code>toyc.cpp</code> 中使用passmanager对实现优化遍进行了注册。</p>
<h2 id="代码变换的基本形式"><a href="#代码变换的基本形式" class="headerlink" title="代码变换的基本形式"></a>代码变换的基本形式</h2><p>Tablegen中进行代码变换需要使用 <code>Pat</code> 进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Reshape(Reshape(x)) = Reshape(x)</span><br><span class="line">def ReshapeReshapeOptPattern : Pat&lt;(ReshapeOp(ReshapeOp $arg)),</span><br><span class="line">                                   (ReshapeOp $arg)&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="NativeCodeCall"><a href="#NativeCodeCall" class="headerlink" title="NativeCodeCall"></a><code>NativeCodeCall</code></h2><p>在代码转换的过程中需要使用C++辅助函数时需要以 <code>NativeCodeCall</code> 描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Reshape(Constant(x)) = x&#x27;</span><br><span class="line">def ReshapeConstant :</span><br><span class="line">  NativeCodeCall&lt;&quot;$0.reshape(::llvm::cast&lt;ShapedType&gt;($1.getType()))&quot;&gt;;</span><br><span class="line">def FoldConstantReshapeOptPattern : Pat&lt;</span><br><span class="line">  (ReshapeOp:$res (ConstantOp $arg)),</span><br><span class="line">  (ConstantOp (ReshapeConstant $arg, $res))&gt;;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-10T08:53:57.000Z" title="2024/1/10 16:53:57">2024-01-10</time>发表</span><span class="level-item"><time dateTime="2024-03-01T07:13:23.260Z" title="2024/3/1 15:13:23">2024-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/MLIR/">MLIR</a></span><span class="level-item">16 分钟读完 (大约2361个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/10/MLIR/3_ODS/">MLIR ODS</a></p><div class="content"><h1 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h1><p>最终第二章还是变成了对文档的简单总结，不过完全把细节完全展开还是太离谱了。<br>本章重点对MLIR ODS进行学习，因为该框架在Op定义上十分重要，所有的custom Op都是以ODS的语法给出的。</p>
<h1 id="Tablegen语法"><a href="#Tablegen语法" class="headerlink" title="Tablegen语法"></a>Tablegen语法</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>Tablgen本身是用来写record的。<br>在这个基础上，record又分为abstract record和concrete record两类。</p>
<ul>
<li>Abstract record：被称为class</li>
<li>Concrete record：被称为record</li>
</ul>
<p>Class和record都有专有的名字，可以由程序员或者tablegen给出。<br>每个名字都会和一组有值的field相关联。<br>Field的具体含义并不由tablegen语法决定，而是由后端决定。</p>
<p>Class通常用来描述一个record的模板，并且能够进行派生；record向class传入参数来填充不同的filed。<br>未初始化的field的值以 <code>?</code> 表示。因此class的field的值通常都是 <code>?</code> 而record的field大多被初始化了。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><ul>
<li>注释： <ul>
<li><code>//</code></li>
<li><code>/*...*/</code></li>
</ul>
</li>
<li>字面量：<ul>
<li>二进制&#x2F;十进制&#x2F;十六进制数</li>
<li>字符串：由双引号 <code>&quot;</code> 包围（单行字符串）或者由 <code>[&#123;...&#125;]</code>  包围（多行）</li>
</ul>
</li>
<li>标识符<ul>
<li>变量名以 <code>$</code> 开头</li>
<li>不能使用关键字作为标识符</li>
</ul>
</li>
<li>惊叹号运算符 (bang operator)<ul>
<li>以 <code>!</code> 为开头，如 <code>!add</code>, <code>!isa</code>, …</li>
</ul>
</li>
<li>文件引用<ul>
<li><code>include ...</code></li>
<li>定义文件 <code>#define</code>, <code>#ifdef</code>, <code>#ifndef</code></li>
</ul>
</li>
</ul>
<p>关键字如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assert     bit           bits          class         code</span><br><span class="line">dag        def           dump          else          false</span><br><span class="line">foreach    defm          defset        defvar        field</span><br><span class="line">if         in            include       int           let</span><br><span class="line">list       multiclass    string        then          true</span><br></pre></td></tr></table></figure>

<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><ul>
<li><code>bit</code></li>
<li><code>int</code></li>
<li>字符串</li>
<li><code>bits&lt;N&gt;</code></li>
<li><code>list&lt;type&gt;</code></li>
<li>ClassID<ul>
<li>比如定义一个class <code>Register</code>，那么有 <code>list&lt;Register&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="值和表达式"><a href="#值和表达式" class="headerlink" title="值和表达式"></a>值和表达式</h2><ul>
<li>字面量</li>
<li>布尔值</li>
<li>未知值 <code>?</code></li>
<li>多位bit<ul>
<li><code>&#123;1, 0, 1&#125;</code></li>
<li><code>1, 0, 1</code></li>
</ul>
</li>
<li>list initializer<ul>
<li><code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></li>
<li>类型说明可选 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] &lt;string&gt;</code></li>
</ul>
</li>
<li>DAG initializer</li>
<li>标识符</li>
<li>匿名record：给定class和参数列表<ul>
<li><code>ClassID&lt;ArgList&gt;</code></li>
</ul>
</li>
<li>运算符</li>
</ul>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="class-定义抽象record"><a href="#class-定义抽象record" class="headerlink" title="class 定义抽象record"></a><code>class</code> 定义抽象record</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  bit V = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def X : C;</span><br><span class="line">def Y : C &#123;</span><br><span class="line">  let V = false;</span><br><span class="line">  string Greeting = &quot;Hello!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="def-定义具体record"><a href="#def-定义具体record" class="headerlink" title="def 定义具体record"></a><code>def</code> 定义具体record</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class FPFormat &lt;bits&lt;3&gt; val&gt; &#123;</span><br><span class="line">  bits&lt;3&gt; Value = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def NotFP      : FPFormat&lt;0&gt;;</span><br><span class="line">def ZeroArgFP  : FPFormat&lt;1&gt;;</span><br><span class="line">def OneArgFP   : FPFormat&lt;2&gt;;</span><br><span class="line">def OneArgFPRW : FPFormat&lt;3&gt;;</span><br><span class="line">def TwoArgFP   : FPFormat&lt;4&gt;;</span><br><span class="line">def CompareFP  : FPFormat&lt;5&gt;;</span><br><span class="line">def CondMovFP  : FPFormat&lt;6&gt;;</span><br><span class="line">def SpecialFP  : FPFormat&lt;7&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="let-覆写class或者record中的field"><a href="#let-覆写class或者record中的field" class="headerlink" title="let 覆写class或者record中的field"></a><code>let</code> 覆写class或者record中的field</h3><blockquote>
<p>TODO: 先写了点常见的，不够再补。</p>
</blockquote>
<h1 id="定义Op"><a href="#定义Op" class="headerlink" title="定义Op"></a>定义Op</h1><p>定义Op所需要的class都定义在 <code>$LLVM_ROOT/mlir/include/mlir/IR/OpBase.td</code> 中：</p>
<ul>
<li><code>Op</code> class：新的Op的定义都是从这个class中派生</li>
<li><code>Dialect</code> class</li>
<li><code>OpTrait</code> class</li>
<li><code>ins</code>&#x2F;<code>outs</code> marker：由后端定义的特别符号，用来引导操作数和结果的定义</li>
<li><code>TypeConstraint</code> class：<code>Type</code> 是它的subclass</li>
<li><code>AttrConstraint</code> class：<code>Attr</code> 是它的subclass</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def TF_AvgPoolOp : TF_Op&lt;&quot;AvgPool&quot;, [NoMemoryEffect]&gt; &#123;</span><br><span class="line">  let summary = &quot;Performs average pooling on the input.&quot;;</span><br><span class="line"></span><br><span class="line">  let description = [&#123;</span><br><span class="line">Each entry in `output` is the mean of the corresponding size `ksize`</span><br><span class="line">window in `value`.</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  let arguments = (ins</span><br><span class="line">    TF_FpTensor:$value,</span><br><span class="line"></span><br><span class="line">    ConfinedAttr&lt;I64ArrayAttr, [ArrayMinCount&lt;4&gt;]&gt;:$ksize,</span><br><span class="line">    ConfinedAttr&lt;I64ArrayAttr, [ArrayMinCount&lt;4&gt;]&gt;:$strides,</span><br><span class="line">    TF_AnyStrAttrOf&lt;[&quot;SAME&quot;, &quot;VALID&quot;]&gt;:$padding,</span><br><span class="line">    DefaultValuedAttr&lt;TF_ConvertDataFormatAttr, &quot;NHWC&quot;&gt;:$data_format</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  let results = (outs</span><br><span class="line">    TF_FpTensor:$output</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  TF_DerivedOperandTypeAttr T = TF_DerivedOperandTypeAttr&lt;0&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各个field含义如下：</p>
<ul>
<li>Op名称：<code>TF_AvgPoolOp</code></li>
<li>文档信息：<code>summary</code>, <code>description</code></li>
<li>参数：<code>arguments</code><ul>
<li>operation：其它Op传过来的result</li>
<li>attribute：编译时已知的常量<ul>
<li>Natural attribute：影响Op的行为</li>
<li>Derived attribute：由Op内信息推断得到</li>
</ul>
</li>
<li>是DAG类型TableGen参数，以 <code>ins</code> 开始，后续为 <code>&lt;type-constraint&gt;:$&lt;operand-name&gt;</code> 或者 <code>&lt;attr-constraint&gt;:$&lt;attr-name&gt;</code></li>
<li>operation和attribute的顺序在 <code>arguments</code> 中没有限制</li>
</ul>
</li>
<li>结果：<code>result</code><ul>
<li>特指在这个Op作为出边的值</li>
<li>是DAG类型TableGen参数，以 <code>outs</code> 开始，后续为 <code>&lt;type-constraint&gt;:$&lt;result-name&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="其它field"><a href="#其它field" class="headerlink" title="其它field"></a>其它field</h2><h3 id="可变参数-variadic-operands"><a href="#可变参数-variadic-operands" class="headerlink" title="可变参数 (variadic operands)"></a>可变参数 (variadic operands)</h3><p>语法为 <code>Variadic&lt;...&gt;</code>。</p>
<h3 id="可选参数-optional-operands"><a href="#可选参数-optional-operands" class="headerlink" title="可选参数 (optional operands)"></a>可选参数 (optional operands)</h3><p>语法为 <code>Optional&lt;...&gt;</code>。</p>
<h3 id="可选attribute"><a href="#可选attribute" class="headerlink" title="可选attribute"></a>可选attribute</h3><p>语法为 <code>OptionalAttr&lt;...&gt;</code>。</p>
<h3 id="约束attribute"><a href="#约束attribute" class="headerlink" title="约束attribute"></a>约束attribute</h3><p>添加约束条件，如 <code>ConfinedAttr&lt;I32Attr, [IntMinValue&lt;10&gt;]&gt;</code>。</p>
<ul>
<li><code>IntMinValue&lt;N&gt;</code>: Specifying an integer attribute to be greater than or equal to N</li>
<li><code>IntMaxValue&lt;N&gt;</code>: Specifying an integer attribute to be less than or equal to N</li>
<li><code>ArrayMinCount&lt;N&gt;</code>: Specifying an array attribute to have at least N elements</li>
<li><code>IntArrayNthElemEq&lt;I, N&gt;</code>: Specifying an integer array attribute’s I-th element to be equal to N</li>
<li><code>IntArrayNthElemMinValue&lt;I, N&gt;</code>: Specifying an integer array attribute’s I-th element to be greater than or equal to N</li>
<li><code>IntArrayNthElemMaxValue&lt;I, N&gt;</code>: Specifying an integer array attribute’s I-th element to be less than or equal to N</li>
<li><code>IntArrayNthElemInRange&lt;I, M, N&gt;</code>: Specifying an integer array attribute’s I-th element to be greater than or equal to M and less than or equal to N</li>
</ul>
<h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><p>由 <code>region</code> 引导的dag数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let regions = (region</span><br><span class="line">  &lt;region-constraint&gt;:$&lt;region-name&gt;,</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="Op-successor"><a href="#Op-successor" class="headerlink" title="Op successor"></a>Op successor</h3><p>由 <code>successor</code> 引导的dag数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let successors = (successor</span><br><span class="line">  &lt;successor-constraint&gt;:$&lt;successor-name&gt;,</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="Op-trait-Op-constraints"><a href="#Op-trait-Op-constraints" class="headerlink" title="Op trait &amp; Op constraints"></a>Op trait &amp; Op constraints</h3><p>Trait和constraint都是作为Op class的参数传入。</p>
<h3 id="Builder-method"><a href="#Builder-method" class="headerlink" title="Builder method"></a>Builder method</h3><p>ODS能够根据参数和返回类型生成基础的builder：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def MyOp : ... &#123;</span><br><span class="line">  let arguments = (ins</span><br><span class="line">    I32:$i32_operand,</span><br><span class="line">    F32:$f32_operand,</span><br><span class="line">    ...,</span><br><span class="line"></span><br><span class="line">    I32Attr:$i32_attr,</span><br><span class="line">    F32Attr:$f32_attr,</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  let results = (outs</span><br><span class="line">    I32:$i32_result,</span><br><span class="line">    F32:$f32_result,</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会生成如下的函数签名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All result-types/operands/attributes have one aggregate parameter.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(OpBuilder &amp;odsBuilder, OperationState &amp;odsState,</span></span></span><br><span class="line"><span class="params"><span class="function">                  TypeRange resultTypes,</span></span></span><br><span class="line"><span class="params"><span class="function">                  ValueRange operands,</span></span></span><br><span class="line"><span class="params"><span class="function">                  ArrayRef&lt;NamedAttribute&gt; attributes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each result-type/operand/attribute has a separate parameter. The parameters</span></span><br><span class="line"><span class="comment">// for attributes are of mlir::Attribute types.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(OpBuilder &amp;odsBuilder, OperationState &amp;odsState,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Type i32_result, Type f32_result, ...,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Value i32_operand, Value f32_operand, ...,</span></span></span><br><span class="line"><span class="params"><span class="function">                  IntegerAttr i32_attr, FloatAttr f32_attr, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each result-type/operand/attribute has a separate parameter. The parameters</span></span><br><span class="line"><span class="comment">// for attributes are raw values unwrapped with mlir::Attribute instances.</span></span><br><span class="line"><span class="comment">// (Note that this builder will not always be generated. See the following</span></span><br><span class="line"><span class="comment">// explanation for more details.)</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(OpBuilder &amp;odsBuilder, OperationState &amp;odsState,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Type i32_result, Type f32_result, ...,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Value i32_operand, Value f32_operand, ...,</span></span></span><br><span class="line"><span class="params"><span class="function">                  APInt i32_attr, StringRef f32_attr, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each operand/attribute has a separate parameter but result type is aggregate.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(OpBuilder &amp;odsBuilder, OperationState &amp;odsState,</span></span></span><br><span class="line"><span class="params"><span class="function">                  TypeRange resultTypes,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Value i32_operand, Value f32_operand, ...,</span></span></span><br><span class="line"><span class="params"><span class="function">                  IntegerAttr i32_attr, FloatAttr f32_attr, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All operands/attributes have aggregate parameters.</span></span><br><span class="line"><span class="comment">// Generated if return type can be inferred.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(OpBuilder &amp;odsBuilder, OperationState &amp;odsState,</span></span></span><br><span class="line"><span class="params"><span class="function">                  ValueRange operands, ArrayRef&lt;NamedAttribute&gt; attributes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (And manually specified builders depending on the specific op.)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一个builder的函数签名是所有Op都相同的，供 <code>MLIRContext::create</code> 使用</li>
<li>第二个和第三个builder对于编写MLIR代码比较有用</li>
</ul>
<h4 id="自定义builder"><a href="#自定义builder" class="headerlink" title="自定义builder"></a>自定义builder</h4><p>如果上述的builder不能满足需求，则可以填充 <code>builders</code> field来添加定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def MyOp : Op&lt;&quot;my_op&quot;, []&gt; &#123;</span><br><span class="line">  let arguments = (ins F32Attr:$attr);</span><br><span class="line"></span><br><span class="line">  let builders = [</span><br><span class="line">    OpBuilder&lt;(ins &quot;float&quot;:$val)&gt;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该field会生成如下的函数签名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyOp</span> : <span class="comment">/*...*/</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(::mlir::OpBuilder &amp;builder, ::mlir::OperationState &amp;state,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">float</span> val)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ODS中也能直接描述builder的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def MyOp : Op&lt;&quot;my_op&quot;, []&gt; &#123;</span><br><span class="line">  let arguments = (ins F32Attr:$attr);</span><br><span class="line"></span><br><span class="line">  let builders = [</span><br><span class="line">    OpBuilder&lt;(ins &quot;float&quot;:$val), [&#123;</span><br><span class="line">      $_state.addAttribute(&quot;attr&quot;, $_builder.getF32FloatAttr(val));</span><br><span class="line">    &#125;]&gt;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$_builder</code> 和 <code>$_state</code> 是特殊变量，对应于C++形式中的 <code>builder</code> 和 <code>state</code></li>
<li>但只推荐在ODS中构建简单的builder，复杂的builder最好还是实现为C++</li>
</ul>
<p>为参数添加默认值需要使用 <code>CArg</code> 进行包装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def MyOp : Op&lt;&quot;my_op&quot;, []&gt; &#123;</span><br><span class="line">  let arguments = (ins F32Attr:$attr);</span><br><span class="line"></span><br><span class="line">  let builders = [</span><br><span class="line">    OpBuilder&lt;(ins CArg&lt;&quot;float&quot;, &quot;0.5f&quot;&gt;:$val), [&#123;</span><br><span class="line">      $_state.addAttribute(&quot;attr&quot;, $_builder.getF32FloatAttr(val));</span><br><span class="line">    &#125;]&gt;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的C++为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Header file.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyOp</span> : <span class="comment">/*...*/</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(::mlir::OpBuilder &amp;builder, ::mlir::OperationState &amp;state,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">float</span> val = <span class="number">0.5f</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Source file.</span></span><br><span class="line">MyOp::<span class="built_in">build</span>(::mlir::OpBuilder &amp;builder, ::mlir::OperationState &amp;state,</span><br><span class="line">            <span class="type">float</span> val) &#123;</span><br><span class="line">  state.<span class="built_in">addAttribute</span>(<span class="string">&quot;attr&quot;</span>, builder.<span class="built_in">getF32FloatAttr</span>(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Verifier"><a href="#Verifier" class="headerlink" title="Verifier"></a>Verifier</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let hasVerifier = 1;</span><br><span class="line">let hasRegionVerifier = 1; // for nested operation</span><br></pre></td></tr></table></figure>

<p>验证顺序：</p>
<ul>
<li>StructuralOp trait会被首先验证</li>
<li><code>verifyInvariants</code> 会验证type&#x2F;attribute</li>
<li>剩下的Trait和interface需要设置 <code>verifyTrait</code> 和 <code>verifyWithRegion</code> 进行验证</li>
<li>自定义的verifier</li>
</ul>
<h4 id="传递诊断信息"><a href="#传递诊断信息" class="headerlink" title="传递诊断信息"></a>传递诊断信息</h4><ul>
<li><code>Note</code></li>
<li><code>Remark</code></li>
<li><code>Warning</code></li>
<li><code>Error</code></li>
</ul>
<h2 id="Declarative-assembly-format"><a href="#Declarative-assembly-format" class="headerlink" title="Declarative assembly format"></a>Declarative assembly format</h2><p>通过使用ODS中预定义的和attribute等匹配的关键字来定义Op的文本形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def CallOp : Std_Op&lt;&quot;call&quot;, ...&gt; &#123;</span><br><span class="line">  let arguments = (ins FlatSymbolRefAttr:$callee, Variadic&lt;AnyType&gt;:$args);</span><br><span class="line">  let results = (outs Variadic&lt;AnyType&gt;);</span><br><span class="line"></span><br><span class="line">  let assemblyFormat = [&#123;</span><br><span class="line">    $callee `(` $args `)` attr-dict `:` functional-type($args, results)</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保留的diective含义如下：</p>
<ul>
<li><code>attr-dict</code><ul>
<li>Represents the attribute dictionary of the operation.</li>
</ul>
</li>
<li><code>attr-dict-with-keyword</code><ul>
<li>Represents the attribute dictionary of the operation, but prefixes the dictionary with an attributes keyword.</li>
</ul>
</li>
<li><code>custom</code> &lt; UserDirective &gt; ( Params )<ul>
<li>Represents a custom directive implemented by the user in C++.</li>
<li>See the Custom Directives section below for more details.</li>
</ul>
</li>
<li><code>functional-type</code> (inputs, outputs)<ul>
<li>Formats the inputs and outputs arguments as a function type.</li>
<li>The constraints on inputs and outputs are the same as the input of the type directive.</li>
</ul>
</li>
<li><code>oilist</code> ( <code>keyword</code> elements | <code>otherKeyword</code> elements …)<ul>
<li>Represents an optional order-independent list of clauses. Each clause has a keyword and corresponding assembly format.</li>
<li>Each clause can appear 0 or 1 time (in any order).</li>
<li>Only literals, types and variables can be used within an oilist element.</li>
<li>All the variables must be optional or variadic.</li>
</ul>
</li>
<li><code>operands</code><ul>
<li>Represents all of the operands of an operation.</li>
</ul>
</li>
<li>ref ( input )<ul>
<li>Represents a reference to the a variable or directive, that must have already been resolved, that may be used as a parameter to a custom directive.</li>
<li>Used to pass previously parsed entities to custom directives.</li>
<li>The input may be any directive or variable, aside from functional-type and custom.</li>
</ul>
</li>
<li>regions<ul>
<li>Represents all of the regions of an operation.</li>
</ul>
</li>
<li>results<ul>
<li>Represents all of the results of an operation.</li>
</ul>
</li>
<li>successors<ul>
<li>Represents all of the successors of an operation.</li>
</ul>
</li>
<li>type ( input )<ul>
<li>Represents the type of the given input.</li>
<li>input must be either an operand or result variable, the operands directive, or the results directive.</li>
</ul>
</li>
<li>qualified ( type_or_attribute )<ul>
<li>Wraps a type directive or an attribute parameter.</li>
<li>Used to force printing the type or attribute prefixed with its dialect and mnemonic. For example the vector.multi_reduction operation has a kind attribute ; by default the declarative assembly will print: vector.multi_reduction <minf>, … but using qualified($kind) in the declarative assembly format will print it instead as: vector.multi_reduction #vector.kind<minf>, ….</li>
</ul>
</li>
</ul>
<h3 id="可选成分"><a href="#可选成分" class="headerlink" title="可选成分"></a>可选成分</h3><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optional-group::= `(` then-elements `)` (`:` `(` else-elements `)`)? `?`</span><br></pre></td></tr></table></figure>

<ul>
<li><code>then-elements</code> 必须是一个attribute&#x2F;literal&#x2F;oprand&#x2F;region</li>
<li>必须有一个参数作为anchor<ul>
<li>作为anchor的参数以 <code>^</code></li>
<li>控制这个可选的部分是否在Op中打印出来</li>
</ul>
</li>
<li>optional group中只能出现literal&#x2F;variable&#x2F;custom directive&#x2F;type directive</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def ReturnOp : ... &#123;</span><br><span class="line">  let arguments = (ins Variadic&lt;AnyType&gt;:$operands);</span><br><span class="line"></span><br><span class="line">  // We only print the operands and types if there are a non-zero number</span><br><span class="line">  // of operands.</span><br><span class="line">  let assemblyFormat = &quot;attr-dict ($operands^ `:` type($operands))?&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Constraint"><a href="#Constraint" class="headerlink" title="Constraint"></a>Constraint</h2><ul>
<li>Single-entity constraint<ul>
<li>只对单个operand&#x2F;attribute&#x2F;result施加约束的</li>
</ul>
</li>
<li>Multi-entity constraint</li>
</ul>
<h3 id="设置constraint"><a href="#设置constraint" class="headerlink" title="设置constraint"></a>设置constraint</h3><p>Constraint由一组predicate构建：</p>
<ul>
<li><code>CPred</code>：leaf predicate，包含能够返回一个布尔类型的C++表达式&#x2F;函数调用&#x2F;…</li>
<li>Compound predicate</li>
</ul>
<p>部分占位符被保留下来，转化为C++中的hook：</p>
<ul>
<li><code>$_builder</code>：<code>mlir::Builder</code> 实例</li>
<li><code>$_op</code>：当前所在的Op，用于访问Op的相关信息</li>
<li><code>$_self</code>：和predicate绑定</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">And&lt;[</span><br><span class="line">  CPred&lt;&quot;$_self.isa&lt;IntegerAttr&gt;()&quot;&gt;,</span><br><span class="line">  Or&lt;[</span><br><span class="line">    CPred&lt;&quot;$_self.cast&lt;IntegerAttr&gt;().getType().isInteger(32)&quot;&gt;,</span><br><span class="line">    CPred&lt;&quot;$_self.cast&lt;IntegerAttr&gt;().getType().isInteger(64)&quot;&gt;</span><br><span class="line">  ]&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>如果一个constraint比较复杂，先用C++实现，然后再tablegen中识别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HasSomeProperty</span><span class="params">(Attribute attr)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def HasSomeProperty : AttrConstraint&lt;CPred&lt;&quot;HasSomeProperty($_self)&quot;&gt;,</span><br><span class="line">                                     &quot;has some property&quot;&gt;;</span><br><span class="line"></span><br><span class="line">def MyOp : Op&lt;...&gt; &#123;</span><br><span class="line">  let arguments = (ins</span><br><span class="line">    ...</span><br><span class="line">    HasSomeProperty:$attr</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="定义Attribute"><a href="#定义Attribute" class="headerlink" title="定义Attribute"></a>定义Attribute</h1><p>MLIR中Attribute的本质就是编译时常量，所以有着各种类型，如 <code>StrAttr</code> (C++ <code>StringAttr</code>)。<br>完整的attribute见<a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/Attributes.h">ODS attribute class</a>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-04T07:17:31.000Z" title="2024/1/4 15:17:31">2024-01-04</time>发表</span><span class="level-item"><time dateTime="2024-03-01T07:13:23.260Z" title="2024/3/1 15:13:23">2024-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/MLIR/">MLIR</a></span><span class="level-item">1 小时读完 (大约8068个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/04/MLIR/2_Toy-tutorial/">MLIR Toy Tutorial</a></p><div class="content"><h1 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h1><p>本文档是基于<a target="_blank" rel="noopener" href="https://mlir.llvm.org/docs/Tutorials/Toy/">MLIR Toy Tutorial</a>上附加本人学习经验中遇到的问题及经验而成的学习笔记。</p>
<h1 id="Chap1"><a href="#Chap1" class="headerlink" title="Chap1"></a>Chap1</h1><p>为了复现教程中的内容，在用CMake配置LLVM时需要加上选项 <code>-DLLVM_BUILD_EXAMPLES=ON</code> 来编译相关示例代码，能够在 <code>$BUILD_PATH/bin</code> 或者 <code>$INSTALL_PATH/examples</code> 中找到。</p>
<p>教程中所用的toy语言编译器文件树如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── toy</span><br><span class="line">│       ├── AST.h</span><br><span class="line">│       ├── Lexer.h</span><br><span class="line">│       └── Parser.h</span><br><span class="line">├── parser</span><br><span class="line">│   └── AST.cpp</span><br><span class="line">└── toyc.cpp</span><br></pre></td></tr></table></figure>

<p>使用MLIR来扩展编译流程时，通常是在Clang AST和LLVM IR中间插入了一个层次，所以这个教程中的toy编译器仅提供了将源代码解析为AST的能力。</p>
<p>Toy测试用例如下，可以在 <code>$LLVM_ROOT/mlir/test/Examples/Toy/Ch1/ast.toy</code> 该样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># User defined generic function that operates on unknown shaped arguments.</span><br><span class="line">def multiply_transpose(a, b) &#123;</span><br><span class="line">  return transpose(a) * transpose(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def main() &#123;</span><br><span class="line">  # Define a variable `a` with shape &lt;2, 3&gt;, initialized with the literal value.</span><br><span class="line">  var a = [[1, 2, 3], [4, 5, 6]];</span><br><span class="line">  var b&lt;2, 3&gt; = [1, 2, 3, 4, 5, 6];</span><br><span class="line"></span><br><span class="line">  # This call will specialize `multiply_transpose` with &lt;2, 3&gt; for both</span><br><span class="line">  # arguments and deduce a return type of &lt;3, 2&gt; in initialization of `c`.</span><br><span class="line">  var c = multiply_transpose(a, b);</span><br><span class="line"></span><br><span class="line">  # A second call to `multiply_transpose` with &lt;2, 3&gt; for both arguments will</span><br><span class="line">  # reuse the previously specialized and inferred version and return &lt;3, 2&gt;.</span><br><span class="line">  var d = multiply_transpose(b, a);</span><br><span class="line"></span><br><span class="line">  # A new call with &lt;3, 2&gt; (instead of &lt;2, 3&gt;) for both dimensions will</span><br><span class="line">  # trigger another specialization of `multiply_transpose`.</span><br><span class="line">  var e = multiply_transpose(c, d);</span><br><span class="line"></span><br><span class="line">  # Finally, calling into `multiply_transpose` with incompatible shapes</span><br><span class="line">  # (&lt;2, 3&gt; and &lt;3, 2&gt;) will trigger a shape inference error.</span><br><span class="line">  var f = multiply_transpose(a, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印该示例代码的命令为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$INSTALL_PATH</span>/examples/toyc-ch1 ast.toy</span><br></pre></td></tr></table></figure>

<h1 id="Chap2"><a href="#Chap2" class="headerlink" title="Chap2"></a>Chap2</h1><p>MLIR的核心是Operation，简记为Op。<br>Op具有良好的可扩展性，下列例子展示了为toy中的builtin操作 <code>transpose</code> 定义的Op：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%t_tensor = &quot;toy.transpose&quot;(%tensor) &#123;inplace = true&#125; : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt; loc(&quot;example/file/path&quot;:12:1)</span><br></pre></td></tr></table></figure>

<p>这里给出的是generic形式的Op，其含义如下：</p>
<ul>
<li><code>t_tensor</code>：Op的result</br>MLIR整体被视为一张数据流图，Op是节点，而result就是Op的出边</li>
<li><code>toy.transpose</code>：<code>.</code> 之前是方言，之后是Opcode</br>方言可以被视为MLIR的名称空间</li>
<li><code>(%tensor)</code>：操作数，满足SSA性质</li>
<li><code>&#123;inplace=true&#125;</code>：attribute dictionary</li>
<li><code>(tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt;</code>：Op的参数类型和返回值类型</li>
<li><code>loc(&quot;example/file/path&quot;:12:1)</code> 源代码中的位置信息</li>
</ul>
<blockquote>
<p>教程里说位置信息是需要要有的，这点在各个Op的C++ <code>build</code> 方法的参数中得到了体现。但是还是可以通过 <code>builder.getUnknownLoc()</code> 达到如传的效果。</p>
</blockquote>
<h2 id="定义toy-dialect"><a href="#定义toy-dialect" class="headerlink" title="定义toy dialect"></a>定义toy dialect</h2><p>从C++定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> m = ::mlir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ToyDialect</span> : <span class="keyword">public</span> m::Dialect &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ToyDialect</span><span class="params">(m::MLIRContext *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// utility accessor for dialect</span></span><br><span class="line">  <span class="function"><span class="type">static</span> llvm::StringRef <span class="title">getDialectNamespace</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;toy&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call from constructor of ToyDialect used to</span></span><br><span class="line">  <span class="comment">// register attributes, operations, types, ...</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m::MLIRContext ctx;</span><br><span class="line">  <span class="comment">// register into context</span></span><br><span class="line">  ctx.<span class="built_in">loadDialect</span>&lt;m::toy::ToyDialect&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从TableGene定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def Toy_Dialect : Dialect &#123;</span><br><span class="line">  // Equal to `ToyDialect::getDialectNamespace`</span><br><span class="line">  let name = &quot;toy&quot;;</span><br><span class="line"></span><br><span class="line">  // A short one-line summary for the dialect.</span><br><span class="line">  let summary = &quot;A high-level dialect for toy lang&quot;;</span><br><span class="line"></span><br><span class="line">  // A longer description of our dialect.</span><br><span class="line">  let description = [&#123;The toy lang is ... analysis and optimization.&#125;];</span><br><span class="line"></span><br><span class="line">  // A specific CPP namespace for generating relevant files.</span><br><span class="line">  let cppNamespace = &quot;toy&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从TableGen生成相关C++文件需要使用 <code>mlir-tblgen</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mlir-tblgen -gen-dialect-decls Ops.td -I <span class="variable">$&#123;mlir_src_root&#125;</span>/include/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TODO: 这里生成的文件输出在stdout中，为了在C++中引用，它应该放在哪里呢？文件名应该是什么？</p>
</blockquote>
<h3 id="在-MLIRContext-中注册ToyDialect"><a href="#在-MLIRContext-中注册ToyDialect" class="headerlink" title="在 MLIRContext 中注册ToyDialect"></a>在 <code>MLIRContext</code> 中注册<code>ToyDialect</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="built_in">loadDialect</span>&lt;ToyDialect&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="定义Toy-Op"><a href="#定义Toy-Op" class="headerlink" title="定义Toy Op"></a>定义Toy Op</h2><p>上述步骤定义了一个toy dialect，现在其内部还是空空如也，没有定义Op。<br>接下来尝试定义 <code>toy.constant</code> Op，用来表示toy lang中的常量。</p>
<h3 id="MLIR中的形式"><a href="#MLIR中的形式" class="headerlink" title="MLIR中的形式"></a>MLIR中的形式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%4 = &quot;toy.constant&quot;() &#123; value = dense&lt;1.0&gt; : tensor&lt;2x3xf64&gt; &#125; : () -&gt; tensor&lt;2x3xf64&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有操作数</li>
<li><code>dense</code> 是builtin attribute，包含了一个稠密多维数组；该attribute和与名称 <code>name</code> 绑定在一起来表示一个常量，其类型为 <code>tensor&lt;2x3xf64&gt;</code></li>
</ul>
<h3 id="使用C-定义"><a href="#使用C-定义" class="headerlink" title="使用C++定义"></a>使用C++定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstantOp</span> : <span class="keyword">public</span> mlir::Op&lt;</span><br><span class="line">                     <span class="comment">/// `mlir::Op` is a CRTP class, meaning that we provide the</span></span><br><span class="line">                     <span class="comment">/// derived class as a template parameter.</span></span><br><span class="line">                     ConstantOp,</span><br><span class="line">                     <span class="comment">/// The ConstantOp takes zero input operands.</span></span><br><span class="line">                     mlir::OpTrait::ZeroOperands,</span><br><span class="line">                     <span class="comment">/// The ConstantOp returns a single result.</span></span><br><span class="line">                     mlir::OpTrait::OneResult,</span><br><span class="line">                     <span class="comment">/// We also provide a utility `getType` accessor that</span></span><br><span class="line">                     <span class="comment">/// returns the TensorType of the single result.</span></span><br><span class="line">                     mlir::OpTraits::OneTypedResult&lt;TensorType&gt;::Impl&gt; &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// Inherit the constructors from the base Op class.</span></span><br><span class="line">  <span class="keyword">using</span> Op::Op;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Provide the unique name for this operation. MLIR will use this to register</span></span><br><span class="line">  <span class="comment">/// the operation and uniquely identify it throughout the system. The name</span></span><br><span class="line">  <span class="comment">/// provided here must be prefixed by the parent dialect namespace followed</span></span><br><span class="line">  <span class="comment">/// by a `.`.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> llvm::StringRef <span class="title">getOperationName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;toy.constant&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Return the value of the constant by fetching it from the attribute.</span></span><br><span class="line">  <span class="function">mlir::DenseElementsAttr <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Operations may provide additional verification beyond what the attached</span></span><br><span class="line">  <span class="comment">/// traits provide.  Here we will ensure that the specific invariants of the</span></span><br><span class="line">  <span class="comment">/// constant operation are upheld, for example the result type must be</span></span><br><span class="line">  <span class="comment">/// of TensorType and matches the type of the constant `value`.</span></span><br><span class="line">  <span class="function">LogicalResult <span class="title">verifyInvariants</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Provide an interface to build this operation from a set of input values.</span></span><br><span class="line">  <span class="comment">/// This interface is used by the `builder` classes to allow for easily</span></span><br><span class="line">  <span class="comment">/// generating instances of this operation:</span></span><br><span class="line">  <span class="comment">///   mlir::OpBuilder::create&lt;ConstantOp&gt;(...)</span></span><br><span class="line">  <span class="comment">/// This method populates the given `state` that MLIR uses to create</span></span><br><span class="line">  <span class="comment">/// operations. This state is a collection of all of the discrete elements</span></span><br><span class="line">  <span class="comment">/// that an operation may contain.</span></span><br><span class="line">  <span class="comment">/// Build a constant with the given return type and `value` attribute.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(mlir::OpBuilder &amp;builder, mlir::OperationState &amp;state,</span></span></span><br><span class="line"><span class="params"><span class="function">                    mlir::Type result, mlir::DenseElementsAttr value)</span></span>;</span><br><span class="line">  <span class="comment">/// Build a constant and reuse the type from the given &#x27;value&#x27;.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(mlir::OpBuilder &amp;builder, mlir::OperationState &amp;state,</span></span></span><br><span class="line"><span class="params"><span class="function">                    mlir::DenseElementsAttr value)</span></span>;</span><br><span class="line">  <span class="comment">/// Build a constant by broadcasting the given &#x27;value&#x27;.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">build</span><span class="params">(mlir::OpBuilder &amp;builder, mlir::OperationState &amp;state,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">double</span> value)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Trait是一种高层次的信息，其它的还有表示参数和结果类型是否一致等；模板中除了第一参数用在CRTP之外，其它模板参数都是trait</li>
<li><code>getValue</code> 返回的是attrbute</li>
<li><code>verifyInvariants</code> 检验attrbute中保存的是不是一个tensor类型</li>
<li><code>build</code> 提供给 <code>OpBuilder::create</code> 使用的构造方法</li>
<li><code>OperationState</code> 包含各种创建Op的各种属性，如Op名称、位置信息等；这个对象很重量级，应该仅在创建时作为临时变量使用；在使用 <code>OpBuilder::create</code> 创建Op时，该对象由 <code>create</code> 自行创建</li>
</ul>
<h4 id="注册在-ToyDialect-中"><a href="#注册在-ToyDialect-中" class="headerlink" title="注册在 ToyDialect 中"></a>注册在 <code>ToyDialect</code> 中</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyDialect::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">addOperations</span>&lt;ConstantOp&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用ODS框架定义Op"><a href="#使用ODS框架定义Op" class="headerlink" title="使用ODS框架定义Op"></a>使用ODS框架定义Op</h2><p>ODS (Operation Definition Specification) 是MLIR提供的另一种定义Op的方式，使用TableGen语法。</p>
<h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>使用ODS框架时，同样需要从 <code>Op</code> 中派生tablegen record。<br>方便起见，这里先定义一个 <code>Toy_Op</code> 方便后续Op的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Base class for toy dialect operations. This operation inherits from the base</span><br><span class="line">// `Op` class in OpBase.td, and provides:</span><br><span class="line">//   * The parent dialect of the operation.</span><br><span class="line">//   * The mnemonic for the operation, or the name without the dialect prefix.</span><br><span class="line">//   * A list of traits for the operation.</span><br><span class="line">class Toy_Op&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt; :</span><br><span class="line">    Op&lt;Toy_Dialect, mnemonic, traits&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mnemonic</code> 指助记符，即Opcode&#x2F;名字，与之前C++中的 <code>ConstantOp::getOperationName</code> 对应，但不用加上dialect的前缀 <code>toy.</code></li>
<li><code>Toy_Dialect</code> 之前单独定义的dialect</li>
<li>C++中定义时添加的trait在ODS中自动推导并加入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def ConstantOp : Toy_Op&lt;&quot;constant&quot;&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-mlir-tblgen-生成C-文件"><a href="#使用-mlir-tblgen-生成C-文件" class="headerlink" title="使用 mlir-tblgen 生成C++文件"></a>使用 <code>mlir-tblgen</code> 生成C++文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mlir-tblgen -decls-op-defs Ops.td -I <span class="variable">$&#123;mlir_src_root&#125;</span>/include/</span><br><span class="line">mlir-tblgen -gen-op-decls Ops.td -I <span class="variable">$&#123;mlir_src_root&#125;</span>/include/</span><br></pre></td></tr></table></figure>

<h3 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h3><p>填充 <code>arguments</code> 和 <code>results</code> 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def ConstantOp : Toy_Op&lt;&quot;constant&quot;&gt; &#123;</span><br><span class="line">  // The constant operation takes an attribute as the only input.</span><br><span class="line">  // `F64ElementsAttr` corresponds to a 64-bit floating-point ElementsAttr.</span><br><span class="line">  let arguments = (ins F64ElementsAttr:$value);</span><br><span class="line">  let results = (outs F64Tensor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><p>添加 <code>summary</code> 和 <code>description</code> 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def ConstantOp : Toy_Op&lt;&quot;constant&quot;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  // Provide a summary and description for this operation. This can be used to</span><br><span class="line">  // auto-generate documentation of the operations within our dialect.</span><br><span class="line">  let summary = &quot;constant operation&quot;;</span><br><span class="line">  let description = [&#123;</span><br><span class="line">    Constant operation turns a literal into an SSA value. The data is attached</span><br><span class="line">    to the operation as an attribute. For example:</span><br><span class="line"></span><br><span class="line">      %0 = &quot;toy.constant&quot;()</span><br><span class="line">         &#123; value = dense&lt;[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]&gt; : tensor&lt;2x3xf64&gt; &#125;</span><br><span class="line">        : () -&gt; tensor&lt;2x3xf64&gt;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检验Op的语义"><a href="#检验Op的语义" class="headerlink" title="检验Op的语义"></a>检验Op的语义</h3><p>设置 <code>hasVerifier = 1</code> 时会在头文件中生成函数签名 <code>::mlir::Logical verify()</code>。</p>
<h3 id="定义-build"><a href="#定义-build" class="headerlink" title="定义 build"></a>定义 <code>build</code></h3><p>Tablegen能够自动生成一些简单的Op创建函数，剩下的创建函数则需要填充 <code>builders</code> 字段来生成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def ConstantOp : Toy_Op&lt;&quot;constant&quot;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // Add custom build methods for the constant operation. These methods populate</span><br><span class="line">  // the `state` that MLIR uses to create operations, i.e. these are used when</span><br><span class="line">  // using `builder.create&lt;ConstantOp&gt;(...)`.</span><br><span class="line">  let builders = [</span><br><span class="line">    // Build a constant with a given constant tensor value.</span><br><span class="line">    OpBuilder&lt;(ins &quot;DenseElementsAttr&quot;:$value), [&#123;</span><br><span class="line">      // Call into an autogenerated `build` method.</span><br><span class="line">      build(builder, result, value.getType(), value);</span><br><span class="line">    &#125;]&gt;,</span><br><span class="line"></span><br><span class="line">    // Build a constant with a given constant floating-point value. This builder</span><br><span class="line">    // creates a declaration for `ConstantOp::build` with the given parameters.</span><br><span class="line">    OpBuilder&lt;(ins &quot;double&quot;:$value)&gt;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指定MLIR代码格式"><a href="#指定MLIR代码格式" class="headerlink" title="指定MLIR代码格式"></a>指定MLIR代码格式</h2><p>在完整的实现中，<code>$INSTALL_PATH/examples/toyc-ch2 ast.toy -emit=mlir -mlir-print-debuginfo 2&gt; codegen.mlir</code> 能够生成MLIR的generic形式。<br>然而这种形式阅读性不够好，通过自定义指令格式能够获得更好的可读性。</p>
<p>e.g. <code>toy.print</code> 指令在generic格式下会被打印为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;toy.print&quot;(%5) : (tensor&lt;*xf64&gt;) -&gt; () loc(&quot;test/Examples/Toy/Ch2/codegen.toy&quot;:13:3)</span><br></pre></td></tr></table></figure>
<p>然而在定义中它的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toy.print %5 : tensor&lt;*xf64&gt; loc(...)</span><br></pre></td></tr></table></figure>

<p>通过填充 <code>assemblyFormat</code> 和 <code>hasAssemblyFormat</code> 字段能够做到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/// Consider a stripped definition of `toy.print` here.</span><br><span class="line">def PrintOp : Toy_Op&lt;&quot;print&quot;&gt; &#123;</span><br><span class="line">  let arguments = (ins F64Tensor:$input);</span><br><span class="line"></span><br><span class="line">  // Divert the printer and parser to `parse` and `print` methods on our operation,</span><br><span class="line">  // to be implemented in the .cpp file. More details on these methods is shown below.</span><br><span class="line">  let hasCustomAssemblyFormat = 1;</span><br><span class="line"></span><br><span class="line">  // In the following format we have two directives, `attr-dict` and `type`.</span><br><span class="line">  // These correspond to the attribute dictionary and the type of a given</span><br><span class="line">  // variable represectively.</span><br><span class="line">  let assemblyFormat = &quot;$input attr-dict `:` type($input)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>asseblyFormat</code> 字段填入的为declarative格式，主要包括下列三个部分：</p>
<ul>
<li>directives：示例中的 <code>type</code> </li>
<li>literals：由 &#96;&#96; 包围，或者关键字</li>
<li>variables：在Op中注册的数据项，如操作数，结果，后继等，以 <code>$</code> 开头</li>
</ul>
<h3 id="Dialect-h-和-Dialect-cpp"><a href="#Dialect-h-和-Dialect-cpp" class="headerlink" title="Dialect.h 和 Dialect.cpp"></a><code>Dialect.h</code> 和 <code>Dialect.cpp</code></h3><p>该文件需要引用上述生成的文件，用来实现各种解析规则、非默认的 <code>build</code> 方法和 <code>verify</code> 方法。</p>
<p>MLIR相关的内容都放在了目录 <code>mlir</code> 下。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>从文档中可以看出来官方很希望我们用ODS方式来实现我们的MLIR dialect和Op。<br>所有的dialect的文档都是用ODS格式写的。</p>
<h1 id="Chap3"><a href="#Chap3" class="headerlink" title="Chap3"></a>Chap3</h1><h2 id="高层次上语言专有的代码变换"><a href="#高层次上语言专有的代码变换" class="headerlink" title="高层次上语言专有的代码变换"></a>高层次上语言专有的代码变换</h2><p>和编写dialect&#x2F;Op一样，MLIR提供了C++和ODS两种方式来编写代码转换。<br>核心的转换思路都是DAG-to-DAG的转换：匹配一组Op的DAG，然后用另一个DAG去替换它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPattern</span> : <span class="keyword">public</span> RewritePattern &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// This overload constructs a pattern that only matches operations with the</span></span><br><span class="line">  <span class="comment">/// root name of `MyOp`.</span></span><br><span class="line">  <span class="built_in">MyPattern</span>(PatternBenefit benefit, MLIRContext *context)</span><br><span class="line">      : <span class="built_in">RewritePattern</span>(MyOp::<span class="built_in">getOperationName</span>(), benefit, context) &#123;&#125;</span><br><span class="line">  <span class="comment">/// This overload constructs a pattern that matches any operation type.</span></span><br><span class="line">  <span class="built_in">MyPattern</span>(PatternBenefit benefit)</span><br><span class="line">      : <span class="built_in">RewritePattern</span>(benefit, <span class="built_in">MatchAnyOpTypeTag</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// In this section, the `match` and `rewrite` implementation is specified</span></span><br><span class="line">  <span class="comment">/// using the separate hooks.</span></span><br><span class="line">  <span class="function">LogicalResult <span class="title">match</span><span class="params">(Operation *op)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The `match` method returns `success()` if the pattern is a match, failure</span></span><br><span class="line">    <span class="comment">// otherwise.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rewrite</span><span class="params">(Operation *op, PatternRewriter &amp;rewriter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The `rewrite` method performs mutations on the IR rooted at `op` using</span></span><br><span class="line">    <span class="comment">// the provided rewriter. All mutations must go through the provided</span></span><br><span class="line">    <span class="comment">// rewriter.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// In this section, the `match` and `rewrite` implementation is specified</span></span><br><span class="line">  <span class="comment">/// using a single hook.</span></span><br><span class="line">  <span class="function">LogicalResult <span class="title">matchAndRewrite</span><span class="params">(Operation *op, PatternRewriter &amp;rewriter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The `matchAndRewrite` method performs both the matching and the mutation.</span></span><br><span class="line">    <span class="comment">// Note that the match must reach a successful point before IR mutation may</span></span><br><span class="line">    <span class="comment">// take place.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Pattern的定义需要继承 <code>RewritePattern</code></li>
<li>构造函数的参数 <code>benefit</code> 是一个可以被动态计算的值，大致是用来确定变换的优先级 (TODO: 文档里说的东西我没理解)</li>
<li><code>RewritePatern(MyOp&quot;&quot;getOperationName(), ...)</code> 中指定了匹配的DAG中根Op的名称；如果不指定则需要加上 <code>MatchAnyOpTypeTag</code> 来匹配任何可能的pattern</li>
<li><code>match</code> 中不能进行代码变换</li>
<li><code>rewrite</code> 中的代码变换必须用参数中的 <code>PatternRewriter</code> 进行；根Op必须进行以下操作之一：updated in-place、replaced或者erased</li>
<li><code>match</code> 和 <code>rewrite</code> 分别是匹配和重写的具体实现，但是当这两个过程中存在一些复杂的分析或者计算过程时，为了结果复用，可以将两者合并实现为 <code>matchAndRewrite</code></li>
</ul>
<h2 id="transpose-transpose-X-X"><a href="#transpose-transpose-X-X" class="headerlink" title="transpose(transpose(X)) -&gt; X"></a><code>transpose(transpose(X)) -&gt; X</code></h2><p>对于张量 <code>X</code> 而言，连续两次转置操作等价于恒等变换，因此能够进行代码变换来消除冗余操作。</p>
<p>源代码形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def transpose_transpose(x) &#123;</span><br><span class="line">  return transpose(transpose(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中间表示形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">toy.func @transpose_transpose(%arg0: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; &#123;</span><br><span class="line">  %0 = toy.transpose(%arg0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  %1 = toy.transpose(%0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  toy.return %1 : tensor&lt;*xf64&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Fold transpose(transpose(x)) -&gt; x</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SimplifyRedundantTranspose</span> : <span class="keyword">public</span> mlir::OpRewritePattern&lt;TransposeOp&gt; &#123;</span><br><span class="line">  <span class="comment">/// We register this pattern to match every toy.transpose in the IR.</span></span><br><span class="line">  <span class="comment">/// The &quot;benefit&quot; is used by the framework to order the patterns and process</span></span><br><span class="line">  <span class="comment">/// them in order of profitability.</span></span><br><span class="line">  <span class="built_in">SimplifyRedundantTranspose</span>(mlir::MLIRContext *context)</span><br><span class="line">      : <span class="built_in">OpRewritePattern</span>&lt;TransposeOp&gt;(context, <span class="comment">/*benefit=*/</span><span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This method is attempting to match a pattern and rewrite it. The rewriter</span></span><br><span class="line">  <span class="comment">/// argument is the orchestrator of the sequence of rewrites. It is expected</span></span><br><span class="line">  <span class="comment">/// to interact with it to perform any changes to the IR from here.</span></span><br><span class="line">  <span class="function">mlir::LogicalResult</span></span><br><span class="line"><span class="function">  <span class="title">matchAndRewrite</span><span class="params">(TransposeOp op,</span></span></span><br><span class="line"><span class="params"><span class="function">                  mlir::PatternRewriter &amp;rewriter)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Look through the input of the current transpose.</span></span><br><span class="line">    mlir::Value transposeInput = op.<span class="built_in">getOperand</span>();</span><br><span class="line">    TransposeOp transposeInputOp = transposeInput.<span class="built_in">getDefiningOp</span>&lt;TransposeOp&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Input defined by another transpose? If not, no match.</span></span><br><span class="line">    <span class="keyword">if</span> (!transposeInputOp)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">failure</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Otherwise, we have a redundant transpose. Use the rewriter.</span></span><br><span class="line">    rewriter.<span class="built_in">replaceOp</span>(op, &#123;transposeInputOp.<span class="built_in">getOperand</span>()&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>将根Op设置为 <code>TransposeOp</code> 然后判定其参数是不是也是一个 <code>TransposeOp</code>，即可完成判定</li>
<li>代码重写通过 <code>rewriter</code> 完成，用最内层的操作数替换</li>
</ul>
<h4 id="Canonicalization-pass"><a href="#Canonicalization-pass" class="headerlink" title="Canonicalization pass"></a>Canonicalization pass</h4><p>规范化pass能够应有上述的重写规则对Op进行代码变换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register our patterns for rewrite by the Canonicalization framework.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TransposeOp::getCanonicalizationPatterns</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    RewritePatternSet &amp;results, MLIRContext *context)</span> </span>&#123;</span><br><span class="line">  results.<span class="built_in">add</span>&lt;SimplifyRedundantTranspose&gt;(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了启动这个变换还需要将 <code>TransposeOp</code> 的 <code>hasCanonicalizer</code> 字段设置为1。</p>
<h3 id="在MLIR-pass-manager中注册"><a href="#在MLIR-pass-manager中注册" class="headerlink" title="在MLIR pass manager中注册"></a>在MLIR pass manager中注册</h3><p>在驱动 <code>toyc.cpp</code> 中需要将上述优化遍注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mlir::PassManager <span class="title">pm</span><span class="params">(<span class="keyword">module</span>-&gt;getName())</span></span>;</span><br><span class="line">pm.<span class="built_in">addNestedPass</span>&lt;mlir::toy::FuncOp&gt;(mlir::<span class="built_in">createCanonicalizerPass</span>());</span><br></pre></td></tr></table></figure>

<h3 id="pure-Op和代码删除"><a href="#pure-Op和代码删除" class="headerlink" title="pure Op和代码删除"></a>pure Op和代码删除</h3><p>上述pass只能清除掉一个转置操作，即没有进行对整个DAG进行替换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toy.func @transpose_transpose(%arg0: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; &#123;</span><br><span class="line">  %0 = toy.transpose(%arg0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  toy.return %arg0 : tensor&lt;*xf64&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为MLIR会假设所有的Op都是有副作用的，因此会保守地进行代码删除。<br>向 <code>TransposeOp</code> 中添加pure trait能够将两个转置操作都消除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def TransposeOp : Toy_Op&lt;&quot;transpose&quot;, [Pure]&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reshape优化"><a href="#reshape优化" class="headerlink" title="reshape优化"></a>reshape优化</h2><p>对张量进行同样形状的reshape操作也是一种冗余，比如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def main() &#123;</span><br><span class="line">  var a&lt;2,1&gt; = [1, 2];</span><br><span class="line">  var b&lt;2,1&gt; = a;</span><br><span class="line">  var c&lt;2,1&gt; = b;</span><br><span class="line">  print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module &#123;</span><br><span class="line">  toy.func @main() &#123;</span><br><span class="line">    %0 = toy.constant dense&lt;[1.000000e+00, 2.000000e+00]&gt; : tensor&lt;2xf64&gt;</span><br><span class="line">    %1 = toy.reshape(%0 : tensor&lt;2xf64&gt;) to tensor&lt;2x1xf64&gt;</span><br><span class="line">    %2 = toy.reshape(%1 : tensor&lt;2x1xf64&gt;) to tensor&lt;2x1xf64&gt;</span><br><span class="line">    %3 = toy.reshape(%2 : tensor&lt;2x1xf64&gt;) to tensor&lt;2x1xf64&gt;</span><br><span class="line">    toy.print %3 : tensor&lt;2x1xf64&gt;</span><br><span class="line">    toy.return</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DRR实现"><a href="#DRR实现" class="headerlink" title="DRR实现"></a>DRR实现</h3><p>DRR (Table-driven Declarative Rewrite Rule) 使用tablegen描述代码的代码变换规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Pattern&lt;</span><br><span class="line">  dag sourcePattern, list&lt;dag&gt; resultPatterns,</span><br><span class="line">  list&lt;dag&gt; additionalConstraints = [],</span><br><span class="line">  dag benefitsAdded = (addBenefit 0)&gt;;</span><br><span class="line"></span><br><span class="line">// Transpose(Tranpose(x)) = x</span><br><span class="line">def TTOptPattern : Pattern&lt;(TransposeOp(TransposeOp $arg)),</span><br><span class="line">                           ($arg)&gt;;</span><br></pre></td></tr></table></figure>

<p>但是在进行reshape的优化时，我们需要根据reshape的参数来确定优化是否能够执行，而不是简单进行模式匹配。<br>下面的DRR实现了冗余reshape消除优化，增加了约束条件——当输入和输出的shape一致时进行代码变换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def TypesAreIdentical : Constraint&lt;CPred&lt;&quot;$0.getType() == $1.getType()&quot;&gt;&gt;;</span><br><span class="line">def RedundantReshapeOptPattern : Pattern&lt;</span><br><span class="line">  (ReshapeOp:$res $arg), (replaceWithValue $arg),</span><br><span class="line">  [(TypesAreIdentical $res, $arg)]&gt;;</span><br></pre></td></tr></table></figure>

<p>在更特殊的情况下，我们还需要对参数进行变化，这需要通过 <code>NativeCodeCall</code> 进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def ReshapeConstant : NativeCodeCall&lt;&quot;$0.reshape(($1.getType()).cast&lt;ShapedType&gt;())&quot;&gt;;</span><br><span class="line">def FoldConstantReshapeOptPattern : Pat&lt;</span><br><span class="line">  (ReshapeOp:$res (ConstantOp $arg)),</span><br><span class="line">  (ConstantOp (ReshapeConstant $arg, $res))&gt;;</span><br></pre></td></tr></table></figure>

<h1 id="Chap4"><a href="#Chap4" class="headerlink" title="Chap4"></a>Chap4</h1><h2 id="通用代码变换"><a href="#通用代码变换" class="headerlink" title="通用代码变换"></a>通用代码变换</h2><p>在MLIR中，通用pass不需要为不同的dialect分别实现。<br>之前在编写转置优化时，<code>getCanonicalizationPatterns</code> 就是一个用来注册pass的hook。<br>但是hook的可扩展性比较有限，不能满足通用优化遍的需求，因此MLIR提供了interface来支持通用pass。</p>
<h2 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h2><p>MLIR提供了通用的inliner并允许我们将其挂载到toy dialect中，我们需要提供让inliner挂载的interface。</p>
<h3 id="Dialect-interface"><a href="#Dialect-interface" class="headerlink" title="Dialect interface"></a>Dialect interface</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This class defines the interface for handling inlining with Toy operations.</span></span><br><span class="line"><span class="comment">/// We simplify inherit from the base interface class and override</span></span><br><span class="line"><span class="comment">/// the necessary methods.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ToyInlinerInterface</span> : <span class="keyword">public</span> DialectInlinerInterface &#123;</span><br><span class="line">  <span class="keyword">using</span> DialectInlinerInterface::DialectInlinerInterface;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This hook checks to see if the given callable operation is legal to inline</span></span><br><span class="line">  <span class="comment">/// into the given call. For Toy this hook can simply return true, as the Toy</span></span><br><span class="line">  <span class="comment">/// Call operation is always inlinable.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isLegalToInline</span><span class="params">(Operation *call, Operation *callable,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">bool</span> wouldBeCloned)</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This hook checks to see if the given operation is legal to inline into the</span></span><br><span class="line">  <span class="comment">/// given region. For Toy this hook can simply return true, as all Toy</span></span><br><span class="line">  <span class="comment">/// operations are inlinable.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isLegalToInline</span><span class="params">(Operation *, Region *, <span class="type">bool</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       IRMapping &amp;)</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This hook cheks if the given &#x27;src&#x27; region can be inlined into the &#x27;dest&#x27;</span></span><br><span class="line">  <span class="comment">/// region. The regions here are the bodies of the callable functions. For</span></span><br><span class="line">  <span class="comment">/// Toy, any function can be inlined, so we simply return true.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isLegalToInline</span><span class="params">(Region *dest, Region *src, <span class="type">bool</span> wouldBeCloned,</span></span></span><br><span class="line"><span class="params"><span class="function">                       IRMapping &amp;valueMapping)</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This hook is called when a terminator operation has been inlined. The only</span></span><br><span class="line">  <span class="comment">/// terminator that we have in the Toy dialect is the return</span></span><br><span class="line">  <span class="comment">/// operation(toy.return). We handle the return by replacing the values</span></span><br><span class="line">  <span class="comment">/// previously returned by the call operation with the operands of the</span></span><br><span class="line">  <span class="comment">/// return.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleTerminator</span><span class="params">(Operation *op,</span></span></span><br><span class="line"><span class="params"><span class="function">                        MutableArrayRef&lt;Value&gt; valuesToRepl)</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Only &quot;toy.return&quot; needs to be handled here.</span></span><br><span class="line">    <span class="keyword">auto</span> returnOp = <span class="built_in">cast</span>&lt;ReturnOp&gt;(op);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace the values directly with the return operands.</span></span><br><span class="line">    <span class="built_in">assert</span>(returnOp.<span class="built_in">getNumOperands</span>() == valuesToRepl.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;it : llvm::<span class="built_in">enumerate</span>(returnOp.<span class="built_in">getOperands</span>()))</span><br><span class="line">      valuesToRepl[it.<span class="built_in">index</span>()].<span class="built_in">replaceAllUsesWith</span>(it.<span class="built_in">value</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这部分提供了在toy lang中进行内联操作的约束条件，重载了interface提供的虚函数hook</li>
</ul>
<p>另一方面，inliner还需要设置函数在MLIR生成过程中的可见性，因为inliner会删掉被设置为private且没有没使用的函数的定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Emit a new function and add it to the MLIR module.</span></span><br><span class="line">mlir::<span class="function">toy::FuncOp <span class="title">mlirGen</span><span class="params">(FunctionAST &amp;funcAST)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// If this function isn&#x27;t main, then set the visibility to private.</span></span><br><span class="line">  <span class="keyword">if</span> (funcAST.<span class="built_in">getProto</span>()-&gt;<span class="built_in">getName</span>() != <span class="string">&quot;main&quot;</span>)</span><br><span class="line">    function.<span class="built_in">setPrivate</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在dialect中注册"><a href="#在dialect中注册" class="headerlink" title="在dialect中注册"></a>在dialect中注册</h4><p>和Op一样，interface也要在dialect中注册才能使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyDialect::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">addInterfaces</span>&lt;ToyInlinerInterface&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Operation-interface"><a href="#Operation-interface" class="headerlink" title="Operation interface"></a>Operation interface</h3><p>Toy lang中使用 <code>toy.generic_call</code> 表示代码函数调用，使用 <code>toy.func</code> 表示函数定义。<br>通过operation interface能够让iniliner知道要对这两个Op分别是call-like和callable-like。</p>
<p>在 <code>Ops.td</code> 中需要引用interface的相关文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &quot;mlir/Interfaces/CallInterfaces.td&quot;</span><br></pre></td></tr></table></figure>

<p>添加相关trait：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def FuncOp : Toy_Op&lt;&quot;func&quot;,</span><br><span class="line">    [DeclareOpInterfaceMethods&lt;CallableOpInterface&gt;]&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def GenericCallOp : Toy_Op&lt;&quot;generic_call&quot;,</span><br><span class="line">    [DeclareOpInterfaceMethods&lt;CallOpInterface&gt;]&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>DeclareOpInterfaceMethods</code> 是ODS direcitive，能自动生成所有的方法函数签名，使我们只用提供函数的实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Returns the region on the function operation that is callable.</span></span><br><span class="line"><span class="function">Region *<span class="title">FuncOp::getCallableRegion</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;<span class="built_in">getBody</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Return the callee of the generic call operation, this is required by the</span></span><br><span class="line"><span class="comment">/// call interface.</span></span><br><span class="line"><span class="function">CallInterfaceCallable <span class="title">GenericCallOp::getCallableForCallee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">getAttrOfType</span>&lt;SymbolRefAttr&gt;(<span class="string">&quot;callee&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Set the callee for the generic call operation, this is required by the call</span></span><br><span class="line"><span class="comment">/// interface.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenericCallOp::setCalleeFromCallable</span><span class="params">(CallInterfaceCallable callee)</span> </span>&#123;</span><br><span class="line">  (*<span class="keyword">this</span>)-&gt;<span class="built_in">setAttr</span>(<span class="string">&quot;callee&quot;</span>, callee.<span class="built_in">get</span>&lt;SymbolRefAttr&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Get the argument operands to the called function, this is required by the</span></span><br><span class="line"><span class="comment">/// call interface.</span></span><br><span class="line"><span class="function">Operation::operand_range <span class="title">GenericCallOp::getArgOperands</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">inputs</span>(); &#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加到pass-manager中"><a href="#添加到pass-manager中" class="headerlink" title="添加到pass manager中"></a>添加到pass manager中</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.<span class="built_in">addPass</span>(mlir::<span class="built_in">createInlinerPass</span>());</span><br></pre></td></tr></table></figure>

<h3 id="处理类型转换"><a href="#处理类型转换" class="headerlink" title="处理类型转换"></a>处理类型转换</h3><p>在toy lang中，即使一个张量的shape是确定的，在传入的时候也会被转换为不定形状的 <code>tensor&lt;*xf64&gt;</code>，为此iniliner需要显式类型转换，实现为 <code>toy.cast</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def CastOp : Toy_Op&lt;&quot;cast&quot;, [</span><br><span class="line">    DeclareOpInterfaceMethods&lt;CastOpInterface&gt;,</span><br><span class="line">    Pure,</span><br><span class="line">    SameOperandsAndResultShape]</span><br><span class="line">  &gt; &#123;</span><br><span class="line">  let summary = &quot;shape cast operation&quot;;</span><br><span class="line">  let description = [&#123;</span><br><span class="line">    The &quot;cast&quot; operation converts a tensor from one type to an equivalent type</span><br><span class="line">    without changing any data elements. The source and destination types</span><br><span class="line">    must both be tensor types with the same element type. If both are ranked,</span><br><span class="line">    then shape is required to match. The operation is invalid if converting</span><br><span class="line">    to a mismatching constant dimension.</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  let arguments = (ins F64Tensor:$input);</span><br><span class="line">  let results = (outs F64Tensor:$output);</span><br><span class="line">  let assemblyFormat = &quot;$input attr-dict `:` type($input) `to` type($output)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Trait list中添加了 <code>CastOpInterface</code>，提供了一些转型用的工具，如检验转型是否正确</li>
</ul>
<p>在实现中提供检验转型是否能成功的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Returns true if the given set of input and result types are compatible with</span></span><br><span class="line"><span class="comment">/// this cast operation. This is required by the `CastOpInterface` to verify</span></span><br><span class="line"><span class="comment">/// this operation and provide other additional utilities.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CastOp::areCastCompatible</span><span class="params">(TypeRange inputs, TypeRange outputs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inputs.<span class="built_in">size</span>() != <span class="number">1</span> || outputs.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// The inputs must be Tensors with the same element type.</span></span><br><span class="line">  TensorType input = inputs.<span class="built_in">front</span>().<span class="built_in">dyn_cast</span>&lt;TensorType&gt;();</span><br><span class="line">  TensorType output = outputs.<span class="built_in">front</span>().<span class="built_in">dyn_cast</span>&lt;TensorType&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!input || !output || input.<span class="built_in">getElementType</span>() != output.<span class="built_in">getElementType</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// The shape is required to match if both types are ranked.</span></span><br><span class="line">  <span class="keyword">return</span> !input.<span class="built_in">hasRank</span>() || !output.<span class="built_in">hasRank</span>() || input == output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在dialect-interface重载相关hook"><a href="#在dialect-interface重载相关hook" class="headerlink" title="在dialect interface重载相关hook"></a>在dialect interface重载相关hook</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ToyInlinerInterface</span> : <span class="keyword">public</span> DialectInlinerInterface &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Attempts to materialize a conversion for a type mismatch between a call</span></span><br><span class="line">  <span class="comment">/// from this dialect, and a callable region. This method should generate an</span></span><br><span class="line">  <span class="comment">/// operation that takes &#x27;input&#x27; as the only operand, and produces a single</span></span><br><span class="line">  <span class="comment">/// result of &#x27;resultType&#x27;. If a conversion can not be generated, nullptr</span></span><br><span class="line">  <span class="comment">/// should be returned.</span></span><br><span class="line">  <span class="function">Operation *<span class="title">materializeCallConversion</span><span class="params">(OpBuilder &amp;builder, Value input,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       Type resultType,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       Location conversionLoc)</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.<span class="built_in">create</span>&lt;CastOp&gt;(conversionLoc, resultType, input);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="过程内shape传播"><a href="#过程内shape传播" class="headerlink" title="过程内shape传播"></a>过程内shape传播</h2><p>内联前程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">toy.func @multiply_transpose(%arg0: tensor&lt;*xf64&gt;, %arg1: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; &#123;</span><br><span class="line">  %0 = toy.transpose(%arg0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  %1 = toy.transpose(%arg1 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  %2 = toy.mul %0, %1 : tensor&lt;*xf64&gt;</span><br><span class="line">  toy.return %2 : tensor&lt;*xf64&gt;</span><br><span class="line">&#125;</span><br><span class="line">toy.func @main() &#123;</span><br><span class="line">  %0 = toy.constant dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;</span><br><span class="line">  %1 = toy.reshape(%0 : tensor&lt;2x3xf64&gt;) to tensor&lt;2x3xf64&gt;</span><br><span class="line">  %2 = toy.constant dense&lt;[1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00]&gt; : tensor&lt;6xf64&gt;</span><br><span class="line">  %3 = toy.reshape(%2 : tensor&lt;6xf64&gt;) to tensor&lt;2x3xf64&gt;</span><br><span class="line">  %4 = toy.generic_call @multiply_transpose(%1, %3) : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;</span><br><span class="line">  %5 = toy.generic_call @multiply_transpose(%3, %1) : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;</span><br><span class="line">  toy.print %5 : tensor&lt;*xf64&gt;</span><br><span class="line">  toy.return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内联后程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toy.func @main() &#123;</span><br><span class="line">  %0 = toy.constant dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;</span><br><span class="line">  %1 = toy.constant dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;</span><br><span class="line">  %2 = toy.cast %1 : tensor&lt;2x3xf64&gt; to tensor&lt;*xf64&gt;</span><br><span class="line">  %3 = toy.cast %0 : tensor&lt;2x3xf64&gt; to tensor&lt;*xf64&gt;</span><br><span class="line">  %4 = toy.transpose(%2 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  %5 = toy.transpose(%3 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;</span><br><span class="line">  %6 = toy.mul %4, %5 : tensor&lt;*xf64&gt;</span><br><span class="line">  toy.print %6 : tensor&lt;*xf64&gt;</span><br><span class="line">  toy.return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中出现了确定形状和不定形状张量类型的混合。<br>为了让代码规范，shape传播可以被实现为toy dialect专有的pass，但是这个操作也很通用。<br>将代码变换实现为通用的能够提高整个系统的可扩展性。<br>完成这个pass的核心在于需要定义一个Op，它能够根据输入的类型推断合理的输出类型。</p>
<h3 id="定义operation-interface"><a href="#定义operation-interface" class="headerlink" title="定义operation interface"></a>定义operation interface</h3><p>决定将这个Op实现为通用的组件，就需要将其实现为operation interface。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def ShapeInferenceOpInterface : OpInterface&lt;&quot;ShapeInference&quot;&gt; &#123;</span><br><span class="line">  let description = [&#123;</span><br><span class="line">    Interface to access a registered method to infer the return types for an</span><br><span class="line">    operation that can be used during type inference.</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来需要定义这个interface中的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def ShapeInferenceOpInterface : OpInterface&lt;&quot;ShapeInference&quot;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  let methods = [</span><br><span class="line">    InterfaceMethod&lt;&quot;Infer and set the output shape for the current operation.&quot;,</span><br><span class="line">                    &quot;void&quot;, &quot;inferShapes&quot;&gt;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Interface方法包括：</p>
<ul>
<li>描述信息</li>
<li>C++返回类型</li>
<li>方法名称</li>
<li><a target="_blank" rel="noopener" href="https://mlir.llvm.org/docs/Interfaces/#attributeoperationtype-interfaces">可选项</a></li>
</ul>
<p>和之前使用inliner一样，向相关的toy Op添加trait，并以C++形式实现相关方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def MulOp : Toy_Op&lt;&quot;mul&quot;,</span><br><span class="line">    [..., DeclareOpInterfaceMethods&lt;ShapeInferenceOpInterface&gt;]&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Infer the output shape of the MulOp, this is required by the shape inference</span></span><br><span class="line"><span class="comment">/// interface.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MulOp::inferShapes</span><span class="params">()</span> </span>&#123; <span class="built_in">getResult</span>().<span class="built_in">setType</span>(<span class="built_in">getLhs</span>().<span class="built_in">getType</span>()); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义pass"><a href="#定义pass" class="headerlink" title="定义pass"></a>定义pass</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeInferencePass</span></span><br><span class="line">    : <span class="keyword">public</span> mlir::PassWrapper&lt;ShapeInferencePass, OperationPass&lt;FuncOp&gt;&gt; &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">runOnOperation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    FuncOp function = <span class="built_in">getOperation</span>();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>OperationPass&lt;FuncOp&gt;</code> 表示该pass只在func上使用</li>
<li>重载 <code>runOnOperation</code></li>
</ul>
<p>创建辅助函数以实例化该pass：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;mlir::Pass&gt; mlir::toy::<span class="built_in">createShapeInferencePass</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ShapeInferencePass&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向pass manager中注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.<span class="built_in">addPass</span>(mlir::<span class="built_in">createShapeInferencePass</span>());</span><br></pre></td></tr></table></figure>

<h3 id="Shape-inference的大致实现"><a href="#Shape-inference的大致实现" class="headerlink" title="Shape inference的大致实现"></a>Shape inference的大致实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ask the operation to infer its output shapes.</span></span><br><span class="line"><span class="built_in">LLVM_DEBUG</span>(llvm::<span class="built_in">dbgs</span>() &lt;&lt; <span class="string">&quot;Inferring shape for: &quot;</span> &lt;&lt; *op &lt;&lt; <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// We check if an operation has a particular interface by casting.</span></span><br><span class="line"><span class="keyword">if</span> (ShapeInference shapeOp = <span class="built_in">dyn_cast</span>&lt;ShapeInference&gt;(op)) &#123;</span><br><span class="line">  shapeOp.<span class="built_in">inferShapes</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  op-&gt;<span class="built_in">emitError</span>(<span class="string">&quot;unable to infer shape of operation without shape &quot;</span></span><br><span class="line">                <span class="string">&quot;inference interface&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">signalPassFailure</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Chap5"><a href="#Chap5" class="headerlink" title="Chap5"></a>Chap5</h1><p>生成能够真正执行的代码需要使用LLVM，但是直接通过LLVM builder会非常麻烦，因此真正采取的方法是对MLIR代码进行部分降级，达到一个各种dialect混合的状态。</p>
<p>这一节会将toy dialect中的某些结构转换为affine dialect：专门用来表示并优化计算密集的部分；将张量转换为 <code>memref</code> 使数据对象能够在affine循环中引用。<br>这是因为tensor只表示一个数据类型，而不存在于内存中。</p>
<h2 id="Dialect转换"><a href="#Dialect转换" class="headerlink" title="Dialect转换"></a>Dialect转换</h2><p>MLIR提供了一个框架 <code>DialectConversion</code> 对不同的dialect进行转换。<br>这个框架需要以下信息：</p>
<ul>
<li>conversion target</li>
<li>rewrite pattern</li>
<li>type converter (option)</li>
</ul>
<h3 id="Conversion-target"><a href="#Conversion-target" class="headerlink" title="Conversion target"></a>Conversion target</h3><p>表示一个计算密集的部分可用的dialect有 <code>affine</code>, <code>arith</code>, <code>func</code>, <code>memref</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyToAffineLoweringPass::runOnOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The first thing to define is the conversion target. This will define the</span></span><br><span class="line">  <span class="comment">// final target for this lowering.</span></span><br><span class="line">  <span class="function">mlir::ConversionTarget <span class="title">target</span><span class="params">(getContext())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We define the specific operations, or dialects, that are legal targets for</span></span><br><span class="line">  <span class="comment">// this lowering. In our case, we are lowering to a combination of the</span></span><br><span class="line">  <span class="comment">// `Affine`, `Arith`, `Func`, and `MemRef` dialects.</span></span><br><span class="line">  target.<span class="built_in">addLegalDialect</span>&lt;affine::AffineDialect, arith::ArithDialect,</span><br><span class="line">                         func::FuncDialect, memref::MemRefDialect&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We also define the Toy dialect as Illegal so that the conversion will fail</span></span><br><span class="line">  <span class="comment">// if any of these operations are *not* converted. Given that we actually want</span></span><br><span class="line">  <span class="comment">// a partial lowering, we explicitly mark the Toy operations that don&#x27;t want</span></span><br><span class="line">  <span class="comment">// to lower, `toy.print`, as *legal*. `toy.print` will still need its operands</span></span><br><span class="line">  <span class="comment">// to be updated though (as we convert from TensorType to MemRefType), so we</span></span><br><span class="line">  <span class="comment">// only treat it as `legal` if its operands are legal.</span></span><br><span class="line">  target.<span class="built_in">addIllegalDialect</span>&lt;ToyDialect&gt;();</span><br><span class="line">  target.<span class="built_in">addDynamicallyLegalOp</span>&lt;toy::PrintOp&gt;([](toy::PrintOp op) &#123;</span><br><span class="line">    <span class="keyword">return</span> llvm::<span class="built_in">none_of</span>(op-&gt;<span class="built_in">getOperandTypes</span>(),</span><br><span class="line">                         [](Type type) &#123; <span class="keyword">return</span> type.<span class="built_in">isa</span>&lt;TensorType&gt;(); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Conversion target是保存降级后的代码的context</li>
<li>将toy dialect设置为illegal能够保证代码被完全转换；除了 <code>toy.print</code></li>
</ul>
<h3 id="Conversion-pattern"><a href="#Conversion-pattern" class="headerlink" title="Conversion pattern"></a>Conversion pattern</h3><p>定义了conversion target之后，代码降级的过程就能够被定义为从illegal dialect向legal dialect的转换。<br>相较于在dialect内优化代码的rewrite pattern，conversion pattern能够接受 <code>operands</code> 参数来处理操作数的类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Lower the `toy.transpose` operation to an affine loop nest.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TransposeOpLowering</span> : <span class="keyword">public</span> mlir::ConversionPattern &#123;</span><br><span class="line">  <span class="built_in">TransposeOpLowering</span>(mlir::MLIRContext *ctx)</span><br><span class="line">      : mlir::<span class="built_in">ConversionPattern</span>(TransposeOp::<span class="built_in">getOperationName</span>(), <span class="number">1</span>, ctx) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Match and rewrite the given `toy.transpose` operation, with the given</span></span><br><span class="line">  <span class="comment">/// operands that have been remapped from `tensor&lt;...&gt;` to `memref&lt;...&gt;`.</span></span><br><span class="line">  <span class="function">mlir::LogicalResult</span></span><br><span class="line"><span class="function">  <span class="title">matchAndRewrite</span><span class="params">(mlir::Operation *op, ArrayRef&lt;mlir::Value&gt; operands,</span></span></span><br><span class="line"><span class="params"><span class="function">                  mlir::ConversionPatternRewriter &amp;rewriter)</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> loc = op-&gt;<span class="built_in">getLoc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call to a helper function that will lower the current operation to a set</span></span><br><span class="line">    <span class="comment">// of affine loops. We provide a functor that operates on the remapped</span></span><br><span class="line">    <span class="comment">// operands, as well as the loop induction variables for the inner most</span></span><br><span class="line">    <span class="comment">// loop body.</span></span><br><span class="line">    <span class="built_in">lowerOpToLoops</span>(</span><br><span class="line">        op, operands, rewriter,</span><br><span class="line">        [loc](mlir::PatternRewriter &amp;rewriter,</span><br><span class="line">              ArrayRef&lt;mlir::Value&gt; memRefOperands,</span><br><span class="line">              ArrayRef&lt;mlir::Value&gt; loopIvs) &#123;</span><br><span class="line">          <span class="comment">// Generate an adaptor for the remapped operands of the TransposeOp.</span></span><br><span class="line">          <span class="comment">// This allows for using the nice named accessors that are generated</span></span><br><span class="line">          <span class="comment">// by the ODS. This adaptor is automatically provided by the ODS</span></span><br><span class="line">          <span class="comment">// framework.</span></span><br><span class="line">          TransposeOpAdaptor <span class="built_in">transposeAdaptor</span>(memRefOperands);</span><br><span class="line">          mlir::Value input = transposeAdaptor.<span class="built_in">input</span>();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Transpose the elements by generating a load from the reverse</span></span><br><span class="line">          <span class="comment">// indices.</span></span><br><span class="line">          SmallVector&lt;mlir::Value, <span class="number">2</span>&gt; <span class="built_in">reverseIvs</span>(llvm::<span class="built_in">reverse</span>(loopIvs));</span><br><span class="line">          <span class="keyword">return</span> rewriter.<span class="built_in">create</span>&lt;mlir::AffineLoadOp&gt;(loc, input, reverseIvs);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现后conversion pattern需要注册会conversion target中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyToAffineLoweringPass::runOnOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now that the conversion target has been defined, we just need to provide</span></span><br><span class="line">  <span class="comment">// the set of patterns that will lower the Toy operations.</span></span><br><span class="line">  <span class="function">mlir::RewritePatternSet <span class="title">patterns</span><span class="params">(&amp;getContext())</span></span>;</span><br><span class="line">  patterns.<span class="built_in">add</span>&lt;..., TransposeOpLowering&gt;(&amp;<span class="built_in">getContext</span>());</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="部分降级"><a href="#部分降级" class="headerlink" title="部分降级"></a>部分降级</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyToAffineLoweringPass::runOnOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// With the target and rewrite patterns defined, we can now attempt the</span></span><br><span class="line">  <span class="comment">// conversion. The conversion will signal failure if any of our *illegal*</span></span><br><span class="line">  <span class="comment">// operations were not converted successfully.</span></span><br><span class="line">  <span class="keyword">if</span> (mlir::<span class="built_in">failed</span>(mlir::<span class="built_in">applyPartialConversion</span>(<span class="built_in">getOperation</span>(), target, patterns)))</span><br><span class="line">    <span class="built_in">signalPassFailure</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>partialConversion</code> 是若干转换方法降级方式中的一种</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>一方面，我们将张量转换为了 <code>memref</code>；另一方面，<code>toy.print</code> 仍然以张量为参数类型。<br>两者之间需要建立某种临时的辅助保证部分降级后的代码的正确性。<br>以下几种方法都是可行的：</p>
<ul>
<li>生成 <code>load</code> 操作来实例化tensor<ul>
<li>可以不对 <code>toy.print</code> 进行修改</li>
<li>但是会影响affine的优化效果</li>
</ul>
</li>
<li>另外创建一个类似 <code>toy.print</code> 但是能接受 <code>memref</code> 为参数的Op<ul>
<li>不会引入额外的复制开销</li>
<li>但是会在dialect中引入冗余的Op</li>
</ul>
</li>
<li>更新 <code>toy.print</code> 的定义<ul>
<li>让toy dialect参与多个抽象层次，与MLIR的设计理念碰撞</li>
</ul>
</li>
</ul>
<p>从简便性考虑，教程最后采纳了第三种方案，允许 <code>toy.print</code> 接受 <code>memref</code> 作为参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def PrintOp : Toy_Op&lt;&quot;print&quot;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // The print operation takes an input tensor to print.</span><br><span class="line">  // We also allow a F64MemRef to enable interop during partial lowering.</span><br><span class="line">  let arguments = (ins AnyTypeOf&lt;[F64Tensor, F64MemRef]&gt;:$input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Chap-6"><a href="#Chap-6" class="headerlink" title="Chap 6"></a>Chap 6</h1><h2 id="降级到LLVM并生成代码"><a href="#降级到LLVM并生成代码" class="headerlink" title="降级到LLVM并生成代码"></a>降级到LLVM并生成代码</h2><p>在上一个步骤中，为了进行代码优化，我们进行了局部降级。<br>现在为了生成可执行文件，我们必须要将代码彻底降级为LLVM dialect。</p>
<h3 id="对-toy-print-降级"><a href="#对-toy-print-降级" class="headerlink" title="对 toy.print 降级"></a>对 <code>toy.print</code> 降级</h3><p>方便起见，<code>toy.print</code> 会被转换为在每个元素上调用 <code>printf</code>。<br>MLIR的转换是逐级进行的，因此不用直接映射到LLVM IR上。<br>因此我们可以先生成SCF风格的 <code>printf</code> 循环而不是LLVM IR的基本块。</p>
<h4 id="创建-printf-的函数声明"><a href="#创建-printf-的函数声明" class="headerlink" title="创建 printf 的函数声明"></a>创建 <code>printf</code> 的函数声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Return a symbol reference to the printf function, inserting it into the</span></span><br><span class="line"><span class="comment">/// module if necessary.</span></span><br><span class="line"><span class="function"><span class="type">static</span> FlatSymbolRefAttr <span class="title">getOrInsertPrintf</span><span class="params">(PatternRewriter &amp;rewriter,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           ModuleOp <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           LLVM::LLVMDialect *llvmDialect)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> *context = <span class="keyword">module</span>.<span class="built_in">getContext</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">module</span>.<span class="built_in">lookupSymbol</span>&lt;LLVM::LLVMFuncOp&gt;(<span class="string">&quot;printf&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> SymbolRefAttr::<span class="built_in">get</span>(<span class="string">&quot;printf&quot;</span>, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a function declaration for printf, the signature is:</span></span><br><span class="line">  <span class="comment">//   * `i32 (i8*, ...)`</span></span><br><span class="line">  <span class="keyword">auto</span> llvmI32Ty = IntegerType::<span class="built_in">get</span>(context, <span class="number">32</span>);</span><br><span class="line">  <span class="keyword">auto</span> llvmI8PtrTy =</span><br><span class="line">      LLVM::LLVMPointerType::<span class="built_in">get</span>(IntegerType::<span class="built_in">get</span>(context, <span class="number">8</span>));</span><br><span class="line">  <span class="keyword">auto</span> llvmFnType = LLVM::LLVMFunctionType::<span class="built_in">get</span>(llvmI32Ty, llvmI8PtrTy,</span><br><span class="line">                                                <span class="comment">/*isVarArg=*/</span><span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert the printf function into the body of the parent module.</span></span><br><span class="line">  <span class="function">PatternRewriter::InsertionGuard <span class="title">insertGuard</span><span class="params">(rewriter)</span></span>;</span><br><span class="line">  rewriter.<span class="built_in">setInsertionPointToStart</span>(<span class="keyword">module</span>.<span class="built_in">getBody</span>());</span><br><span class="line">  rewriter.<span class="built_in">create</span>&lt;LLVM::LLVMFuncOp&gt;(<span class="keyword">module</span>.<span class="built_in">getLoc</span>(), <span class="string">&quot;printf&quot;</span>, llvmFnType);</span><br><span class="line">  <span class="keyword">return</span> SymbolRefAttr::<span class="built_in">get</span>(<span class="string">&quot;printf&quot;</span>, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Conversion-target-1"><a href="#Conversion-target-1" class="headerlink" title="Conversion target"></a>Conversion target</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mlir::ConversionTarget <span class="title">target</span><span class="params">(getContext())</span></span>;</span><br><span class="line">target.<span class="built_in">addLegalDialect</span>&lt;mlir::LLVMDialect&gt;();</span><br><span class="line">target.<span class="built_in">addLegalOp</span>&lt;mlir::ModuleOp&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="Type-converter"><a href="#Type-converter" class="headerlink" title="Type converter"></a>Type converter</h4><p><code>memref</code> 需要被转换为LLVM IR能够表示的类型，而type converter能够描述类型的映射关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LLVMTypeConverter <span class="title">typeConverter</span><span class="params">(&amp;getContext())</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="Conversion-pattern-1"><a href="#Conversion-pattern-1" class="headerlink" title="Conversion pattern"></a>Conversion pattern</h4><p>在降级的过程中，整个MLIR包含以下要素：</p>
<ul>
<li><code>toy</code></li>
<li><code>affine</code></li>
<li><code>arith</code></li>
<li><code>std</code></li>
</ul>
<p>好在 <code>affine</code>，<code>arith</code> 和 <code>std</code> 都已经内置像向LLVM dialect转换的pattern：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mlir::RewritePatternSet <span class="title">patterns</span><span class="params">(&amp;getContext())</span></span>;</span><br><span class="line">mlir::<span class="built_in">populateAffineToStdConversionPatterns</span>(patterns, &amp;<span class="built_in">getContext</span>());</span><br><span class="line">mlir::cf::<span class="built_in">populateSCFToControlFlowConversionPatterns</span>(patterns, &amp;<span class="built_in">getContext</span>());</span><br><span class="line">mlir::arith::<span class="built_in">populateArithToLLVMConversionPatterns</span>(typeConverter,</span><br><span class="line">                                                        patterns);</span><br><span class="line">mlir::<span class="built_in">populateFuncToLLVMConversionPatterns</span>(typeConverter, patterns);</span><br><span class="line">mlir::cf::<span class="built_in">populateControlFlowToLLVMConversionPatterns</span>(patterns, &amp;<span class="built_in">getContext</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// The only remaining operation, to lower from the `toy` dialect, is the</span></span><br><span class="line"><span class="comment">// PrintOp.</span></span><br><span class="line">patterns.<span class="built_in">add</span>&lt;PrintOpLowering&gt;(&amp;<span class="built_in">getContext</span>());</span><br></pre></td></tr></table></figure>

<h3 id="完全降级"><a href="#完全降级" class="headerlink" title="完全降级"></a>完全降级</h3><p>与之前的部分降级相对，是另一种降级方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mlir::ModuleOp <span class="keyword">module</span> = <span class="built_in">getOperation</span>();</span><br><span class="line"><span class="keyword">if</span> (mlir::<span class="built_in">failed</span>(mlir::<span class="built_in">applyFullConversion</span>(<span class="keyword">module</span>, target, patterns)))</span><br><span class="line">  <span class="built_in">signalPassFailure</span>();</span><br></pre></td></tr></table></figure>

<h2 id="离开MLIR和代码生成"><a href="#离开MLIR和代码生成" class="headerlink" title="离开MLIR和代码生成"></a>离开MLIR和代码生成</h2><p>LLVM dialect能够直接生成LLVM IR，接下来的工作只不过是调用工具而已。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;llvm::Module&gt; llvmModule = mlir::<span class="built_in">translateModuleToLLVMIR</span>(<span class="keyword">module</span>);</span><br><span class="line"> <span class="keyword">if</span> (!llvmModule)</span><br><span class="line">   <span class="comment">/* ... an error was encountered ... */</span></span><br></pre></td></tr></table></figure>

<h3 id="设置JIT"><a href="#设置JIT" class="headerlink" title="设置JIT"></a>设置JIT</h3><p>如果直接生成LLVM IR进行静态编译，还可以设置JIT编译 <code>.mlir</code> 文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">runJit</span><span class="params">(mlir::ModuleOp <span class="keyword">module</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize LLVM targets.</span></span><br><span class="line">  llvm::<span class="built_in">InitializeNativeTarget</span>();</span><br><span class="line">  llvm::<span class="built_in">InitializeNativeTargetAsmPrinter</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An optimization pipeline to use within the execution engine.</span></span><br><span class="line">  <span class="keyword">auto</span> optPipeline = mlir::<span class="built_in">makeOptimizingTransformer</span>(</span><br><span class="line">      <span class="comment">/*optLevel=*/</span>EnableOpt ? <span class="number">3</span> : <span class="number">0</span>, <span class="comment">/*sizeLevel=*/</span><span class="number">0</span>,</span><br><span class="line">      <span class="comment">/*targetMachine=*/</span><span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an MLIR execution engine. The execution engine eagerly JIT-compiles</span></span><br><span class="line">  <span class="comment">// the module.</span></span><br><span class="line">  <span class="keyword">auto</span> maybeEngine = mlir::ExecutionEngine::<span class="built_in">create</span>(<span class="keyword">module</span>,</span><br><span class="line">      <span class="comment">/*llvmModuleBuilder=*/</span><span class="literal">nullptr</span>, optPipeline);</span><br><span class="line">  <span class="built_in">assert</span>(maybeEngine &amp;&amp; <span class="string">&quot;failed to construct an execution engine&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> &amp;engine = maybeEngine.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invoke the JIT-compiled function.</span></span><br><span class="line">  <span class="keyword">auto</span> invocationResult = engine-&gt;<span class="built_in">invoke</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (invocationResult) &#123;</span><br><span class="line">    llvm::<span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;JIT invocation failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Chap-7"><a href="#Chap-7" class="headerlink" title="Chap 7"></a>Chap 7</h1><p>本节讨论如何在MLIR中添加一个新的复合数据对象。</p>
<h2 id="Toy-lang中的语法"><a href="#Toy-lang中的语法" class="headerlink" title="Toy lang中的语法"></a>Toy lang中的语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># A struct is defined by using the `struct` keyword followed by a name.</span><br><span class="line">struct MyStruct &#123;</span><br><span class="line">  # Inside of the struct is a list of variable declarations without initializers</span><br><span class="line">  # or shapes, which may also be other previously defined structs.</span><br><span class="line">  var a;</span><br><span class="line">  var b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在MLIR中增加定义"><a href="#在MLIR中增加定义" class="headerlink" title="在MLIR中增加定义"></a>在MLIR中增加定义</h2><h3 id="定义type"><a href="#定义type" class="headerlink" title="定义type"></a>定义type</h3><h4 id="定义存储方式"><a href="#定义存储方式" class="headerlink" title="定义存储方式"></a>定义存储方式</h4><p>MLIR中的类型本质上是对 <code>TypeStorage</code> 对象的包装。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This class represents the internal storage of the Toy `StructType`.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StructTypeStorage</span> : <span class="keyword">public</span> mlir::TypeStorage &#123;</span><br><span class="line">  <span class="comment">/// The `KeyTy` is a required type that provides an interface for the storage</span></span><br><span class="line">  <span class="comment">/// instance. This type will be used when uniquing an instance of the type</span></span><br><span class="line">  <span class="comment">/// storage. For our struct type, we will unique each instance structurally on</span></span><br><span class="line">  <span class="comment">/// the elements that it contains.</span></span><br><span class="line">  <span class="keyword">using</span> KeyTy = llvm::ArrayRef&lt;mlir::Type&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// A constructor for the type storage instance.</span></span><br><span class="line">  <span class="built_in">StructTypeStorage</span>(llvm::ArrayRef&lt;mlir::Type&gt; elementTypes)</span><br><span class="line">      : <span class="built_in">elementTypes</span>(elementTypes) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Define the comparison function for the key type with the current storage</span></span><br><span class="line">  <span class="comment">/// instance. This is used when constructing a new instance to ensure that we</span></span><br><span class="line">  <span class="comment">/// haven&#x27;t already uniqued an instance of the given key.</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> KeyTy &amp;key) <span class="type">const</span> &#123; <span class="keyword">return</span> key == elementTypes; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Define a hash function for the key type. This is used when uniquing</span></span><br><span class="line">  <span class="comment">/// instances of the storage.</span></span><br><span class="line">  <span class="comment">/// Note: This method isn&#x27;t necessary as both llvm::ArrayRef and mlir::Type</span></span><br><span class="line">  <span class="comment">/// have hash functions available, so we could just omit this entirely.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> llvm::hash_code <span class="title">hashKey</span><span class="params">(<span class="type">const</span> KeyTy &amp;key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> llvm::<span class="built_in">hash_value</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Define a construction function for the key type from a set of parameters.</span></span><br><span class="line">  <span class="comment">/// These parameters will be provided when constructing the storage instance</span></span><br><span class="line">  <span class="comment">/// itself, see the `StructType::get` method further below.</span></span><br><span class="line">  <span class="comment">/// Note: This method isn&#x27;t necessary because KeyTy can be directly</span></span><br><span class="line">  <span class="comment">/// constructed with the given parameters.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> KeyTy <span class="title">getKey</span><span class="params">(llvm::ArrayRef&lt;mlir::Type&gt; elementTypes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">KeyTy</span>(elementTypes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Define a construction method for creating a new instance of this storage.</span></span><br><span class="line">  <span class="comment">/// This method takes an instance of a storage allocator, and an instance of a</span></span><br><span class="line">  <span class="comment">/// `KeyTy`. The given allocator must be used for *all* necessary dynamic</span></span><br><span class="line">  <span class="comment">/// allocations used to create the type storage and its internal.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> StructTypeStorage *<span class="title">construct</span><span class="params">(mlir::TypeStorageAllocator &amp;allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">const</span> KeyTy &amp;key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Copy the elements from the provided `KeyTy` into the allocator.</span></span><br><span class="line">    llvm::ArrayRef&lt;mlir::Type&gt; elementTypes = allocator.<span class="built_in">copyInto</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate the storage instance and construct it.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span> (allocator.<span class="built_in">allocate</span>&lt;StructTypeStorage&gt;())</span><br><span class="line">        <span class="built_in">StructTypeStorage</span>(elementTypes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The following field contains the element types of the struct.</span></span><br><span class="line">  llvm::ArrayRef&lt;mlir::Type&gt; elementTypes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h4><p>上述代码描述了类型该如何保存，而下面的定义才是真正用来交互的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This class defines the Toy struct type. It represents a collection of</span></span><br><span class="line"><span class="comment">/// element types. All derived types in MLIR must inherit from the CRTP class</span></span><br><span class="line"><span class="comment">/// &#x27;Type::TypeBase&#x27;. It takes as template parameters the concrete type</span></span><br><span class="line"><span class="comment">/// (StructType), the base class to use (Type), and the storage class</span></span><br><span class="line"><span class="comment">/// (StructTypeStorage).</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StructType</span> : <span class="keyword">public</span> mlir::Type::TypeBase&lt;StructType, mlir::Type,</span><br><span class="line">                                               StructTypeStorage&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// Inherit some necessary constructors from &#x27;TypeBase&#x27;.</span></span><br><span class="line">  <span class="keyword">using</span> Base::Base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Create an instance of a `StructType` with the given element types. There</span></span><br><span class="line">  <span class="comment">/// *must* be at least one element type.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> StructType <span class="title">get</span><span class="params">(llvm::ArrayRef&lt;mlir::Type&gt; elementTypes)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elementTypes.<span class="built_in">empty</span>() &amp;&amp; <span class="string">&quot;expected at least 1 element type&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call into a helper &#x27;get&#x27; method in &#x27;TypeBase&#x27; to get a uniqued instance</span></span><br><span class="line">    <span class="comment">// of this type. The first parameter is the context to unique in. The</span></span><br><span class="line">    <span class="comment">// parameters after are forwarded to the storage instance.</span></span><br><span class="line">    mlir::MLIRContext *ctx = elementTypes.<span class="built_in">front</span>().<span class="built_in">getContext</span>();</span><br><span class="line">    <span class="keyword">return</span> Base::<span class="built_in">get</span>(ctx, elementTypes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Returns the element types of this struct type.</span></span><br><span class="line">  <span class="function">llvm::ArrayRef&lt;mlir::Type&gt; <span class="title">getElementTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &#x27;getImpl&#x27; returns a pointer to the internal storage instance.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getImpl</span>()-&gt;elementTypes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Returns the number of element type held by this struct.</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">getNumElementTypes</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getElementTypes</span>().<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>向toy dialect注册该类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyDialect::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">addTypes</span>&lt;StructType&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="暴露在ODS中"><a href="#暴露在ODS中" class="headerlink" title="暴露在ODS中"></a>暴露在ODS中</h3><p>使用ODS添加相关定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Provide a definition for the Toy StructType for use in ODS. This allows for</span><br><span class="line">// using StructType in a similar way to Tensor or MemRef. We use `DialectType`</span><br><span class="line">// to demarcate the StructType as belonging to the Toy dialect.</span><br><span class="line">def Toy_StructType :</span><br><span class="line">    DialectType&lt;Toy_Dialect, CPred&lt;&quot;$_self.isa&lt;StructType&gt;()&quot;&gt;,</span><br><span class="line">                &quot;Toy struct type&quot;&gt;;</span><br><span class="line"></span><br><span class="line">// Provide a definition of the types that are used within the Toy dialect.</span><br><span class="line">def Toy_Type : AnyTypeOf&lt;[F64Tensor, Toy_StructType]&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="定义解析方式"><a href="#定义解析方式" class="headerlink" title="定义解析方式"></a>定义解析方式</h3><p>为了解析 <code>StructType</code>，需要在 <code>ToyDialect</code> 中添加解析方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ToyDialect</span> : <span class="keyword">public</span> mlir::Dialect &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// Parse an instance of a type registered to the toy dialect.</span></span><br><span class="line">  <span class="function">mlir::Type <span class="title">parseType</span><span class="params">(mlir::DialectAsmParser &amp;parser)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Print an instance of a type registered to the toy dialect.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printType</span><span class="params">(mlir::Type type,</span></span></span><br><span class="line"><span class="params"><span class="function">                 mlir::DialectAsmPrinter &amp;printer)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在实现上，我们需要给出正式的ODS语法：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct-type ::= `struct` `&lt;` type (`,` type)* `&gt;`</span><br></pre></td></tr></table></figure>

<p>根据语法实现parser和printer：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Parse an instance of a type registered to the toy dialect.</span></span><br><span class="line"><span class="function">mlir::Type <span class="title">ToyDialect::parseType</span><span class="params">(mlir::DialectAsmParser &amp;parser)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Parse a struct type in the following form:</span></span><br><span class="line">  <span class="comment">//   struct-type ::= `struct` `&lt;` type (`,` type)* `&gt;`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> All MLIR parser function return a ParseResult. This is a</span></span><br><span class="line">  <span class="comment">// specialization of LogicalResult that auto-converts to a `true` boolean</span></span><br><span class="line">  <span class="comment">// value on failure to allow for chaining, but may be used with explicit</span></span><br><span class="line">  <span class="comment">// `mlir::failed/mlir::succeeded` as desired.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse: `struct` `&lt;`</span></span><br><span class="line">  <span class="keyword">if</span> (parser.<span class="built_in">parseKeyword</span>(<span class="string">&quot;struct&quot;</span>) || parser.<span class="built_in">parseLess</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Type</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the element types of the struct.</span></span><br><span class="line">  SmallVector&lt;mlir::Type, <span class="number">1</span>&gt; elementTypes;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// Parse the current element type.</span></span><br><span class="line">    SMLoc typeLoc = parser.<span class="built_in">getCurrentLocation</span>();</span><br><span class="line">    mlir::Type elementType;</span><br><span class="line">    <span class="keyword">if</span> (parser.<span class="built_in">parseType</span>(elementType))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the type is either a TensorType or another StructType.</span></span><br><span class="line">    <span class="keyword">if</span> (!elementType.<span class="built_in">isa</span>&lt;mlir::TensorType, StructType&gt;()) &#123;</span><br><span class="line">      parser.<span class="built_in">emitError</span>(typeLoc, <span class="string">&quot;element type for a struct must either &quot;</span></span><br><span class="line">                                <span class="string">&quot;be a TensorType or a StructType, got: &quot;</span>)</span><br><span class="line">          &lt;&lt; elementType;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    elementTypes.<span class="built_in">push_back</span>(elementType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the optional: `,`</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">succeeded</span>(parser.<span class="built_in">parseOptionalComma</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse: `&gt;`</span></span><br><span class="line">  <span class="keyword">if</span> (parser.<span class="built_in">parseGreater</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Type</span>();</span><br><span class="line">  <span class="keyword">return</span> StructType::<span class="built_in">get</span>(elementTypes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Print an instance of a type registered to the toy dialect.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToyDialect::printType</span><span class="params">(mlir::Type type,</span></span></span><br><span class="line"><span class="params"><span class="function">                           mlir::DialectAsmPrinter &amp;printer)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Currently the only toy type is a struct type.</span></span><br><span class="line">  StructType structType = type.<span class="built_in">cast</span>&lt;StructType&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print the struct type according to the parser format.</span></span><br><span class="line">  printer &lt;&lt; <span class="string">&quot;struct&lt;&quot;</span>;</span><br><span class="line">  llvm::<span class="built_in">interleaveComma</span>(structType.<span class="built_in">getElementTypes</span>(), printer);</span><br><span class="line">  printer &lt;&lt; <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加使用-StructType-的Op"><a href="#添加使用-StructType-的Op" class="headerlink" title="添加使用 StructType 的Op"></a>添加使用 <code>StructType</code> 的Op</h2><h3 id="更新既有的Op"><a href="#更新既有的Op" class="headerlink" title="更新既有的Op"></a>更新既有的Op</h3><p>如 <code>ReterunOp</code> 需要添加对 <code>StructType</code> 的支持：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def ReturnOp : Toy_Op&lt;&quot;return&quot;, [Terminator, HasParent&lt;&quot;FuncOp&quot;&gt;]&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  let arguments = (ins Variadic&lt;Toy_Type&gt;:$input);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现新的Op"><a href="#实现新的Op" class="headerlink" title="实现新的Op"></a>实现新的Op</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%0 = toy.struct_constant [</span><br><span class="line">  dense&lt;[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]&gt; : tensor&lt;2x3xf64&gt;</span><br><span class="line">] : !toy.struct&lt;tensor&lt;*xf64&gt;&gt;</span><br><span class="line"></span><br><span class="line">%1 = toy.struct_access %0[0] : !toy.struct&lt;tensor&lt;*xf64&gt;&gt; -&gt; tensor&lt;*xf64&gt;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-03T13:17:23.000Z" title="2024/1/3 21:17:23">2024-01-03</time>发表</span><span class="level-item"><time dateTime="2024-03-01T07:13:23.261Z" title="2024/3/1 15:13:23">2024-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/MLIR/">MLIR</a></span><span class="level-item">5 分钟读完 (大约734个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/03/MLIR/999_%E6%9D%82%E8%B0%88/">MLIR杂谈</a></p><div class="content"><h1 id="MLIR-custom-operation-BNF和-mlir-OpBuilder-create-的关系"><a href="#MLIR-custom-operation-BNF和-mlir-OpBuilder-create-的关系" class="headerlink" title="MLIR custom operation BNF和 mlir::OpBuilder::create 的关系"></a>MLIR custom operation BNF和 <code>mlir::OpBuilder::create</code> 的关系</h1><p>在 <code>OpBuilder::create</code> 中，MLIR提供了三种重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Operation *<span class="title">OpBuilder::create</span><span class="params">(<span class="type">const</span> OperationState &amp;state)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">insert</span>(Operation::<span class="built_in">create</span>(state));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Operation *<span class="title">OpBuilder::create</span><span class="params">(Location loc, StringAttr opName,</span></span></span><br><span class="line"><span class="params"><span class="function">                             ValueRange operands, TypeRange types,</span></span></span><br><span class="line"><span class="params"><span class="function">                             ArrayRef&lt;NamedAttribute&gt; attributes,</span></span></span><br><span class="line"><span class="params"><span class="function">                             BlockRange successors,</span></span></span><br><span class="line"><span class="params"><span class="function">                             MutableArrayRef&lt;std::unique_ptr&lt;Region&gt;&gt; regions)</span> </span>&#123;</span><br><span class="line">  <span class="function">OperationState <span class="title">state</span><span class="params">(loc, opName, operands, types, </span></span></span><br><span class="line"><span class="params"><span class="function">                       attributes, successors, regions)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">create</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OpTy, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">OpTy <span class="title">create</span><span class="params">(Location location, Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">  <span class="function">OperationState <span class="title">state</span><span class="params">(location,</span></span></span><br><span class="line"><span class="params"><span class="function">                        getCheckRegisteredInfo&lt;OpTy&gt;(location.getContext()))</span></span>;</span><br><span class="line">  OpTy::<span class="built_in">build</span>(*<span class="keyword">this</span>, state, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  <span class="keyword">auto</span> *op = <span class="built_in">create</span>(state);</span><br><span class="line">  <span class="keyword">auto</span> result = <span class="built_in">dyn_cast</span>&lt;OpTy&gt;(op);</span><br><span class="line">  <span class="built_in">assert</span>(result &amp;&amp; <span class="string">&quot;builder didn&#x27;t return the right type&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>目前在github搜索到使用OpBuilder构建Op的代码中，第三种 <code>create</code> 是用的最多的。<br>但是这里使用了工厂模式+完美转发让代码补全无法提示到底需要哪些参数，这时候就需要自己去对应Op的 <code>build</code> 方法中去找了。</p>
<p>但是每个参数的含义还是要根据BNF去找 (以custom Op为准)。<br>比如在 <code>arith::ConstOp</code> 里面，我一开始不太清楚哪个 <code>Attr</code> 到底是什么玩意，打开BNF才知道那是常量在MLIR中以attribute的形式存在。</p>
<h1 id="编写MLIR代码用于测试"><a href="#编写MLIR代码用于测试" class="headerlink" title="编写MLIR代码用于测试"></a>编写MLIR代码用于测试</h1><p>MLIR本身并不是一种语言，而是一种编译设施。<br>因此，文档中大多在描述你该如何定义自己的dialect、如何对代码进行转换，而不会像一般的编译语言一样从类型到控制指令那样逐步教你使用。<br>另一方面，虽然MLIR为里面有的dialect提供了文档，但是确定编写一份样例中需要使用哪些dialect也是一件很麻烦的事情——因为选项实在太多了。</p>
<h1 id="MLIR-Op和C-CRTP"><a href="#MLIR-Op和C-CRTP" class="headerlink" title="MLIR Op和C++ CRTP"></a>MLIR Op和C++ CRTP</h1><p>CRTP (Curiously recurring template pattern) 是C++中的一种编程技巧，用于提供静态多态的能力。<br>该技术的大致模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : Base&lt;Drived&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>在C++中定义Op时也会用到这种技巧，其体现为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstantOp</span> : <span class="keyword">public</span> mlir::Op&lt;ConstantOp, ... &gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>这种模式的使用对于提高MLIR框架的性能比较有帮助。</p>
<h1 id="Op-和-Operation"><a href="#Op-和-Operation" class="headerlink" title="Op 和 Operation"></a><code>Op</code> 和 <code>Operation</code></h1><p>MLIR的C++接口中提供了 <code>Op</code> 和 <code>Operation</code> 两种相关的类。</p>
<p>从语法上讲，<code>Operation</code> 对应于generic Op，并不会用来直接描述某个具体的Op；<code>Op</code> 对应于MLIR语法中的custom Op，能够很方便地定义Op，所以定义Op时全是从 <code>Op</code> 继承。</p>
<p>从C++实现上讲，<code>Op</code> 的派生类很像是 <code>Operation *</code> 类型的智能指针，能够进行动态类型转换，但是更加便于使用，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processConstantOp</span><span class="params">(mlir::Operation *operation)</span> </span>&#123;</span><br><span class="line">  ConstantOp op = llvm::<span class="built_in">dyn_cast</span>&lt;ConstantOp&gt;(operation);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This operation is not an instance of `ConstantOp`.</span></span><br><span class="line">  <span class="keyword">if</span> (!op)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the internal operation instance wrapped by the smart pointer.</span></span><br><span class="line">  mlir::Operation *internalOperation = op.<span class="built_in">getOperation</span>();</span><br><span class="line">  <span class="built_in">assert</span>(internalOperation == operation &amp;&amp;</span><br><span class="line">         <span class="string">&quot;these operation instances are the same&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Round-trip"><a href="#Round-trip" class="headerlink" title="Round-trip"></a>Round-trip</h1><p>Round-trip描述的是src-&gt;target-&gt;src的过程，主要用于调试自定义的MLIR是否对源代码进行了正确的建模。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-02T05:25:46.000Z" title="2024/1/2 13:25:46">2024-01-02</time>发表</span><span class="level-item"><time dateTime="2024-03-01T07:13:23.259Z" title="2024/3/1 15:13:23">2024-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/MLIR/">MLIR</a></span><span class="level-item">17 分钟读完 (大约2532个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/02/MLIR/1_Basics/">MLIR Basic Concepts</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MLIR可以被视为一个数据流图，其中的节点被称为operation，边被称为value。<br>Operation包含于block，而block又被包含于region。<br>不过operation本身又能够包含region，如定义函数的operation。<br>这样形成了一个层次化的结构。</p>
<p>本教程自底向上地介绍MLIR的搭建过程，按照从Op-&gt;Block-&gt;Function-&gt;Module的顺序介绍语法及在代码中会使用到的工具。</p>
<p>相关概念都能够在<a target="_blank" rel="noopener" href="https://mlir.llvm.org/docs/LangRef/">MLIR LangRef</a>中找到最权威的解释。<br>关于环境搭建可以参考<a target="_blank" rel="noopener" href="https://github.com/KEKE046/mlir-tutorial">这篇文档</a>。</p>
<h1 id="Operation-a-k-a-Op"><a href="#Operation-a-k-a-Op" class="headerlink" title="Operation (a.k.a. Op)"></a>Operation (a.k.a. Op)</h1><blockquote>
<p>In MLIR, everything is about Operations, not Instructions: we put the emphasis to distinguish from the LLVM view. </p>
</blockquote>
<h2 id="文法结构"><a href="#文法结构" class="headerlink" title="文法结构"></a>文法结构</h2><p>Op的EBNF语法如下所示：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">operation             ::= op-result-list? (generic-operation | custom-operation)</span><br><span class="line">                          trailing-location?</span><br><span class="line">generic-operation     ::= string-literal `(` value-use-list? `)`  successor-list?</span><br><span class="line">                          dictionary-properties? region-list? dictionary-attribute?</span><br><span class="line">                          `:` function-type</span><br><span class="line">custom-operation      ::= bare-id custom-operation-format</span><br><span class="line">op-result-list        ::= op-result (`,` op-result)* `=`</span><br><span class="line">op-result             ::= value-id (`:` integer-literal)?</span><br><span class="line">successor-list        ::= `[` successor (`,` successor)* `]`</span><br><span class="line">successor             ::= caret-id (`:` block-arg-list)?</span><br><span class="line">dictionary-properties ::= `&lt;` dictionary-attribute `&gt;`</span><br><span class="line">region-list           ::= `(` region (`,` region)* `)`</span><br><span class="line">dictionary-attribute  ::= `&#123;` (attribute-entry (`,` attribute-entry)*)? `&#125;`</span><br><span class="line">trailing-location     ::= `loc` `(` location `)`</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%res:2 = mydialect.morph(%arg0#3) </span><br><span class="line">         &#123; some.attribute = true, other_attribute = 1.5 &#125; :</span><br><span class="line">         (!mydialect&lt;&quot;custom_type&quot;&gt;) -&gt; </span><br><span class="line">         (!mydialect&lt;&quot;other_type&quot;&gt;, !mydialect&lt;&quot;other_type&quot;&gt;)</span><br><span class="line">         loc(callsite(&quot;foo&quot; at &quot;mysource.cc&quot;:10:8))</span><br></pre></td></tr></table></figure>

<p>从语法角度来说：</p>
<ul>
<li><code>%res:2 =</code> 对应了 <code>op-result-list</code></li>
<li><code>mydialect.morph ... -&gt; ...</code> 对应了 <code>generic-operation</code></li>
<li><code>loc(...)</code> 对应了 <code>trailing-location</code></li>
</ul>
<p>从含义角度来说：</p>
<ul>
<li><code>%res:2</code>：Op的计算结果，2表示返回值的数量</li>
<li><code>mydialect.morph</code>：方言及内部的操作</li>
<li><code>(%arg0#3) &#123; some.attribute = true, other_attribute = 1.5 &#125;</code>：参数、属性</li>
<li><code>(!mydialect&lt;&quot;custom_type&quot;&gt;) -&gt; (!mydialect&lt;&quot;other_type&quot;&gt;, !mydialect&lt;&quot;other_type&quot;&gt;)</code>：函数签名类型 (语法结构中的function-type)</li>
<li><code>loc(callsite(&quot;foo&quot; at &quot;mysource.cc&quot;:10:8))</code>：位置信息</li>
</ul>
<p>虽然文档中给出的generic Op语法如此复杂，但是custom Op却会简单很多，如 <code>arith.addi</code>：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operation ::= `arith.addi` $lhs `,` $rhs attr-dict `:` type($result)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%c = arith.addi %a, %b : i32</span><br></pre></td></tr></table></figure>

<p>从custom Op转换为generic Op可以使用工具 <code>mlir-opt --mlir-print-op-generic</code> 进行转换。</p>
<p>接下来需要弄清楚的概念来自于 <code>generatic-operation</code>：</p>
<ul>
<li>固有属性 (property)</li>
<li>可变属性 (attribute)</li>
</ul>
<h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2><p>Property是直接保存在operation class内的额外数据成员，包含了某些语义并能通过interface accessor等方法暴露给其余Op。</p>
<p>Property和inherent attribute息息相关，这是因为property有专门的存储区域。</p>
<p>Property能够被序列化为attribute来打印出来。</p>
<h2 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dictionary-attribute  ::= `&#123;` (attribute-entry (`,` attribute-entry)*)? `&#125;`</span><br><span class="line">attribute-entry ::= (bare-id | string-literal) `=` attribute-value</span><br><span class="line">attribute-value ::= attribute-alias | dialect-attribute | builtin-attribute</span><br><span class="line">attribute-alias-def ::= `#` alias-name `=` attribute-value</span><br><span class="line">attribute-alias ::= `#` alias-name</span><br></pre></td></tr></table></figure>

<p>Attribute为Op提供了除了保存value本身以外信息的机制，从而进行高层次的分析。<br>另一方面，Op的结果——value——并不能够保存常量 (编译时已知的量)，所以常量值必须以attribute的形式保存。<br>这在 <code>arith.ConstOp</code> 中可见一斑：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operation ::= `arith.constant` attr-dict $value</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%a = arith.constant 4: i32</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>4 : i32</code> 共同构成了 <code>$value</code>。</p>
</blockquote>
<p>Attribute能够为分为两类：</p>
<ul>
<li>Inherent attribute：存在于Op的定义中，它们的名字中不会带有dialect前缀；保存在property storage中</li>
<li>Discardable attribute：名字中带有dialect前缀；保存在top-level dictionary中</li>
</ul>
<h3 id="Type和attribute"><a href="#Type和attribute" class="headerlink" title="Type和attribute"></a>Type和attribute</h3><p>因为Op分为custom和generic两类，所以在这样的两套系统下type和attribute的边界变得模糊。<br>下列例子中，我们使用 <code>mlir-opt</code> 将custom Op向generic Op转换，函数的type变成了property被保存在了Op中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func.func @test(%a: i32, %b: i32) -&gt; i32 &#123;</span><br><span class="line">  %c = arith.addi %a, %b : i32</span><br><span class="line">  func.return %c : i32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;builtin.module&quot;() (&#123;</span><br><span class="line">  &quot;func.func&quot;() &lt;&#123;function_type = (i32, i32) -&gt; i32, sym_name = &quot;test&quot;&#125;&gt; (&#123;</span><br><span class="line">  ^bb0(%arg0: i32, %arg1: i32):</span><br><span class="line">    %0 = &quot;arith.addi&quot;(%arg0, %arg1) : (i32, i32) -&gt; i32</span><br><span class="line">    &quot;func.return&quot;(%0) : (i32) -&gt; ()</span><br><span class="line">  &#125;) : () -&gt; ()</span><br><span class="line">&#125;) : () -&gt; ()</span><br></pre></td></tr></table></figure>

<h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p>和LLVM IR类似，MLIR提供了builder来获取类型和attribute、构建Op。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mlir/IR/Builders.h&gt;</span>            <span class="comment">// for OpBuilder</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mlir/IR/MLIRContext.h&gt;</span>         <span class="comment">// for MLIRContext</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mlir/Dialect/Arith/IR/Arith.h&gt;</span> <span class="comment">// for addi</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mlir::MLIRContext ctx;</span><br><span class="line">  ctx.<span class="built_in">loadDialect</span>&lt;mlir::arith::ArithDialect&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function">mlir::OpBuilder <span class="title">builder</span><span class="params">(&amp;ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> a = builder.<span class="built_in">create</span>&lt;arith::ConstantOp&gt;(builder.<span class="built_in">getUnknownLoc</span>(), i32, builder.<span class="built_in">getI32IntegerAttr</span>(<span class="number">4</span>));</span><br><span class="line">  <span class="keyword">auto</span> b = builder.<span class="built_in">create</span>&lt;arith::ConstantOp&gt;(builder.<span class="built_in">getUnknownLoc</span>(), i32, builder.<span class="built_in">getI32IntegerAttr</span>(<span class="number">2</span>));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> addi = builder.<span class="built_in">create</span>&lt;arith::AddIOp&gt;(builder.<span class="built_in">getUnknownLoc</span>(), a.<span class="built_in">getResult</span>(), b.<span class="built_in">getResult</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Context</code> 包含了大量的辅助数据结构，在Moudle中使用到的dialect需要注册在里面</li>
<li><code>OpBuilder</code> 依赖与 <code>Context</code> 存在</li>
<li>常量值在MLIR中以attribute的形式存在，所以这里创建常量时以attribute的形式传入值</li>
<li>如果不想再Op中加入位置信息，使用 <code>builder.getUnknownLoc()</code> 来缺省位置信息，这个信息仅用于调试，而非指定Op插入的位置</li>
<li>Op外面是block，block外面是function，function外面是module，没有外面的层次就无法确定 <code>builder</code> 插入Op的为主，因此这里仅仅是创建了指令，并没有真正插入MLIR中</li>
<li>Result是Op中作为出边的value</li>
</ul>
<blockquote>
<p>所有编译期常量都是用 <code>getXXX</code> 创建，反之则是 <code>create</code>。</p>
</blockquote>
<h1 id="Type-system"><a href="#Type-system" class="headerlink" title="Type system"></a>Type system</h1><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">type ::= type-alias | dialect-type | builtin-type</span><br><span class="line"></span><br><span class="line">type-list-no-parens ::=  type (`,` type)*</span><br><span class="line">type-list-parens ::= `(` `)`</span><br><span class="line">                   | `(` type-list-no-parens `)`</span><br><span class="line"></span><br><span class="line">// This is a common way to refer to a value with a specified type.</span><br><span class="line">ssa-use-and-type ::= ssa-use `:` type</span><br><span class="line">ssa-use ::= value-use</span><br><span class="line"></span><br><span class="line">// Non-empty list of names and types.</span><br><span class="line">ssa-use-and-type-list ::= ssa-use-and-type (`,` ssa-use-and-type)*</span><br><span class="line"></span><br><span class="line">function-type ::= (type | type-list-parens) `-&gt;` (type | type-list-parens)</span><br><span class="line"></span><br><span class="line">// type alias</span><br><span class="line">type-alias-def ::= `!` alias-name `=` type</span><br><span class="line">type-alias ::= `!` alias-name</span><br><span class="line"></span><br><span class="line">// dialect type</span><br><span class="line">dialect-namespace ::= bare-id</span><br><span class="line"></span><br><span class="line">dialect-type ::= `!` (opaque-dialect-type | pretty-dialect-type)</span><br><span class="line">opaque-dialect-type ::= dialect-namespace dialect-type-body</span><br><span class="line">pretty-dialect-type ::= dialect-namespace `.` pretty-dialect-type-lead-ident</span><br><span class="line">                                              dialect-type-body?</span><br><span class="line">pretty-dialect-type-lead-ident ::= `[A-Za-z][A-Za-z0-9._]*`</span><br><span class="line"></span><br><span class="line">dialect-type-body ::= `&lt;` dialect-type-contents+ `&gt;`</span><br><span class="line">dialect-type-contents ::= dialect-type-body</span><br><span class="line">                            | `(` dialect-type-contents+ `)`</span><br><span class="line">                            | `[` dialect-type-contents+ `]`</span><br><span class="line">                            | `&#123;` dialect-type-contents+ `&#125;`</span><br><span class="line">                            | [^\[<span class="attribute">&lt;(&#123;\]&gt;</span>)&#125;\0]+</span><br></pre></td></tr></table></figure>

<p>Builtin type全部定义在builtin dialect中，参考<a target="_blank" rel="noopener" href="https://mlir.llvm.org/docs/Dialects/Builtin/">文档</a>。</p>
<h2 id="Type-alias"><a href="#Type-alias" class="headerlink" title="Type alias"></a>Type alias</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">!avx_m128 = vector&lt;4 x f32&gt;</span><br><span class="line"></span><br><span class="line">// Using the original type.</span><br><span class="line">&quot;foo&quot;(%x) : vector&lt;4 x f32&gt; -&gt; ()</span><br><span class="line"></span><br><span class="line">// Using the type alias.</span><br><span class="line">&quot;foo&quot;(%x) : !avx_m128 -&gt; ()</span><br></pre></td></tr></table></figure>

<p><code>!</code> 开头的就是类型别名。</p>
<h2 id="Dialect-type"><a href="#Dialect-type" class="headerlink" title="Dialect type"></a>Dialect type</h2><h3 id="Opaque-form"><a href="#Opaque-form" class="headerlink" title="Opaque form"></a>Opaque form</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// A tensorflow string type.</span><br><span class="line">!tf&lt;string&gt;</span><br><span class="line"></span><br><span class="line">// A type with complex components.</span><br><span class="line">!foo&lt;something&lt;abcd&gt;&gt;</span><br><span class="line"></span><br><span class="line">// An even more complex type.</span><br><span class="line">!foo&lt;&quot;a123^^^&quot; + bar&gt;</span><br></pre></td></tr></table></figure>

<p><code>!dialect&lt;type&gt;</code> 表示位于 <code>dialect</code> 名称空间内的类型。</p>
<h3 id="Pretty-form"><a href="#Pretty-form" class="headerlink" title="Pretty form"></a>Pretty form</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// A tensorflow string type.</span><br><span class="line">!tf.string</span><br><span class="line"></span><br><span class="line">// A type with complex components.</span><br><span class="line">!foo.something&lt;abcd&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h1><h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p>Block是一个Op列表。<br>与SSA中的基本块类似，MLIR block在大部分情况下以控制流转移指令作为结束。<br>基本块位于MLIR region中，这是传统SSA中间表示中没有的形式。<br>利用region，MLIR取消了phi节点而使用块参数来传递值。</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">block           ::= block-label operation+</span><br><span class="line">block-label     ::= block-id block-arg-list? `:`</span><br><span class="line">block-id        ::= caret-id</span><br><span class="line">caret-id        ::= `^` suffix-id</span><br><span class="line">value-id-and-type ::= value-id `:` type</span><br><span class="line"></span><br><span class="line">// Non-empty list of names and types.</span><br><span class="line">value-id-and-type-list ::= value-id-and-type (`,` value-id-and-type)*</span><br><span class="line"></span><br><span class="line">block-arg-list ::= `(` value-id-and-type-list? `)`</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func.func @simple(i64, i1) -&gt; i64 &#123;</span><br><span class="line">^bb0(%a: i64, %cond: i1): // Code dominated by ^bb0 may refer to %a</span><br><span class="line">  cf.cond_br %cond, ^bb1, ^bb2</span><br><span class="line"></span><br><span class="line">^bb1:</span><br><span class="line">  cf.br ^bb3(%a: i64)    // Branch passes %a as the argument</span><br><span class="line"></span><br><span class="line">^bb2:</span><br><span class="line">  %b = arith.addi %a, %a : i64</span><br><span class="line">  cf.br ^bb3(%b: i64)    // Branch passes %b as the argument</span><br><span class="line"></span><br><span class="line">// ^bb3 receives an argument, named %c, from predecessors</span><br><span class="line">// and passes it on to bb4 along with %a. %a is referenced</span><br><span class="line">// directly from its defining operation and is not passed through</span><br><span class="line">// an argument of ^bb3.</span><br><span class="line">^bb3(%c: i64):</span><br><span class="line">  cf.br ^bb4(%c, %a : i64, i64)</span><br><span class="line"></span><br><span class="line">^bb4(%d : i64, %e : i64):</span><br><span class="line">  %0 = arith.addi %d, %e : i64</span><br><span class="line">  return %0 : i64   // Return is also a terminator.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Block和Op的区别"><a href="#Block和Op的区别" class="headerlink" title="Block和Op的区别"></a>Block和Op的区别</h3><p>在Op内定义的value在Op外时无法访问的；所以block是不能用Op表示的概念。</p>
<h2 id="Region-1"><a href="#Region-1" class="headerlink" title="Region"></a>Region</h2><p>Region是由block构成的有序列表。<br>MLIR中内置了两种region：</p>
<ul>
<li>SSA CFG region：描述block间的控制流</li>
<li>Graph region：节点间不一定存在控制流的关系</li>
</ul>
<p>Region和block不一样，它没有名字或者地址，需要依附于Op存在，如 <code>func.func</code>，且自身没有type或者attribute。</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">region      ::= `&#123;` entry-block? block* `&#125;`</span><br><span class="line">entry-block ::= operation+</span><br></pre></td></tr></table></figure>

<p>一个entry block是一个没有label和参数的block，通常用于打开一个新的作用域出现在一个region开头的位置。</p>
<h3 id="值的作用域"><a href="#值的作用域" class="headerlink" title="值的作用域"></a>值的作用域</h3><p>给定region，其内部定义的值仅在这个region内可见；其外部定义的值仅能在这个值作为参数传入创建这个region的Op时才可用。</p>
<h3 id="控制流和SSA-CFG-region"><a href="#控制流和SSA-CFG-region" class="headerlink" title="控制流和SSA CFG region"></a>控制流和SSA CFG region</h3><p>在C++形式中，其所属的接口为 <code>RegionKind::SSACFG</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func.func @accelerator_compute(i64, i1) -&gt; i64 &#123; // An SSACFG region</span><br><span class="line">^bb0(%a: i64, %cond: i1): // Code dominated by ^bb0 may refer to %a</span><br><span class="line">  cf.cond_br %cond, ^bb1, ^bb2</span><br><span class="line"></span><br><span class="line">^bb1:</span><br><span class="line">  // This def for %value does not dominate ^bb2</span><br><span class="line">  %value = &quot;op.convert&quot;(%a) : (i64) -&gt; i64</span><br><span class="line">  cf.br ^bb3(%a: i64)    // Branch passes %a as the argument</span><br><span class="line"></span><br><span class="line">^bb2:</span><br><span class="line">  accelerator.launch() &#123; // An SSACFG region</span><br><span class="line">    ^bb0:</span><br><span class="line">      // Region of code nested under &quot;accelerator.launch&quot;, it can reference %a but</span><br><span class="line">      // not %value.</span><br><span class="line">      %new_value = &quot;accelerator.do_something&quot;(%a) : (i64) -&gt; ()</span><br><span class="line">  &#125;</span><br><span class="line">  // %new_value cannot be referenced outside of the region</span><br><span class="line"></span><br><span class="line">^bb3:</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="包含多个region的Op"><a href="#包含多个region的Op" class="headerlink" title="包含多个region的Op"></a>包含多个region的Op</h4><p>执行一条包含region的Op时，控制流会转移到它的region上；当这个region结束时，控制流会重新回到这条Op上。<br>如果这个Op有多个region，那么控制流会继续转移到下一个region上。</p>
<h3 id="Graph-region"><a href="#Graph-region" class="headerlink" title="Graph region"></a>Graph region</h3><p>其C++中的接口为 <code>RegionKind::Graph</code>。</p>
<p>Graph region在表达不需要控制流的并发语义时十分有用，还能用来建立有向图。<br>其主要应用场景包括表示彼此独立的线程。<br>因此，graph region中Op和block的顺序并没有意义。</p>
<blockquote>
<p>目前一个graph region中只能包含一个基本块。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;test.graph_region&quot;() (&#123; // A Graph region</span><br><span class="line">  %1 = &quot;op1&quot;(%1, %3) : (i32, i32) -&gt; (i32)  // OK: %1, %3 allowed here</span><br><span class="line">  %2 = &quot;test.ssacfg_region&quot;() (&#123;</span><br><span class="line">     %5 = &quot;op2&quot;(%1, %2, %3, %4) : (i32, i32, i32, i32) -&gt; (i32) // OK: %1, %2, %3, %4 all defined in the containing region</span><br><span class="line">  &#125;) : () -&gt; (i32)</span><br><span class="line">  %3 = &quot;op2&quot;(%1, %4) : (i32, i32) -&gt; (i32)  // OK: %4 allowed here</span><br><span class="line">  %4 = &quot;op3&quot;(%1) : (i32) -&gt; (i32)</span><br><span class="line">&#125;) : () -&gt; ()</span><br></pre></td></tr></table></figure>

<h2 id="C-interface"><a href="#C-interface" class="headerlink" title="C++ interface"></a>C++ interface</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mlir/IR/AsmState.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mlir/IR/Builders.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mlir/IR/BuiltinOps.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mlir/IR/MLIRContext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mlir/IR/ValueRange.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mlir/Parser/Parser.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mlir/Support/FileUtilities.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mlir/Dialect/Func/IR/FuncOps.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mlir/Dialect/Arith/IR/Arith.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;llvm/Support/raw_ostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> mlir;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  MLIRContext ctx;</span><br><span class="line">  ctx.<span class="built_in">loadDialect</span>&lt;func::FuncDialect, arith::ArithDialect&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function">OpBuilder <span class="title">builder</span><span class="params">(&amp;ctx)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">module</span> = builder.<span class="built_in">create</span>&lt;ModuleOp&gt;(builder.<span class="built_in">getUnknownLoc</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set insert point for builder</span></span><br><span class="line">  builder.<span class="built_in">setInsertionPointToEnd</span>(<span class="keyword">module</span>.<span class="built_in">getBody</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create a func</span></span><br><span class="line">  <span class="keyword">auto</span> i32 = builder.<span class="built_in">getI32Type</span>();</span><br><span class="line">  <span class="keyword">auto</span> funcType = builder.<span class="built_in">getFunctionType</span>(&#123;i32, i32&#125;, &#123;i32&#125;);</span><br><span class="line">  <span class="keyword">auto</span> func = builder.<span class="built_in">create</span>&lt;func::FuncOp&gt;(builder.<span class="built_in">getUnknownLoc</span>(), <span class="string">&quot;foo&quot;</span>, funcType);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create basic blocks</span></span><br><span class="line">  <span class="keyword">auto</span> entry = func.<span class="built_in">addEntryBlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set insert point</span></span><br><span class="line">  builder.<span class="built_in">setInsertionPointToEnd</span>(entry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create constant as argumengts of addi</span></span><br><span class="line">  <span class="keyword">auto</span> a = builder.<span class="built_in">create</span>&lt;arith::ConstantOp&gt;(builder.<span class="built_in">getUnknownLoc</span>(), i32, builder.<span class="built_in">getI32IntegerAttr</span>(<span class="number">4</span>));</span><br><span class="line">  <span class="keyword">auto</span> b = builder.<span class="built_in">create</span>&lt;arith::ConstantOp&gt;(builder.<span class="built_in">getUnknownLoc</span>(), i32, builder.<span class="built_in">getI32IntegerAttr</span>(<span class="number">2</span>));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> addi = builder.<span class="built_in">create</span>&lt;arith::AddIOp&gt;(builder.<span class="built_in">getUnknownLoc</span>(), a.<span class="built_in">getResult</span>(), b.<span class="built_in">getResult</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create ret to leave the func</span></span><br><span class="line">  builder.<span class="built_in">create</span>&lt;func::ReturnOp&gt;(builder.<span class="built_in">getUnknownLoc</span>(), <span class="built_in">ValueRange</span>(&#123;addi&#125;));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">module</span>.<span class="built_in">print</span>(llvm::<span class="built_in">outs</span>());</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Module在IR中是个特殊的Op，由 <code>ModuleOp</code> 定义，所以需要用到 <code>builder</code></li>
<li><code>builder.setInsertionPointToEnd(module.getBody())</code> 初始化指令插入的位置，否则 <code>builder</code> 不会插入指令</li>
<li><code>func.func</code> Op定义了一个region，并插入一个entry block</li>
<li><code>builder.setInsertionPointToEnd(entry)</code> 调整插入的位置，否则指令会插入在函数的外面 (<code>func.func</code> Op的下一条指令)</li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/gallery/head-portrial.jpg" alt="ReRoozen"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ReRoozen</p><p class="is-size-6 is-block">I need more power!!!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Within Heaven and Hell</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Benchmarks/"><span class="level-start"><span class="level-item">Benchmarks</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CMAKE/"><span class="level-start"><span class="level-item">CMAKE</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Patterns-in-CPP/"><span class="level-start"><span class="level-item">Design Patterns in CPP</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/LLVM/"><span class="level-start"><span class="level-item">LLVM</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/LLVM-Meetings/"><span class="level-start"><span class="level-item">LLVM Meetings</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/MLIR/"><span class="level-start"><span class="level-item">MLIR</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Modern-CPP/"><span class="level-start"><span class="level-item">Modern CPP</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/PFPL/"><span class="level-start"><span class="level-item">PFPL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Performance-Profiling/"><span class="level-start"><span class="level-item">Performance Profiling</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Polyhedral/"><span class="level-start"><span class="level-item">Polyhedral</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Writing/"><span class="level-start"><span class="level-item">Writing</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/vim/"><span class="level-start"><span class="level-item">vim</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-16T05:24:08.000Z">2024-04-16</time></p><p class="title"><a href="/2024/04/16/PerformanceMeasuring/02-MemoryHierarchical/">02-Measuring Memory Hierarchy</a></p><p class="categories"><a href="/categories/Performance-Profiling/">Performance Profiling</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-16T01:48:32.000Z">2024-04-16</time></p><p class="title"><a href="/2024/04/16/PerformanceMeasuring/01-CPU/">01-Measuring CPU Time</a></p><p class="categories"><a href="/categories/Performance-Profiling/">Performance Profiling</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-06T10:34:12.000Z">2024-04-06</time></p><p class="title"><a href="/2024/04/06/DesingnPatterns/1-CreationalPattern/">1-CreationalPattern</a></p><p class="categories"><a href="/categories/Design-Patterns-in-CPP/">Design Patterns in CPP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-05T12:19:36.000Z">2024-04-05</time></p><p class="title"><a href="/2024/04/05/DesingnPatterns/0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/">Prequest knowledge</a></p><p class="categories"><a href="/categories/Design-Patterns-in-CPP/">Design Patterns in CPP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-03T08:03:39.000Z">2024-04-03</time></p><p class="title"><a href="/2024/04/03/CPPTemplate/9-Require%E5%92%8Cconcept/">9-Require and concept</a></p><p class="categories"><a href="/categories/Modern-CPP/">Modern CPP</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">八月 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="ReRoozen&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 ReRoozen</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2024</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>